{"pages":[{"title":"About","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. 概況本人就讀於廣州大學，主要是弄JAVA WEB。現在學習goLang和安卓開發 More info: Writing 簡歷More info: Writing 聯繫我 Email:**@gmail.com","link":"/about/index.html"},{"title":"archives","text":"","link":"/archives/index.html"},{"title":"","text":"title: “Tags”","link":"/tags/index.html"},{"title":"","text":"title: “Categories”","link":"/categories/index.html"}],"posts":[{"title":"詞法分析 DFA 程序","text":"實驗一：詞法分析實驗目的:通過DFA程式的實現理解自動機的原理 實驗內容：1、閱讀並理解實驗案例中DFA的程式實現；2、參考實驗案例，完成簡單的DFA程式設計。 實驗要求：請對下列程式進行詞法分析，判斷是否字串“abbb”將被識別或通過在FA接受？1、假定FA=（{0,1,2,3}, {a,b}, M, 0, {3}） M： M(0,a)=1 M(0,b)=2 M(1,a)=3 M(1,b)=2 M(2,a)=1 M(2,b)=3 M(3,a)=3 M(3,b)=3確定化後的DFA為： 參考代碼：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147#include &lt;stdio.h&gt;int in(int s,int z){if (s==z){printf(\"3\\n这个最后状态跳转到终态!\");return 1;}else return 0;}int step (int s,char t){ if(t=='a')switch(s){case 0: return 1;case 1: return 3;case 2: return 1;case 3: return 3;}else if (t=='b')switch(s){case 0: return 2;case 1: return 2;case 2: return 3;case 3: return 3;}return 0;}int realize(char *input){ int z=3;int s,i;s=0;for(i=0;input[i]!='\\n';i++){ printf(\"%d\\n\",s); s=step(s,input[i]);} if (in(s,z))return 1;else return 0;}main(){ int i;int a;char input[40]; printf(\"FA=({0,1,2,3}, {a,b}, M, 0, {3})\\n\");printf(\"M:\\n\"); printf(\" M(0,a)=1 M(0,b)=2\\n\");printf(\" M(1,a)=3 M(1,b)=2\\n\"); printf(\" M(2,a)=1 M(2,b)=3\\n\"); printf(\" M(3,a)=3 M(3,b)=3\\n\");printf(\"请输入要检查的字符串:\\n\");lop: for(i=0;input[i-1]!='\\n';i++)scanf(\"%c\",&amp;input[i]);for(i=0;input[i-1]!='\\n';i++)if(input[i]!='a'&amp;&amp;input[i]!='b'&amp;&amp;input[i]!='\\n'){printf(\"输入错误，请重新输入:\\n\");goto lop;}printf(\"这个状态转换为:\\n\");a=realize(input);if(a==1)printf(\"\\n这个字符串不能识别\\n\");else printf(\"\\n这个字符串不能识别n\");printf(\"请回车离开此程序\\n\");getchar();} 實驗結果：測試數據：aab 測試結果：0 1 3 3","link":"/2016/05/07/DFA-program/"},{"title":"Hexo GitHub搭建個人博客","text":"概況為何使用Hexo呢？Hexo非常強大而且免費開源，作為程式員怎麼能不使用它呢。 環境配置之前我們已經講到，安裝好了Node.js和GitHub了。現在我們就使用Node.js生成靜態頁面吧 安裝配置Hexo首先在本地的磁盤上新建一個檔案hexo，用來把hexo生成的靜態頁面存放到那裡。然後右鍵打開Git Bush,輸入下面的命令 $ npm install hexo-cli -g本人輸入完之後，發生錯誤，結果網上查了一下，發現有兩種情況。 其一、Node.js版本太低，建議升級。把之前舊版本的Node.js卸載掉，重裝最新版本（本人不是這個問題）； 其二、是因為之前使用命令安裝失敗，結果再次重裝失敗，建議清除緩存，輸入以下命令；1$ npm cache clean 結果成功了 安裝靜態頁面1$ hexo init 安裝依賴包1$ npm install 現在我們已經搭建起本地的hexo博客了，執行以下命令(在D:\\hexo)我的在D盤，然後到遊覽器輸入localhost:4000看看。12$ hexo generate$ hexo server 好了，至此，本地博客已經搭建起來了，只是本地哦，別人看不到的。下麵，我們要部署到Github。 部署編輯_config.yml(在D:\\hexo下)。你在部署時，要把下麵的username都換成你的帳號名。在文件最後插入以下配置1234deploy: type: github repository: https://github.com/username/username.github.io.git branch: master 創建repository創建repository上一節我我已經講過，詳情去看看上一節。比如現在我的GitHub帳號是auhanjie，auhanjie.github.io千萬要按照這個來命名，獨一無二的，要不然的話，是訪問不了的。 执行下列指令即可完成部署。123deploy:$ hexo generate$ hexo deploy 也可以123deploy:$ hexo g$ hexo d 建議部署前清理一下輸入以下命令12deploy:$ hexo clean 成功，我們的博客已經在GitHub部署起來了，那麼在遊覽器輸入你的域名username.github.io開展你的博客之旅吧。","link":"/2016/03/20/Hexo/"},{"title":"Hibernate緩存原理","text":"今天面試Hibernate緩存原理答不上來，太久沒看過基礎，以至於有點慌張，現在總結幫助以後面試發揮。Hibernate緩存原理: 對於Hibernate這類ORM而言,緩存顯的尤為重要,它是持久層性能提升的關鍵.簡單來講Hibernate就是對JDBC進行封裝,以實現內部狀態的管理,OR關係的映射等,但隨之帶來的就是數據訪問效率的降低,和性能的下降,而緩存就是彌補這一缺點的重要方法. 緩存就是資料庫數據在內存中的臨時容器,包括資料庫數據在內存中的臨時拷貝,它位於資料庫與資料庫訪問層中間.ORM在查詢數據時首先會根據自身的緩存管理策略,在緩存中查找相關數據,如發現所需的數據,則直接將此數據作為結果加以利用,從而避免了資料庫調用性能的開銷.而相對記憶體操作而言,資料庫調用是一個代價高昂的過程. 一般來講ORM中的緩存分為以下幾類: 1.事務級緩存:即在當前事務範圍內的數據緩存.就Hibernate來講,事務級緩存是基於Session的生命週期實現的,每個Session內部會存在一個數據緩存,它隨著Session的創建而存在,隨著Session的銷毀而滅亡,因此也稱為Session Level Cache. 2.應用級緩存:即在某個應用中或應用中某個獨立資料庫訪問子集中的共用緩存,此緩存可由多個事務共用(資料庫事務或應用事務),事務之間的緩存共用策略與應用的事務隔離機制密切相關.在Hibernate中,應用級緩存由SessionFactory實現,所有由一個SessionFactory創建的 Session實例共用此緩存,因此也稱為SessionFactory Level Cache. 3.分佈式緩存:即在多個應用實例,多個JVM間共用的緩存策略.分佈式緩存由多個應用級緩存實例組成,通過某種遠程機制(RMI,JMS)實現各個緩存實例間的數據同步,任何一個實例的數據修改,將導致整個集群間的數據狀態同步. Hibernate的一，二級緩存策略: Hibernate中提供了兩級Cache，第一級別的緩存是Session級別的緩存，它是屬於事務範圍的緩存。這一級別的緩存由hibernate管理的，一般情況下無需進行干預；第二級別的緩存是SessionFactory級別的緩存，它是屬於進程範圍或群集範圍的緩存。這一級別的緩存可以進行配置和更改，並且可以動態加載和卸載，屬於多事務級別，要防止事務併發性。緩存是以map的形式進行存儲的(key-id,value-object)一級緩存(Session): 事務範圍，每個事務(Session)都有單獨的第一級緩存. 一級緩存的管理：當應用程式調用Session的save()、update()、saveOrUpdate()、get()或load()，以及調用查詢介面的 list()、iterate()–(用的是n+1次查詢，先查id)或filter()方法時，如果在Session緩存中還不存在相應的對象，Hibernate就會把該對象加入到第一級緩存中。當清理緩存時，Hibernate會根據緩存中對象的狀態變化來同步更新資料庫。 Session為應用程式提供了兩個管理緩存的方法： evict(Object obj)：從緩存中清除參數指定的持久化對象。 clear()：清空緩存中所有持久化對象,flush():使緩存與資料庫同步。當查詢相應的字段如(name)，而不是對象時，不支持緩存。二級緩存(SessionFactory): Hibernate的二級緩存策略的一般過程如下： 1.條件查詢的時候，總是發出一條select * from table_name where …. （選擇所有字段）這樣的SQL句查詢資料庫，一次獲得所有的數據對象(這個問題要考慮，如果你查詢十萬條數據時，記憶體不是被佔用)。 2.把獲得的所有數據對象根據ID放入到第二級緩存中。 3.當Hibernate根據ID訪問數據對象的時候，首先從Session一級緩存中查；查不到，如果配置了二級緩存，那麼從二級緩存中查；查不到，再查詢資料庫，把結果按照ID放入到緩存。 4.刪除、更新、增加數據的時候，同時更新緩存。Hibernate的二級緩存策略，是針對於ID查詢的緩存策略，對於條件查詢則毫無作用。為此，Hibernate提供了針對條件查詢的Query Cache。 Q:什麼樣的數據適合存放到第二級緩存中？ 1.很少被修改的數據 2.不是很重要的數據，允許出現偶爾併發的數據 3.不會被併發訪問的數據 4.參考數據,指的是供應用參考的常量數據，它的實例數目有限，它的實例會被許多其他類的實例引用，實例極少或者從來不會被修改。 不適合存放到第二級緩存的數據？ 1.經常被修改的數據 2.財務數據，絕對不允許出現併發 3.與其他應用共用的數據。 常用的緩存插件 Hibernater 的二級緩存是一個插件，下麵是幾種常用的緩存插件： EhCache：可作為進程範圍的緩存，存放數據的物理介質可以是記憶體或硬碟，對Hibernate的查詢緩存提供了支持。 OSCache：可作為進程範圍的緩存，存放數據的物理介質可以是記憶體或硬碟，提供了豐富的緩存數據過期策略，對Hibernate的查詢緩存提供了支持。 SwarmCache：可作為群集範圍內的緩存，但不支持Hibernate的查詢緩存。 JBossCache：可作為群集範圍內的緩存，支持事務型併發訪問策略，對Hibernate的查詢緩存提供了支持。 配置二級緩存的主要步驟： 1.選擇需要使用二級緩存的持久化類，設置它的命名緩存的併發訪問策略。這是最值得認真考慮的步驟。 2.選擇合適的緩存插件，然後編輯該插件的配置檔。","link":"/2016/09/25/HibernateCache/"},{"title":"怎麼安裝 MinGW (GCC) 編譯器套件","text":"使用GUI自動安裝程式如果你是MinGW的新手，一個好的方法是從下載。 下載並運行安裝程式(例如 “MinGW-5.1.4.exe” – 當前唯一“建議”的版本)。這個安裝程式會安裝 mingw-runtime, w32api, GCC, binutils 和 mingw32-make, (不過它可能不會安裝最新發佈的獨立版本)。比如 GCC，只須把它們解壓到MinGW目錄即可。 警告默認的安裝路徑是C:\\MinGW，這也是安裝包預配置的路徑。如果你不肯定你知道怎麼做的話，你就不應該改變它。特別是：絕對不要把MinGW安裝到含有空格的路徑中去。 安裝包不會自動改變環境設定，(特指PATH)。 你需要添加 MinGW 的bin 路徑到環境變數中。","link":"/2016/05/04/MinGW/"},{"title":"Picked up JAVA_TOOL_OPTIONS: -agentlib:jvmhook","text":"12345678910111213刪除用戶變量中的JAVA_TOOL_OPTIONS後正常_JAVA_OPTIONS-Xrunjvmhook -Xbootclasspath/a:C:\\PROGRA~2\\HP\\QUICKT~1\\bin\\JAVA_S~1\\classes;C:\\PROGRA~2\\HP\\QUICKT~1\\bin\\JAVA_S~1\\classes\\jasmine.jarJAVA_TOOL_OPTIONS-agentlib:jvmhookIBM_JAVA_OPTIONS-Xrunjvmhook -Xbootclasspath/a:C:\\PROGRA~2\\HP\\QUICKT~1\\bin\\JAVA_S~1\\classes;C:\\PROGRA~2\\HP\\QUICKT~1\\bin\\JAVA_S~1\\classes\\jasmine.jar_JAVA_OPTIONS-Xrunjvmhook -Xbootclasspath/a:C:\\PROGRA~2\\HP\\QUICKT~1\\bin\\JAVA_S~1\\classes;C:\\PROGRA~2\\HP\\QUICKT~1\\bin\\JAVA_S~1\\classes\\jasmine.jar","link":"/2016/05/28/Picked-up-JAVA-TOOL-OPTIONS-agentlib-jvmhook/"},{"title":"ORA-28001: the password has expired","text":"Oracle 提示錯誤消息ORA-28001: the password has expired，是由於Oracle11G的新特性所致， Oracle11G創建用戶時缺省密碼過期限制是180天（即6個月）， 如果超過180天用戶密碼未做修改則該用戶無法登錄。 Oracle公司是為了資料庫的安全性默認在11G中引入了這個默認功能，但是這個默認的功能很容易被DBA或者是開發人員給疏忽，一旦密碼180天未修 改過，就會出現這樣的問題。解決方法可通過如下SQL語句注: 首先需要使用dba登錄.運行SQLPlus命令行工具, 輸入:1connect as sysdba; 輸入dba的用戶名和密碼後進行.1SELECT * FROM dba_profiles WHERE profile='DEFAULT' AND resource_name='PASSWORD_LIFE_TIME' 查詢密碼的有效期設置，LIMIT字段是密碼有效天數。在密碼將要過期或已經過期時可通過如下語句進行修改密碼，密碼修改後該用戶可正常連接資料庫。12ALTER USER 用戶名 IDENTIFIED BY 密碼 ; 如果想去除180天的密碼生存週期的限制可通過如下SQL語句將其關閉1ALTER PROFILE DEFAULT LIMIT PASSWORD_LIFE_TIME UNLIMITED 如上SQL語句將口令有效期默認值180天修改成了“無限制”。但是出於資料庫安全性考慮，不建議將PASSWORD_LIFE_TIME值設置成UNLIMITED，建議大家定期修改資料庫用戶口令。","link":"/2016/05/28/ORA-28001-the-password-has-expired/"},{"title":"Web前端程序员简历模板","text":"Web前端程序员简历模板本简历模板由国内首家互联网人才拍卖网站「 JobDeer.com 」提供。 （括号里的是我们的顾问编写的说明，建议在简历书写完成后统一删除） 先讲讲怎样才是一份好的技术简历首先，一份好的简历不光说明事实，更通过FAB模式来增强其说服力。 Feature：是什么 Advantage：比别人好在哪些地方 Benefit：如果雇佣你，招聘方会得到什么好处 其次，写简历和写议论文不同，过分的论证会显得自夸，反而容易引起反感，所以要点到为止。这里的技巧是，提供论据，把论点留给阅读简历的人自己去得出。放论据要具体，最基本的是要数字化，好的论据要让人印象深刻。 举个例子，下边内容是虚构的： 2006年，我参与了手机XX网发布系统WAPCMS的开发（这部分是大家都会写的）。作为核心程序员，我不但完成了网站界面、调度队列的开发工作，更提出了高效的组件级缓存系统，通过碎片化缓冲有效的提升了系统的渲染效率。（这部分是很多同学忘掉的，要写出你在这个项目中具体负责的部分，以及你贡献出来的价值。）在该系统上线后，Web前端性能从10QPS提升到200QPS，服务器由10台减少到3台（通过量化的数字来增强可信度）。2008年我升任WAPCMS项目负责人，带领一个3人小组支持着每天超过2亿的PV（这就是Benefit。你能带给前雇主的价值，也就是你能带给新雇主的价值。）。 有同学问，如果我在项目里边没有那么显赫的成绩可以说怎么办？讲不出成绩时，就讲你的成长。因为学习能力也是每家公司都看中的东西。你可以写你在这个项目里边遇到了一个什么样的问题，别人怎么解决的，你怎么解决的，你的方案好在什么地方，最终这个方案的效果如何。 具体、量化、有说服力，是技术简历特别需要注重的地方。 （以上内容在写完简历后，对每一段进行评估，完成后再删除） 联系方式（HR会打印你的简历，用于在面试的时候联系，所以联系方式放到最上边会比较方便） 手机：135** （如果是外地手机，可注明。如经常关机，要写上最优联系时间） Email：goodman@gmail.com （虽然我觉得QQ邮箱无所谓，不过有些技术人员比较反感，建议用G） QQ/微信号：6*（提供一个通过网络可以联系到你的方式） 个人信息 胶布帝/男/1990 本科/萌鹿大学计算机系 工作年限：3年 微博：@JobDeer （如果没有技术相关内容，也可以不放） 技术博客：http://blog.github.io ( 使用GitHub Host的Big较高 ) Github: http://github.com/geekcompany ( 有原创repo的Github帐号会极大的提升你的个人品牌 ) 期望职位：Web前端高级程序员，应用架构师 期望薪资：税前月薪15k~20k，特别喜欢的公司可例外 期望城市：北京 工作经历（工作经历按逆序排列，最新的在最前边，按公司做一级分组，公司内按二级分组） ABC公司 （ 2012年9月 ~ 2014年9月 ）DEF项目我在此项目负责了哪些工作，分别在哪些地方做得出色/和别人不一样/成长快，这个项目中，我最困难的问题是什么，我采取了什么措施，最后结果如何。这个项目中，我最自豪的技术细节是什么，为什么，实施前和实施后的数据对比如何，同事和领导对此的反应如何。 GHI项目我在此项目负责了哪些工作，分别在哪些地方做得出色/和别人不一样/成长快，这个项目中，我最困难的问题是什么，我采取了什么措施，最后结果如何。这个项目中，我最自豪的技术细节是什么，为什么，实施前和实施后的数据对比如何，同事和领导对此的反应如何。 其他项目（每个公司写2~3个核心项目就好了，如果你有非常大量的项目，那么按分类进行合并，每一类选一个典型写出来。其他的一笔带过即可。） JKL公司 （ 2010年3月 ~ 2012年8月 ）MNO项目我在此项目负责了哪些工作，分别在哪些地方做得出色/和别人不一样/成长快，这个项目中，我最困难的问题是什么，我采取了什么措施，最后结果如何。这个项目中，我最自豪的技术细节是什么，为什么，实施前和实施后的数据对比如何，同事和领导对此的反应如何。 PQR项目我在此项目负责了哪些工作，分别在哪些地方做得出色/和别人不一样/成长快，这个项目中，我最困难的问题是什么，我采取了什么措施，最后结果如何。这个项目中，我最自豪的技术细节是什么，为什么，实施前和实施后的数据对比如何，同事和领导对此的反应如何。 其他项目（每个公司写2~3个核心项目就好了，如果你有非常大量的项目，那么按分类进行合并，每一类选一个典型写出来。其他的一笔带过即可。） 开源项目和作品（这一段用于放置工作以外的、可证明你的能力的材料） 开源项目（对于程序员来讲，没有什么比Show me the code能有说服力了） STU : 项目的简要说明，Star和Fork数多的可以注明 WXYZ : 项目的简要说明，Star和Fork数多的可以注明 技术文章（挑选你写作或翻译的技术文章，好的文章可以从侧面证实你的表达和沟通能力，也帮助招聘方更了解你） 一个产品经理眼中的云计算：前生今世和未来 来自HeroKu的HTTP API 设计指南(翻译文章) （ 好的翻译文章可以侧证你对英文技术文档的阅读能力） 演讲和讲义（放置你代表公司在一些技术会议上做过的演讲，以及你在公司分享时制作的讲义） 2014架构师大会演讲：如何通过Docker优化内部开发 9月公司内部分享：云计算的前生今世 技能清单（我一般主张将技能清单写入到工作经历里边去。不过很难完整，所以有这么一段也不错） 以下均为我熟练使用的技能 Web开发：PHP/Hack/Node Web框架：ThinkPHP/Yaf/Yii/Lavaral/LazyPHP 前端框架：Bootstrap/AngularJS/EmberJS/HTML5/Cocos2dJS/ionic 前端工具：Bower/Gulp/SaSS/LeSS/PhoneGap 数据库相关：MySQL/PgSQL/PDO/SQLite 版本管理、文档和自动化部署工具：Svn/Git/PHPDoc/Phing/Composer 单元测试：PHPUnit/SimpleTest/Qunit 云和开放平台：SAE/BAE/AWS/微博开放平台/微信应用开发 参考技能关键字本技能关键字列表是从最近招聘Web前端的数百份JD中统计出来的，括号中是出现的词频。如果你的简历要投递给有机器（简历分选系统）和不如机器（不懂技术的HR）筛选简历环节的地方，请一定从下边高频关键词中选择5～10个适合你自己的。 web(889) javascript(596) css(555) html(430) jquery(323) html5(312) js(311) ajax(196) css3(176) w3c(168) div(156) php(134) xhtml(106) java(92) ui(78) photoshop(75) dom(63) xml(56) json(54) yui(51) flash(45) bootstrap(43) python(43) http(38) dreamweaver(38) ext(33) linux(33) seo(32) prototype(29) chrome(28) pc(28) nodejs(28) firefox(26) ps(25) angularjs(25) fireworks(24) extjs(23) safari(22) www(22) mobile(22) jsp(22) mvc(22) backbone(21) node(21) ruby(20) github(19) ios(18) ie6(18) android(18) asp(18) sass(17) wap(16) mootools(16) ie(16) mysql(15) flex(14) firebug(13) bom(13) webapp(12) less(12) web2(11) angular(10) git(10) dw(10) as(10) mac(10) psd(8) o2o(7) dojo(7) actionscript3(6) grunt(5) ue(5) zepto(5) actionscript(5) ie8(5) coffeescript(5) django(4) 致谢感谢您花时间阅读我的简历，期待能有机会和您共事。","link":"/2017/03/24/Web前端程序员简历模板/"},{"title":"在Eclipse或MyEclipse 2014中安裝findbugs插件","text":"Eclipse中安裝findbugs插件Eclipse中安裝findbugs插件(就不一一贅述了) MyEclipse中安裝findbugs插件下載findbugs修改MyEclipse安装目录下configuration\\org.eclipse.equinox.simpleconfigurator的bundles.info檔案，在檔案最後添加一行：將官網下載的findbugs包放到MyEclipse安装目录下\\pluginsMyEclipse： edu.umd.cs.findbugs.plugin.eclipse,3.0.1.20150306-5afe4d1,file:/C:/Myeclipse/plugins/edu.umd.cs.findbugs.plugin.eclipse_3.0.1.20150306-5afe4d1/,4,false注：bundles.info檔案中添加的格式為 插件包名 , 插件版本號 , 插件安裝路徑 , 4 , false如上findbugs插件： edu.umd.cs.findbugs.plugin.eclipse：插件的壓縮包名 3.0.1.20150306-5afe4d1：該插件的版本號 plugins/edu.umd.cs.findbugs.plugin.eclipse_3.0.1.20150306-5afe4d1/ ：該插件的安裝路徑，如果插件是一个jar包，则不要最後的/， 例如plugins/org.uddi4j_2.0.5.v200805270300.jar,4,false ,4,false：固定格式 重启myeclipse和Eclipse，選中項目，右鍵會出現Find Bugs菜单。至此，findbugs插件安裝成功。","link":"/2016/05/10/findbugs/"},{"title":"How to ORDER BY FIELD VALUE in MongoDB","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465db.getCollection('form').aggregate([{ '$project': { 'name': 1, 'code': 1, 'handlerUserId': 1, 'handlerName': 1, 'reviewerUserId': 1, 'reviewerName': 1, 'createdUserId': 1, 'createdUserName': 1, 'address': 1, 'tnNumber': 1, 'createdDate': 1, 'updatedDate': 1, 'description': 1, 'formId': 1, 'formNo': 1, 'showFormNo': 1, 'jsonObject': 1, 'formTypeId': 1, 'version': 1, 'supervisorStatus': 1, 'supervisorStatusId': { $switch: { branches: [ { case: { $eq : [ '$supervisorStatus', \"FORM_NOT_SUBMITTED\" ] }, then: 5 }, { case: { $eq : [ '$supervisorStatus', \"FORM_PROCESSING\" ] }, then: 4 }, { case: { $eq : [ '$supervisorStatus', \"FORM_SUBMITTED_FOR_REVIEW\" ] }, then: 3 }, { case: { $eq : [ '$supervisorStatus', \"FORM_APPROVED\" ] }, then: 2 }, { case: { $eq : [ '$supervisorStatus', \"FORM_AUDIT_WAS_REJECTED\" ] }, then: 1 } ], default: 0 } } }},{ \"$sort\": { \"weight\": -1 }}, { \"$skip\" : 0}, { \"$limit\" : 20},]) 12345678910111213141516171819202122232425262728293031ProjectionOperation projectOperation = project(\"name\", \"code\", \"handlerUserId\", \"handlerName\", \"reviewerUserId\", \"reviewerName\", \"createdUserId\", \"createdUserName\", \"address\", \"tnNumber\", \"createdDate\", \"updatedDate\", \"description\", \"formId\", \"formNo\", \"showFormNo\", \"supervisorStatus\", \"formTypeId\", \"version\") .and(ConditionalOperators.switchCases( ConditionalOperators.Switch.CaseOperator.when( ComparisonOperators.Eq.valueOf(\"$supervisorStatus\").equalToValue(FormConstant.FORM_STATUS_APPROVED.getKey())) .then(5), ConditionalOperators.Switch.CaseOperator.when( ComparisonOperators.Eq.valueOf(\"$supervisorStatus\").equalToValue(FormConstant.FORM_STATUS_AUDIT_WAS_REJECTED.getKey())) .then(4), ConditionalOperators.Switch.CaseOperator.when( ComparisonOperators.Eq.valueOf(\"$supervisorStatus\").equalToValue(FormConstant.FORM_STATUS_SUBMITTED_FOR_REVIEW.getKey())) .then(3), ConditionalOperators.Switch.CaseOperator.when( ComparisonOperators.Eq.valueOf(\"$supervisorStatus\").equalToValue(FormConstant.FORM_STATUS_NOT_SUBMITTED.getKey())) .then(2), ConditionalOperators.Switch.CaseOperator.when( ComparisonOperators.Eq.valueOf(\"$supervisorStatus\").equalToValue(FormConstant.FORM_STATUS_PROCESSING.getKey())) .then(1)).defaultTo(0) ).as(\"supervisorStatusId\"); SortOperation sortOperation = sort(DESC, \"supervisorStatusId\"); SkipOperation skipOperation = new SkipOperation(formListSearchDto.getOffset()); LimitOperation limitOperation = limit(formListSearchDto.getLimit()); TypedAggregation&lt;Form&gt; agg = newAggregation(Form.class, projectOperation, sortOperation, skipOperation, limitOperation ); AggregationResults&lt;Form&gt; result = mongoTemplate.aggregate(agg, \"form\", Form.class); List&lt;Form&gt; stateStatsList = result.getMappedResults(); long count = this.mongoTemplate.count(query, Form.class); page = new PageImpl(stateStatsList, pageable, count);","link":"/2020/01/03/how-to-order-by-field-value-in-mongodb/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new \"My New Post\" More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","link":"/2019/06/03/hello-world/"},{"title":"華師校招","text":"table1 序號 日期 客戶人數 01 1 1000 02 2 2000 03 1 1000 查询SQL如下 序號 日期 客戶人數 01 1 1000 02 2 2000 123SELECT distinct t.日期,t.`客户人数`FROM table1 tORDER BY t.序号 多線程安全有什麽解決方式，樂觀鎖和悲觀鎖 Stringmvc的特性 單例模式和工廠模式有什麽不同 容器有什麽作用 数据库索引","link":"/2016/10/22/huashrsiaujhau/"},{"title":"java面试","text":"1、Spring Bean 的生命周期 Spring 容器 从 XML 文件中读取 bean 的定义，并实例化 bean。 Spring 根据 bean 的定义填充所有的属性。 如果 bean 实现了 BeanNameAware 接口， Spring 传递 bean 的 ID 到setBeanName 方法。 如果 Bean 实现了 BeanFactoryAware 接口， Spring 传递 beanfactory 给setBeanFactory 方法。 如果有任何与bean相关联的BeanPostProcessors ， Spring 会 在postProcesserBeforeInitialization()方法内调用它们。 如果 bean 实现 IntializingBean 了，调用它的 afterPropertySet 方法，如果 bean 声明了初始化方法，调用此初始化方法。 如 果 有BeanPostProcessors和bean关 联 ， 这 些bean的postProcessAfterInitialization() 方法将被调用。 如果 bean 实现了 DisposableBean，它将调用 destroy()方法。 2、反射机制Spring 是依赖反射机制的， 那到底什么是反射机制呢： 反射机制就是利用（dom4j=java 反射机制） userBean ub = Class.forName（com.bean.*）这里是 com 全路径 所以在 Spring 配置文件中 bean 的 id 属性和 class 属性中要写全路径。 3、HashSet底层实现对于HashSet而言，它是基于HashMap实现的，HashSet底层使用HashMap来保存所有元素，因此HashSet 的实现比较简单，相关HashSet的操作，基本上都是直接调用底层HashMap的相关方法来完成，在HashSet中，元素都存到HashMap键值对的Key上面，而Value时有一个统一的值private static final Object PRESENT = new Object();。 4、TreeSet 底层源码有看过吗？类似于HashMap和HashSet之间的关系，HashSet底层依赖于HashMap实现，TreeSet底层则采用一个NavigableMap来保存TreeSet集合的元素。但实际上，由于NavigableMap只是一个接口，因此底层依然是使用TreeMap来包含Set集合中的所有元素。 5、重载和重写区别方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实 现的是运行时的多态性。 扩展； 重载(Overloading) 重载的时候，方法名要一样，但是参数类型和个数不一样，返回值类型可以相同也可以 不相同。无法以返回型别作为重载函数的区分标准。 重写（Overriding） 父类与子类之间的多态性，对父类的函数进行重新定义。如果在子类中定义某方法与其 父类有相同的名称和参数，我们说该方法被重写 (Overriding)。在 Java 中，子类可继承父类 中的方法，而不需要重新编写相同的方法。但有时子类并不想原封不动地继承父类的方法， 而是想作一定的修改，这就需要采用方法的重写。 方法重写又称方法覆盖 （2）若子类中的方法与父类中的某一方法具有相同的方法名、返回类型和参数表，则 新方法将覆盖原有的方法。 如需父类中原有的方法，可使用 super 关键字，该关键字引用了当前类的父类。 （3）子类函数的访问修饰权限不能少于父类的；","link":"/2018/08/23/java/"},{"title":"6-1 简单输出整数（10 分）","text":"6-1 简单输出整数（10 分）本题要求实现一个函数，对给定的正整数N，打印从1到N的全部正整数。 函数接口定义：1void PrintN ( int N ); 其中N是用户传入的参数。该函数必须将从1到N的全部正整数顺序打印出来，每个数字占1行。 裁判测试程序样例：123456789101112131415#include &lt;stdio.h&gt;void PrintN ( int N );int main (){ int N; scanf(\"%d\", &amp;N); PrintN( N ); return 0;}/* 你的代码将被嵌在这里 */ 输入样例：13 输出样例：123123 12345678910111213141516171819202122#include &lt;stdio.h&gt;void PrintN ( int N );int main (){ int N; scanf(\"%d\", &amp;N); PrintN( N ); return 0;}void PrintN(int N){ int i; for(i=1;i&lt;=N;i++) { printf(\"%d\\n\",i); }}","link":"/2018/04/13/jichu6-1/"},{"title":"6-10 阶乘计算升级版（20 分）","text":"6-10 阶乘计算升级版（20 分）本题要求实现一个打印非负整数阶乘的函数。 函数接口定义：1void Print_Factorial ( const int N ); 其中N是用户传入的参数，其值不超过1000。如果N是非负整数，则该函数必须在一行中打印出N!的值，否则打印“Invalid input”。 裁判测试程序样例：1234567891011121314#include &lt;stdio.h&gt;void Print_Factorial ( const int N );int main(){ int N; scanf(\"%d\", &amp;N); Print_Factorial(N); return 0;}/* 你的代码将被嵌在这里 */ 输入样例：115 输出样例：11307674368000 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;stdio.h&gt;void Print_Factorial ( const int N );int main(){ int N; scanf(\"%d\", &amp;N); Print_Factorial(N); return 0;}void Print_Factorial ( const int N ){ long i,s=1; if(N&gt;=0&amp;&amp;N&lt;=12){ for(i=2 ;i&lt;=N ;i++){ s *= i; } printf(\"%ld\\n\",s); } else if(N&gt;12&amp;&amp;N&lt;=1000){ int num[3000] = {0}; num[0] = 1; int k=1; //位数 int n=0; //进位 int temp; for(int i=2 ;i&lt;=N ;i++){ for(int j=0;j&lt;k;j++){ temp = num[j]*i+n; //每一位相乘 再+进位 num[j] = temp%10; //更新每一位的数字 n = temp/10; //判断能否进位 } while(n!=0){ //如果可以进位 num[k] = n%10; //新增一位 n /=10; //继续判断能否进位 k++; } } for(int x=k-1;x&gt;=0;x--){ //输出数字 printf(\"%d\",num[x]); } } else{ printf(\"%s\\n\",\"Invalid input\"); } }","link":"/2018/04/13/jichu6-10/"},{"title":"6-11 求自定类型元素序列的中位数（25 分）","text":"6-11 求自定类型元素序列的中位数（25 分）本题要求实现一个函数，求N个集合元素A[]的中位数，即序列中第⌊N/2+1⌋大的元素。其中集合元素的类型为自定义的ElementType。 函数接口定义：1ElementType Median( ElementType A[], int N ); 其中给定集合元素存放在数组A[]中，正整数N是数组元素个数。该函数须返回N个A[]元素的中位数，其值也必须是ElementType类型。 裁判测试程序样例：123456789101112131415161718192021#include &lt;stdio.h&gt;#define MAXN 10typedef float ElementType;ElementType Median( ElementType A[], int N );int main (){ ElementType A[MAXN]; int N, i; scanf(\"%d\", &amp;N); for ( i=0; i&lt;N; i++ ) scanf(\"%f\", &amp;A[i]); printf(\"%.2f\\n\", Median(A, N)); return 0;}/* 你的代码将被嵌在这里 */ 输入样例：12312.3 34 -5 输出样例：112.30 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;stdio.h&gt;#define MAXN 10typedef float ElementType;ElementType Median( ElementType A[], int N );int main (){ ElementType A[MAXN]; int N, i; scanf(\"%d\", &amp;N); for ( i=0; i&lt;N; i++ ) scanf(\"%f\", &amp;A[i]); printf(\"%.2f\\n\", Median(A, N)); return 0;}void shell_sort(ElementType A[],int N);ElementType Median(ElementType A[],int N){ if(N==1) return A[0]; shell_sort(A,N); return A[N/2];}void shell_sort(ElementType A[],int N){ int i,j,gap; for(gap=N/2;gap&gt;0;gap/=2) for(i=gap;i&lt;N;i++) for(j=i-gap;j&gt;=0&amp;&amp;A[j]&gt;A[j+gap];j-=gap) { ElementType temp=A[j]; A[j]=A[j+gap]; A[j+gap]=temp; }}","link":"/2018/04/13/jichu6-11/"},{"title":"6-13 折半查找（15 分）","text":"6-13 折半查找（15 分）给一个严格递增数列，函数int binSearch(SeqList T, KeyType k)用来二分地查找k在数列中的位置。 函数接口定义：1int binSearch(SeqList T, KeyType k) 其中T是有序表，k是查找的值。 裁判测试程序样例：1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;using namespace std;#define MAXLEN 50typedef int KeyType;typedef struct { KeyType key; } elementType; typedef struct{ elementType data[MAXLEN+1]; int len;} SeqList; void creat(SeqList &amp;L){ int i; cin&gt;&gt;L.len; for(i=1;i&lt;=L.len;i++) cin&gt;&gt;L.data[i].key; }int binSearch(SeqList T, KeyType k);int main () { SeqList L; KeyType k; creat(L); cin&gt;&gt;k; int pos=binSearch(L,k); if(pos==0) cout&lt;&lt;\"NOT FOUND\"&lt;&lt;endl; else cout&lt;&lt;pos&lt;&lt;endl; return 0;}/* 请在这里填写答案 */ 输入格式：第一行输入一个整数n，表示有序表的元素个数，接下来一行n个数字，依次为表内元素值。 然后输入一个要查找的值。 输出格式：输出这个值在表内的位置，如果没有找到，输出”NOT FOUND”。 输入样例：12351 3 5 7 97 输出样例：14 输入样例：12351 3 5 7 910 输出样例：1NOT FOUND 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;iostream&gt;using namespace std;#define MAXLEN 50typedef int KeyType;typedef struct { KeyType key; } elementType; typedef struct{ elementType data[MAXLEN+1]; int len;} SeqList; void creat(SeqList &amp;L){ int i; cin&gt;&gt;L.len; for(i=1;i&lt;=L.len;i++) cin&gt;&gt;L.data[i].key; }int binSearch(SeqList T, KeyType k);int main () { SeqList L; KeyType k; creat(L); cin&gt;&gt;k; int pos=binSearch(L,k); if(pos==0) cout&lt;&lt;\"NOT FOUND\"&lt;&lt;endl; else cout&lt;&lt;pos&lt;&lt;endl; return 0;}int binSearch(SeqList T, KeyType k){ int mid; int i = 1,j = T.len;//i指向一行数据的第一个，j指向一行数据的最后一个 while(i&lt;j){ mid = (i+j)/2;//折半查找 if(T.data[mid].key == k){ return mid; } if (T.data[mid].key&gt;k){//大于了 上限j就变化 j = mid -1; } if(T.data[mid].key &lt; k){//小于了下限就变化 i = mid +1; } } return 0; }","link":"/2018/04/13/jichu6-13/"},{"title":"6-12 判断奇偶性（10 分）","text":"6-12 判断奇偶性（10 分）本题要求实现判断给定整数奇偶性的函数。 函数接口定义：1int even( int n ); 其中n是用户传入的整型参数。当n为偶数时，函数返回1；n为奇数时返回0。注意：0是偶数。 裁判测试程序样例：123456789101112131415161718#include &lt;stdio.h&gt;int even( int n );int main(){ int n; scanf(\"%d\", &amp;n); if (even(n)) printf(\"%d is even.\\n\", n); else printf(\"%d is odd.\\n\", n); return 0;}/* 你的代码将被嵌在这里 */ 输入样例1：1-6 输出样例1：1-6 is even. 输入样例2：15 输出样例2：15 is odd. 123456789101112131415161718192021222324#include &lt;stdio.h&gt;int even( int n );int main(){ int n; scanf(\"%d\", &amp;n); if (even(n)) printf(\"%d is even.\\n\", n); else printf(\"%d is odd.\\n\", n); return 0;}int even( int n ) { if(n%2==0) { return 1; } return 0; }","link":"/2018/04/13/jichu6-12/"},{"title":"6-2 多项式求值（15 分）","text":"6-2 多项式求值（15 分）本题要求实现一个函数，计算阶数为n，系数为a[0] … a[n]的多项式$f(x)=\\sum_{i=0}^{n}\\left(a[i] \\times x^{i}\\right)$在x点的值。 函数接口定义：1double f( int n, double a[], double x ); 其中n是多项式的阶数，a[]中存储系数，x是给定点。函数须返回多项式f(x)的值。 裁判测试程序样例：12345678910111213141516171819#include &lt;stdio.h&gt;#define MAXN 10double f( int n, double a[], double x );int main(){ int n, i; double a[MAXN], x; scanf(\"%d %lf\", &amp;n, &amp;x); for ( i=0; i&lt;=n; i++ ) scanf(“%lf”, &amp;a[i]); printf(\"%.1f\\n\", f(n, a, x)); return 0;}/* 你的代码将被嵌在这里 */ 输入样例：122 1.11 2.5 -38.7 输出样例：1-43.1 123456789101112131415161718192021222324252627282930#include &lt;stdio.h&gt;#define MAXN 10double f( int n, double a[], double x );int main(){ int n, i; double a[MAXN], x; scanf(\"%d %lf\", &amp;n, &amp;x); for ( i=0; i&lt;=n; i++ ) scanf(\"%lf\", &amp;a[i]); printf(\"%.1f\\n\", f(n, a, x)); return 0;}double f( int n, double a[], double x ) { int i; double b=1.0; double sum=a[0]; for(i=1;i&lt;=n;i++) { b=b*x; sum=sum+b*a[i]; } return sum; }","link":"/2018/04/13/jichu6-2/"},{"title":"6-3 简单求和（10 分）","text":"6-3 简单求和（10 分）本题要求实现一个函数，求给定的N个整数的和。 函数接口定义：1int Sum ( int List[], int N ); 其中给定整数存放在数组List[]中，正整数N是数组元素个数。该函数须返回N个List[]元素的和。 裁判测试程序样例：12345678910111213141516171819#include &lt;stdio.h&gt;#define MAXN 10int Sum ( int List[], int N );int main (){ int List[MAXN], N, i; scanf(\"%d\", &amp;N); for ( i=0; i&lt;N; i++ ) scanf(\"%d\", &amp;List[i]); printf(\"%d\\n\", Sum(List, N)); return 0;}/* 你的代码将被嵌在这里 */ 输入样例：12312 34 -5 输出样例：141 1234567891011121314151617181920212223242526#include &lt;stdio.h&gt;#define MAXN 10int Sum ( int List[], int N );int main (){ int List[MAXN], N, i; scanf(\"%d\", &amp;N); for ( i=0; i&lt;N; i++ ) scanf(\"%d\", &amp;List[i]); printf(\"%d\\n\", Sum(List, N)); return 0;}int Sum ( int List[], int N ){ int sum=0; for(int i=0;i&lt;N;i++) { sum+=List[i]; } return sum;}","link":"/2018/04/13/jichu6-3/"},{"title":"6-5 求自定类型元素的最大值（10 分）","text":"6-5 求自定类型元素的最大值（10 分）本题要求实现一个函数，求N个集合元素S[]中的最大值，其中集合元素的类型为自定义的ElementType。 函数接口定义：1ElementType Max( ElementType S[], int N ); 其中给定集合元素存放在数组S[]中，正整数N是数组元素个数。该函数须返回N个S[]元素中的最大值，其值也必须是ElementType类型。 裁判测试程序样例：123456789101112131415161718192021#include &lt;stdio.h&gt;#define MAXN 10typedef float ElementType;ElementType Max( ElementType S[], int N );int main (){ ElementType S[MAXN]; int N, i; scanf(\"%d\", &amp;N); for ( i=0; i&lt;N; i++ ) scanf(\"%f\", &amp;S[i]); printf(\"%.2f\\n\", Max(S, N)); return 0;}/* 你的代码将被嵌在这里 */ 输入样例：12312.3 34 -5 输出样例：134.00 123456789101112131415161718192021222324252627282930#include &lt;stdio.h&gt;#define MAXN 10typedef float ElementType;ElementType Max( ElementType S[], int N );int main (){ ElementType S[MAXN]; int N, i; scanf(\"%d\", &amp;N); for ( i=0; i&lt;N; i++ ) scanf(\"%f\", &amp;S[i]); printf(\"%.2f\\n\", Max(S, N)); return 0;}ElementType Max( ElementType S[], int N ) { int i; ElementType MAX=S[0]; for(i=1;i&lt;N;i++) { if(MAX&lt;S[i]) MAX=S[i]; } return MAX; }","link":"/2018/04/13/jichu6-5/"},{"title":"6-6 求单链表结点的阶乘和（15 分）","text":"6-6 求单链表结点的阶乘和（15 分）本题要求实现一个函数，求单链表L结点的阶乘和。这里默认所有结点的值非负，且题目保证结果在int范围内。 函数接口定义：1int FactorialSum( List L ); 其中单链表List的定义如下： 123456typedef struct Node *PtrToNode;struct Node { int Data; /* 存储结点数据 */ PtrToNode Next; /* 指向下一个结点的指针 */};typedef PtrToNode List; /* 定义单链表类型 */ 裁判测试程序样例：123456789101112131415161718192021222324252627282930#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct Node *PtrToNode;struct Node { int Data; /* 存储结点数据 */ PtrToNode Next; /* 指向下一个结点的指针 */};typedef PtrToNode List; /* 定义单链表类型 */int FactorialSum( List L );int main(){ int N, i; List L, p; scanf(\"%d\", &amp;N); L = NULL; for ( i=0; i&lt;N; i++ ) { p = (List)malloc(sizeof(struct Node)); scanf(\"%d\", &amp;p-&gt;Data); p-&gt;Next = L; L = p; } printf(\"%d\\n\", FactorialSum(L)); return 0;}/* 你的代码将被嵌在这里 */ 输入样例：1235 3 6 输出样例：1846 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct Node *PtrToNode;struct Node { int Data; /* 存储结点数据 */ PtrToNode Next; /* 指向下一个结点的指针 */};typedef PtrToNode List; /* 定义单链表类型 */int FactorialSum( List L );int main(){ int N, i; List L, p; scanf(\"%d\", &amp;N); L = NULL; for ( i=0; i&lt;N; i++ ) { p = (List)malloc(sizeof(struct Node)); scanf(\"%d\", &amp;p-&gt;Data); p-&gt;Next = L; L = p; } printf(\"%d\\n\", FactorialSum(L)); return 0;}int FactorialSum(List L) { int i, Num; int Sum = 0; while (L != NULL) //遍历整个链表 { Num = 1; for (i = 1; i &lt;= L-&gt;Data; i++)//从每个节点读取数据计 { Num = Num*i; //算每个节点数据的阶乘 } Sum = Sum + Num; //对节点数据求和 L = L-&gt;Next; } return Sum; //返回单链表结点的阶乘和}","link":"/2018/04/13/jichu6-6/"},{"title":"6-7 统计某类完全平方数（20 分）","text":"6-7 统计某类完全平方数（20 分）本题要求实现一个函数，判断任一给定整数N是否满足条件：它是完全平方数，又至少有两位数字相同，如144、676等。 函数接口定义：1int IsTheNumber ( const int N ); 其中N是用户传入的参数。如果N满足条件，则该函数必须返回1，否则返回0。 裁判测试程序样例：123456789101112131415161718192021#include &lt;stdio.h&gt;#include &lt;math.h&gt;int IsTheNumber ( const int N );int main(){ int n1, n2, i, cnt; scanf(\"%d %d\", &amp;n1, &amp;n2); cnt = 0; for ( i=n1; i&lt;=n2; i++ ) { if ( IsTheNumber(i) ) cnt++; } printf(\"cnt = %d\\n\", cnt); return 0;}/* 你的代码将被嵌在这里 */ 输入样例：1105 500 输出样例：1cnt = 6 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;stdio.h&gt;#include &lt;math.h&gt;int IsTheNumber ( const int N );int main(){ int n1, n2, i, cnt; scanf(\"%d %d\", &amp;n1, &amp;n2); cnt = 0; for ( i=n1; i&lt;=n2; i++ ) { if ( IsTheNumber(i) ) cnt++; } printf(\"cnt = %d\\n\", cnt); return 0;}int IsTheNumber ( const int N ){ int n,m; n=(int)sqrt(N); m=n*n; if(m==N) { int num[10]={0}; int i; while(m&gt;0) { for(i=0;i&lt;=9;i++) { if(m%10==i) { num[i]+=1; if(num[i]==2) { return 1; } } } m=m/10; } return 0; } return 0;}","link":"/2018/04/13/jichu6-7/"},{"title":"6-4 求自定类型元素的平均（10 分）","text":"6-4 求自定类型元素的平均（10 分）本题要求实现一个函数，求N个集合元素S[]的平均值，其中集合元素的类型为自定义的ElementType。 函数接口定义：1ElementType Average( ElementType S[], int N ); 其中给定集合元素存放在数组S[]中，正整数N是数组元素个数。该函数须返回N个S[]元素的平均值，其值也必须是ElementType类型。 裁判测试程序样例：123456789101112131415161718192021#include &lt;stdio.h&gt;#define MAXN 10typedef float ElementType;ElementType Average( ElementType S[], int N );int main (){ ElementType S[MAXN]; int N, i; scanf(\"%d\", &amp;N); for ( i=0; i&lt;N; i++ ) scanf(\"%f\", &amp;S[i]); printf(\"%.2f\\n\", Average(S, N)); return 0;}/* 你的代码将被嵌在这里 */ 输入样例：12312.3 34 -5 输出样例：113.77 1234567891011121314151617181920212223242526272829#include &lt;stdio.h&gt;#define MAXN 10typedef float ElementType;ElementType Average( ElementType S[], int N );int main (){ ElementType S[MAXN]; int N, i; scanf(\"%d\", &amp;N); for ( i=0; i&lt;N; i++ ) scanf(\"%f\", &amp;S[i]); printf(\"%.2f\\n\", Average(S, N)); return 0;}ElementType Average( ElementType S[], int N){ ElementType sum=0; for(int i=0;i&lt;N;i++) { sum+=S[i]; } return sum/N;};","link":"/2018/04/13/jichu6-4/"},{"title":"6-8 简单阶乘计算（10 分）","text":"6-8 简单阶乘计算（10 分）本题要求实现一个计算非负整数阶乘的简单函数。 函数接口定义：1int Factorial( const int N ); 其中N是用户传入的参数，其值不超过12。如果N是非负整数，则该函数必须返回N的阶乘，否则返回0。 裁判测试程序样例：1234567891011121314151617#include &lt;stdio.h&gt;int Factorial( const int N );int main(){ int N, NF; scanf(\"%d\", &amp;N); NF = Factorial(N); if (NF) printf(\"%d! = %d\\n\", N, NF); else printf(\"Invalid input\\n\"); return 0;}/* 你的代码将被嵌在这里 */ 输入样例：15 输出样例：15! = 120 12345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;int Factorial( const int N );int main(){ int N, NF; scanf(\"%d\", &amp;N); NF = Factorial(N); if (NF) printf(\"%d! = %d\\n\", N, NF); else printf(\"Invalid input\\n\"); return 0;}int Factorial( const int N ){ if(N&lt;0) return 0; int mul=1; int i; for(i=1;i&lt;=N;i++){ mul=mul*i; } return mul;}","link":"/2018/04/13/jichu6-8/"},{"title":"6-9 统计个位数字（15 分）","text":"6-9 统计个位数字（15 分）本题要求实现一个函数，可统计任一整数中某个位数出现的次数。例如-21252中，2出现了3次，则该函数应该返回3。 函数接口定义：1int Count_Digit ( const int N, const int D ); 其中N和D都是用户传入的参数。N的值不超过int的范围；D是[0, 9]区间内的个位数。函数须返回N中D出现的次数。 裁判测试程序样例：1234567891011121314#include &lt;stdio.h&gt;int Count_Digit ( const int N, const int D );int main(){ int N, D; scanf(\"%d %d\", &amp;N, &amp;D); printf(\"%d\\n\", Count_Digit(N, D)); return 0;}/* 你的代码将被嵌在这里 */ 输入样例：1-21252 2 输出样例：13 1234567891011121314151617181920212223242526#include &lt;stdio.h&gt;int Count_Digit ( const int N, const int D );int main(){ int N, D; scanf(\"%d %d\", &amp;N, &amp;D); printf(\"%d\\n\", Count_Digit(N, D)); return 0;}int Count_Digit ( const int N, const int D ){ int a[10] = {0},n = N; if(n&lt;0) n = -n; else if(n==0) return 1; while(n) { a[n%10]++; n/=10; } return a[D];}","link":"/2018/04/13/jichu6-9/"},{"title":"7-11 分段计算居民水费（10 分）","text":"7-11 分段计算居民水费（10 分）为鼓励居民节约用水，自来水公司采取按用水量阶梯式计价的办法，居民应交水费$y$（元）与月用水量$x$（吨）相关：当$x$不超过15吨时，$y=4x\\div3$；超过后，$y=2.5x−17.5$。请编写程序实现水费的计算。 输入格式：输入在一行中给出非负实数x。 输出格式：在一行输出应交的水费，精确到小数点后2位。 输入样例1：112 输出样例1：116.00 输入样例2：116 输出样例2：122.50 12345678910111213#include &lt;stdio.h&gt;int main(){ double x,y; scanf(\"%lf\",&amp;x); if(x&lt;=15){ y=4*x/3; } else y= 2.5*x-17.5 ; printf(\"%.2lf\\n\",y); return 0;}","link":"/2018/04/15/jichu7-11/"},{"title":"7-10 计算工资（15 分）","text":"7-10 计算工资（15 分）某公司员工的工资计算方法如下：一周内工作时间不超过40小时，按正常工作时间计酬；超出40小时的工作时间部分，按正常工作时间报酬的1.5倍计酬。员工按进公司时间分为新职工和老职工，进公司不少于5年的员工为老职工，5年以下的为新职工。新职工的正常工资为30元/小时，老职工的正常工资为50元/小时。请按该计酬方式计算员工的工资。 输入格式：输入在一行中给出2个正整数，分别为某员工入职年数和周工作时间，其间以空格分隔。 输出格式：在一行输出该员工的周薪，精确到小数点后2位。 输入样例1：15 40 输出样例1：12000.00 输入样例2：13 50 输出样例2：11650.00 12345678910111213141516#include&lt;stdio.h&gt;int main (){ int y,h; float s; scanf(\"%d %d\",&amp;y,&amp;h); if(y&lt;5){ if(h&gt;40)s=((h-40)*1.5+40)*30; else s=h*30; printf(\"%.2f\",s); }else{ if(h&gt;40)s=((h-40)*1.5+40)*50; else s=h*50; printf(\"%.2f\",s); }}","link":"/2018/04/15/jichu7-10/"},{"title":"7-1 厘米换算英尺英寸（15 分）","text":"7-1 厘米换算英尺英寸（15 分）如果已知英制长度的英尺foot和英寸inch的值，那么对应的米是$(foot+inch\\div12)\\times0.3048$。现在，如果用户输入的是厘米数，那么对应英制长度的英尺和英寸是多少呢？别忘了1英尺等于12英寸。 输入格式：输入在一行中给出1个正整数，单位是厘米。 输出格式：在一行中输出这个厘米数对应英制长度的英尺和英寸的整数值，中间用空格分开。 输入样例：1170 输出样例：15 6 123456789101112#include &lt;stdio.h&gt; int main() { int cm; int foot,inch; scanf(\"%d\",&amp;cm); foot= cm / 30.48; inch= 12 * (cm / 30.48 - foot); printf(\"%d %d\\n\", foot,inch); return 0; }","link":"/2018/04/13/jichu7-1/"},{"title":"7-13 日K蜡烛图（15 分）","text":"7-13 日K蜡烛图（15 分）股票价格涨跌趋势，常用蜡烛图技术中的K线图来表示，分为按日的日K线、按周的周K线、按月的月K线等。以日K线为例，每天股票价格从开盘到收盘走完一天，对应一根蜡烛小图，要表示四个价格：开盘价格Open（早上刚刚开始开盘买卖成交的第1笔价格）、收盘价格Close（下午收盘时最后一笔成交的价格）、中间的最高价High和最低价Low。 如果CloseOpen，表示为“R-Hollow”（即“空心红蜡烛”）；如果Open等于Close，则为“R-Cross”（即“十字红蜡烛”）。如果Low比Open和Close低，称为“Lower Shadow”（即“有下影线”），如果High比Open和Close高，称为“Upper Shadow”（即“有上影线”）。请编程序，根据给定的四个价格组合，判断当日的蜡烛是一根什么样的蜡烛。 输入格式：输入在一行中给出4个正实数，分别对应Open、High、Low、Close，其间以空格分隔。 输出格式：在一行中输出日K蜡烛的类型。如果有上、下影线，则在类型后加上with 影线类型。如果两种影线都有，则输出with Lower Shadow and Upper Shadow。 输入样例1：15.110 5.250 5.100 5.105 输出样例1：1BW-Solid with Lower Shadow and Upper Shadow 输入样例2：15.110 5.110 5.110 5.110 输出样例2：1R-Cross 输入样例3：15.110 5.125 5.112 5.126 输出样例3：1R-Hollow 12345678910111213141516171819202122232425262728#include&lt;stdio.h&gt;int main(){ double open,close,high,low; scanf(\"%lf %lf %lf %lf\",&amp;open,&amp;high,&amp;low,&amp;close); { if(close&lt;open) printf(\"BW-Solid\"); else if(close&gt;open) printf(\"R-Hollow\"); else printf(\"R-Cross\"); } {//上下影线都存在的情况，记得加上前面的空格 if((low&lt;open&amp;&amp;low&lt;close)&amp;&amp;(high&gt;open&amp;&amp;high&gt;close)) printf(\" with Lower Shadow and Upper Shadow\"); //下影线 else if(low&lt;open&amp;&amp;low&lt;close) printf(\" with Lower Shadow\"); //上影线 else if(high&gt;open&amp;&amp;high&gt;close) printf(\" with Upper Shadow\"); } return 0;}","link":"/2018/04/15/jichu7-13/"},{"title":"7-12 两个数的简单计算器（10 分）","text":"7-12 两个数的简单计算器（10 分）本题要求编写一个简单计算器程序，可根据输入的运算符，对2个整数进行加、减、乘、除或求余运算。题目保证输入和输出均不超过整型范围。 输入格式：输入在一行中依次输入操作数1、运算符、操作数2，其间以1个空格分隔。操作数的数据类型为整型，且保证除法和求余的分母非零。 输出格式：当运算符为+、-、*、/、%时，在一行输出相应的运算结果。若输入是非法符号（即除了加、减、乘、除和求余五种运算符以外的其他符号）则输出ERROR。 输入样例1：1-7 / 2 输出样例1：1-3 输入样例2：13 &amp; 6 输出样例2：1ERROR 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;stdio.h&gt;int main(void){ int a, b,d; char c; scanf(\"%d %c %d\", &amp;a, &amp;c, &amp;b); switch (c) { case '+': { d = a + b; printf(\"%d\", d); break; } case '-': { d = a - b; printf(\"%d\", d); break; } case'*': { d = a*b; printf(\"%d\", d); break; } case'/': { d = a / b; printf(\"%d\", d); break; } case'%': { d = a%b; printf(\"%d\", d); break; } default: printf(\"ERROR\\n\"); break; } return 0;}","link":"/2018/04/15/jichu7-12/"},{"title":"7-14 求整数段和（15 分）","text":"7-14 求整数段和（15 分）给定两个整数A和B，输出从A到B的所有整数以及这些数的和。 输入格式：输入在一行中给出2个整数A和B，其中$−100\\leq A\\leq B\\leq 100$，其间以空格分隔。 输出格式：首先顺序输出从A到B的所有整数，每5个数字占一行，每个数字占5个字符宽度，向右对齐。最后在一行中按Sum = X的格式输出全部数字的和X。 输入样例：1-3 8 输出样例：1234 -3 -2 -1 0 1 2 3 4 5 6 7 8Sum = 30 123456789101112131415161718192021#include&lt;stdio.h&gt;int main(){ int a,b,i,cot=0,sum=0;//添加计数器 scanf(\"%d %d\",&amp;a,&amp;b);//输入区间 //以a为起点，如果a小于b，每次a累加1 for(i=a;i&lt;=b;i++){ printf(\"%5d\",i);//题目要求占5个字符宽 cot++;//每输出一次，计数器累加1 if(cot%5==0&amp;&amp;i!=b)//如果当前计数器的值能被5整除那么换行 printf(\"\\n\"); } printf(\"\\n\");//执行完循环后，换行输入总和 for(i=a;i&lt;=b;i++) sum+=i; printf(\"Sum = %d\",sum); return 0;}","link":"/2018/04/15/jichu7-14/"},{"title":"7-16 求符合给定条件的整数集（15 分）","text":"7-16 求符合给定条件的整数集（15 分）给定不超过6的正整数A，考虑从A开始的连续4个数字。请输出所有由它们组成的无重复数字的3位数。 输入格式：输入在一行中给出A。 输出格式：输出满足条件的的3位数，要求从小到大，每行6个整数。整数间以空格分隔，但行末不能有多余空格。 输入样例：12 输出样例：1234234 235 243 245 253 254324 325 342 345 352 354423 425 432 435 452 453523 524 532 534 542 543 123456789101112131415161718192021222324#include &lt;stdio.h&gt;int main(){ int start; scanf(\"%d\", &amp;start); int end; int n = 0; end = start + 4; for(int i = start; i&lt;end; i++){ for(int j = start; j&lt;end; j++){ if(i == j) continue; for(int k = start; k&lt;end; k++){ if(k == j) continue; if(k == i) continue; n++; if(n%6){ printf(\"%d \", i*100+j*10+k); }else{ printf(\"%d\\n\", i*100+j*10+k); } } } }}","link":"/2018/04/15/jichu7-16/"},{"title":"7-15 计算圆周率（15 分）","text":"7-15 计算圆周率（15 分）根据下面关系式，求圆周率的值，直到最后一项的值小于给定阈值。 $$\\frac{\\pi}{2}=1+\\frac{1}{3}+\\frac{2 !}{3 \\times 5}+\\frac{3 !}{3 \\times 5 \\times 7}+\\cdots+\\frac{n !}{3 \\times 5 \\times 7 \\times \\cdots \\times(2 n+1)}+\\cdots$$ 输入格式：输入在一行中给出小于1的阈值。 输出格式：在一行中输出满足阈值条件的近似圆周率，输出到小数点后6位。 输入样例：10.01 输出样例：13.132157 12345678910111213141516171819#include&lt;stdio.h&gt;int main(){ int i = 1; double up=1.0f; double down=1.0f; double sum=1.0f;//右边式子第一项为1，在此直接处理 double n; scanf(\"%lf\",&amp;n);//输入阈值 do{ up*=i;//分子 down*=(2.0*i+1.0);//分母（奇数相乘，从1*3开始） i++; sum+=(up/down);//每一项的和累加 }while(up/down&gt;=n);//如果当前项小于阈值，退出循环 printf(\"%.6lf\",2.0*sum);//最后不要忘记乘以2 return 0;}","link":"/2018/04/15/jichu7-15/"},{"title":"7-18 二分法求多项式单根（20 分）","text":"7-18 二分法求多项式单根（20 分）二分法求函数根的原理为：如果连续函数f(x)在区间[a,b]的两个端点取值异号，即f(a)f(b)&lt;0，则它在这个区间内至少存在1个根r，即f(r)=0。 二分法的步骤为： 检查区间长度，如果小于给定阈值，则停止，输出区间中点(a+b)/2；否则 如果f(a)f(b)&lt;0，则计算中点的值f((a+b)/2)； 如果f((a+b)/2)正好为0，则(a+b)/2就是要求的根；否则 如果f((a+b)/2)与f(a)同号，则说明根在区间[(a+b)/2,b]，令a=(a+b)/2，重复循环； 如果f((a+b)/2)与f(b)同号，则说明根在区间[a,(a+b)/2]，令b=(a+b)/2，重复循环。 本题目要求编写程序，计算给定3阶多项式f(x)=a3x3+a2x2+a1x+a0在给定区间[a,b]内的根。 输入格式：输入在第1行中顺序给出多项式的4个系数a3、a2、a1、a0，在第2行中顺序给出区间端点a和b。题目保证多项式在给定区间内存在唯一单根。 输出格式：在一行中输出该多项式在该区间内的根，精确到小数点后2位。 输入样例：123 -1 -3 1-0.5 0.5 输出样例：10.33 1234567891011121314151617181920212223242526272829303132333435#include &lt;stdio.h&gt;#include &lt;math.h&gt;double a3, a2, a1, a0;double f(double a){ return a3*pow(a,3)+a2*pow(a,2)+a1*a+a0;}int main(){ int ok=1; double a,b; scanf(\"%lf%lf%lf%lf\",&amp;a3,&amp;a2,&amp;a1,&amp;a0); scanf(\"%lf%lf\",&amp;a,&amp;b); while((b-a)&gt;0.001) { if(f((a+b)/2)==0) { printf(\"%.2f\\n\",(a+b)/2); ok=0; break; } else if(f((a+b)/2)*f(a)&gt;0) { a=(a+b)/2; } else// if(f((a+b)/2)*f(b)&gt;0) { b=(a+b)/2; } } if(ok) printf(\"%.2f\\n\",(a+b)/2); return 0;}","link":"/2018/04/15/jichu7-18/"},{"title":"7-17 爬动的蠕虫（15 分）","text":"7-17 爬动的蠕虫（15 分）一条蠕虫长1寸，在一口深为N寸的井的底部。已知蠕虫每1分钟可以向上爬U寸，但必须休息1分钟才能接着往上爬。在休息的过程中，蠕虫又下滑了D寸。就这样，上爬和下滑重复进行。请问，蠕虫需要多长时间才能爬出井？ 这里要求不足1分钟按1分钟计，并且假定只要在某次上爬过程中蠕虫的头部到达了井的顶部，那么蠕虫就完成任务了。初始时，蠕虫是趴在井底的（即高度为0）。 输入格式：输入在一行中顺序给出3个正整数N、U、D，其中D&lt;U，N不超过100。 输出格式：在一行中输出蠕虫爬出井的时间，以分钟为单位。 输入样例：112 3 1 输出样例：111 12345678910111213141516171819202122232425262728293031/*假设爬行一分钟，休息一分钟*/ #include&lt;stdio.h&gt; int main() { int n, u, d;//井口高度，上爬量和下滑量 int time = 0, distance = 0;//虫虫消耗的时间(分钟)，距离井底的距离(寸) scanf(\"%i %i %i\", &amp;n, &amp;u, &amp;d); /** * 第1分钟，爬； * 第2分钟，滑； * 第3分钟，爬； * 第4分钟，滑； * ... * 时间为偶数，虫虫下滑； * 时间为奇数，虫虫上爬。 */ do { time++; if (time % 2 != 0) { distance += u; } else { distance -= d; } } while (distance &lt; n); printf(\"%i\\n\", time); return 0; }","link":"/2018/04/15/jichu7-17/"},{"title":"7-19 支票面额（15 分）","text":"7-19 支票面额（15 分）一个采购员去银行兑换一张y元f分的支票，结果出纳员错给了f元y分。采购员用去了n分之后才发觉有错，于是清点了余额尚有2y元2f分，问该支票面额是多少？ 输入格式：输入在一行中给出小于100的正整数n。 输出格式：在一行中按格式y.f输出该支票的原始面额。如果无解，则输出No Solution。 输入样例1：123 输出样例1：125.51 输入样例2：122 输出样例2：1No Solution 123456789101112131415161718192021#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(){ int n,i,j,count=0; scanf(\"%d\",&amp;n); for(i=0;i&lt;100;i++) for(j=0;j&lt;100;j++) if(98*j-199*i-n==0){ count=1; printf(\"%d.%d\", i, j); } if(count==0)printf(\"No Solution\"); return 0;}","link":"/2018/04/15/jichu7-19/"},{"title":"7-20 打印九九口诀表（15 分）","text":"7-20 打印九九口诀表（15 分）下面是一个完整的下三角九九口诀表： 1234567891*1=1 1*2=2 2*2=4 1*3=3 2*3=6 3*3=9 1*4=4 2*4=8 3*4=12 4*4=16 1*5=5 2*5=10 3*5=15 4*5=20 5*5=25 1*6=6 2*6=12 3*6=18 4*6=24 5*6=30 6*6=36 1*7=7 2*7=14 3*7=21 4*7=28 5*7=35 6*7=42 7*7=49 1*8=8 2*8=16 3*8=24 4*8=32 5*8=40 6*8=48 7*8=56 8*8=64 1*9=9 2*9=18 3*9=27 4*9=36 5*9=45 6*9=54 7*9=63 8*9=72 9*9=81 本题要求对任意给定的一位正整数N，输出从1*1到N*N的部分口诀表。 输入格式：输入在一行中给出一个正整数N（1≤N≤9）。 输出格式：输出下三角N*N部分口诀表，其中等号右边数字占4位、左对齐。 输入样例：14 输出样例：12341*1=1 1*2=2 2*2=4 1*3=3 2*3=6 3*3=9 1*4=4 2*4=8 3*4=12 4*4=16 123456789101112#include &lt;stdio.h&gt; int main(void) { int i, j, n; scanf(\"%d\", &amp;n); for(i = 1; i &lt;= n; ++i) { for(j = 1; j &lt;= i; ++j) { printf(\"%d*%d=%-4d\", j, i, i * j); } printf(\"\\n\"); } return 0; }","link":"/2018/04/15/jichu7-20/"},{"title":"7-21 求特殊方程的正整数解（15 分）","text":"7-21 求特殊方程的正整数解（15 分）本题要求对任意给定的正整数$N$，求方程$X^2+Y^2=N$的全部正整数解。 输入格式：输入在一行中给出正整数$N（\\leq 10000）$。 输出格式：输出方程$X^2+Y^2=N$的全部正整数解，其中$X\\leq Y$。每组解占1行，两数字间以1空格分隔，按$X$的递增顺序输出。如果没有解，则输出No Solution。 输入样例1：1884 输出样例1：1210 2820 22 输入样例2：111 输出样例2：1No Solution 12345678910111213141516171819#include &lt;stdio.h&gt; int main(void) { int n, x, y; int flag = 0; scanf(\"%d\", &amp;n); int half = n / 2; for(x = 1; x &lt;= half; ++x) { for(y = x; y &lt;= half; ++y) { if(x * x + y * y == n) { flag = 1; printf(\"%d %d\\n\", x, y); } } } if(!flag) printf(\"No Solution\\n\"); return 0;}","link":"/2018/04/15/jichu7-21/"},{"title":"7-2 然后是几点（15 分）","text":"7-2 然后是几点（15 分）有时候人们用四位数字表示一个时间，比如1106表示11点零6分。现在，你的程序要根据起始时间和流逝的时间计算出终止时间。 读入两个数字，第一个数字以这样的四位数字表示当前时间，第二个数字表示分钟数，计算当前时间经过那么多分钟后是几点，结果也表示为四位数字。当小时为个位数时，没有前导的零，即5点30分表示为530。注意，第二个数字表示的分钟数可能超过60，也可能是负数。 输入格式：输入在一行中给出2个整数，分别是四位数字表示的起始时间、以及流逝的分钟数，其间以空格分隔。注意：在起始时间中，当小时为个位数时，没有前导的零，即5点30分表示为530；流逝的分钟数可能超过60，也可能是负数。 输出格式：输出四位数字表示的终止时间。题目保证起始时间和终止时间在同一天内。 输入样例：11120 110 输出样例：11310 123456789101112131415161718192021#include&lt;stdio.h&gt;int main(){ int t1,t2,t3; int hour1,minute1,hour2,minute2; scanf(\"%d %d\",&amp;t1,&amp;t2); hour2=t2/60; minute2=t2%60; hour1=t1/100; minute1=t1%100; int hour3=hour1+hour2; int minute3=minute2+minute1; if(minute3&gt;60) { minute3=minute3%60; hour3++; } t3=hour3*100+minute3; printf(\"%d\",t3); return 0;}","link":"/2018/04/13/jichu7-2/"},{"title":"7-23 币值转换（20 分）","text":"7-23 币值转换（20 分）输入一个整数（位数不超过9位）代表一个人民币值（单位为元），请转换成财务要求的大写中文格式。如23108元，转换后变成“贰万叁仟壹百零捌”元。为了简化输出，用小写英文字母a-j顺序代表大写数字0-9，用S、B、Q、W、Y分别代表拾、百、仟、万、亿。于是23108元应被转换输出为“cWdQbBai”元。 输入格式：输入在一行中给出一个不超过9位的非负整数。 输出格式：在一行中输出转换后的结果。注意“零”的用法必须符合中文习惯。 输入样例1：1813227345 输出样例1：1iYbQdBcScWhQdBeSf 输入样例2：16900 输出样例2：1gQjB 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;stdio.h&gt;int main(){ char a[10]={'a','b','c','d','e','f','g','h','i','j'}; char b[10]={'0','S','B','Q','W','S','B','Q','Y'}; int c[10]={0}; int flag[10]={1,1,1,1,1,1,1,1,1,1,}; long n; int len=0; scanf(\"%ld\",&amp;n); long t=n; int j; int hou=0; while(t&gt;0){ c[len]=t%10; t/=10; len++; } if(n==0) printf(\"a\"); else{ for(j=0;j&lt;len;j++){ if(c[j]==0){ flag[j]=0; } else break; } for(j=len-1;j&gt;=0;j--){ if(j==len-1){ if(len==1){ printf(\"%c\",a[c[j]]); break; } else if(flag[j]==1&amp;&amp;flag[j-1]==0){ printf(\"%c%c\",a[c[j]],b[j]); if(j==8||j&lt;=4) break; else if(j&gt;4&amp;&amp;j&lt;8){ printf(\"W\"); break; } } else printf(\"%c%c\",a[c[j]],b[j]); } else if(j&gt;4){ if(c[j]!=0&amp;&amp;flag[j]==1&amp;&amp;flag[j-1]==0){ printf(\"%c%cW\",a[c[j]],b[j]); break; } else if(c[j]!=0) printf(\"%c%c\",a[c[j]],b[j]); else if(c[j]==0&amp;&amp;c[j-1]!=0) printf(\"a\"); } else if(j==4){ if(c[j]!=0&amp;&amp;flag[j]==1&amp;&amp;flag[j-1]==0){ printf(\"%c%c\",a[c[j]],b[j]); break; } else if(c[j]!=0) printf(\"%c%c\",a[c[j]],b[j]); else if(c[j]==0&amp;&amp;c[j-1]!=0) printf(\"Wa\"); } else if(j&lt;4&amp;&amp;j&gt;0){ if(c[j]!=0&amp;&amp;flag[j]==1&amp;&amp;flag[j-1]==0){ printf(\"%c%c\",a[c[j]],b[j]); break; } else if(c[j]!=0) printf(\"%c%c\",a[c[j]],b[j]); else if(c[j]==0&amp;&amp;c[j-1]!=0) printf(\"a\"); } else if(j==0){ printf(\"%c\",a[c[j]]); } } } return 0;}","link":"/2018/04/15/jichu7-23/"},{"title":"7-25 念数字（15 分）","text":"7-25 念数字（15 分）输入一个整数，输出每个数字对应的拼音。当整数为负数时，先输出fu字。十个数字对应的拼音如下： 123456789100: ling1: yi2: er3: san4: si5: wu6: liu7: qi8: ba9: jiu 输入格式：输入在一行中给出一个整数，如：1234。 提示：整数包括负数、零和正数。 输出格式：在一行中输出这个整数对应的拼音，每个数字的拼音之间用空格分开，行末没有最后的空格。如 yi er san si。 输入样例：1-600 输出样例：1fu liu ling ling 123456789101112131415161718192021222324252627282930#include &lt;stdio.h&gt;int main(){ int n; scanf(\"%d\", &amp;n); if (n &lt; 0) { printf(\"fu \"); n = -n; } int t = n,mask = 1; while(t &gt; 9) { t /= 10; mask *= 10; } char *s[] = { \"ling\", \"yi\", \"er\", \"san\", \"si\", \"wu\", \"liu\", \"qi\", \"ba\", \"jiu\" }; int d; while (mask &gt; 0) { d = n / mask; printf(\"%s\", s[d]); if (mask &gt; 9) printf(\" \"); n %= mask; mask /= 10; } return 0;}","link":"/2018/04/15/jichu7-25/"},{"title":"7-22 龟兔赛跑（20 分）","text":"7-22 龟兔赛跑（20 分）乌龟与兔子进行赛跑，跑场是一个矩型跑道，跑道边可以随地进行休息。乌龟每分钟可以前进3米，兔子每分钟前进9米；兔子嫌乌龟跑得慢，觉得肯定能跑赢乌龟，于是，每跑10分钟回头看一下乌龟，若发现自己超过乌龟，就在路边休息，每次休息30分钟，否则继续跑10分钟；而乌龟非常努力，一直跑，不休息。假定乌龟与兔子在同一起点同一时刻开始起跑，请问T分钟后乌龟和兔子谁跑得快？ 输入格式：输入在一行中给出比赛时间T（分钟）。 输出格式：在一行中输出比赛的结果：乌龟赢输出@_@，兔子赢输出^_^，平局则输出-_-；后跟1空格，再输出胜利者跑完的距离。 输入样例：1242 输出样例：1@_@ 726 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;stdio.h&gt;int main(){ int T, i; int rabbitT=0; //兔子跑的时间 scanf(\"%d\",&amp;T); if(T&lt;10) { printf(\"^_^ %d\\n\",T*9); return 0; } rabbitT=10; for(i=10;i&lt;=T;i++) { if(i%10==0) //每10分钟回头，比较 { if(rabbitT*9&gt;i*3 &amp;&amp; (T-i)&gt;=30) //兔子大于乌龟，剩余时间不小于30分钟 i=i+29; //不是i=i+30, 最后还有i++ else if(rabbitT*9&gt;i*3 &amp;&amp; (T-i)&lt;30) //兔子大于乌龟，剩余时间小于30分钟 { i=T; break; } else if(T-i&gt;=10) //兔子小于乌龟，剩余时间不小于10分钟，兔子真正跑的时间+10 { rabbitT+=10; i=i+9; } else //兔子小于乌龟，剩余时间小于10分钟, 兔子真正跑的时间+T-i { rabbitT+=T-i; i=T; break; } } } if(i*3&gt;rabbitT*9) printf(\"@_@ %d\\n\",i*3); else if(i*3&lt;rabbitT*9) printf(\"^_^ %d\\n\",rabbitT*9); else printf(\"-_- %d\\n\",rabbitT*9); return 0;}","link":"/2018/04/15/jichu7-22/"},{"title":"7-24 约分最简分式（15 分）","text":"7-24 约分最简分式（15 分）分数可以表示为分子/分母的形式。编写一个程序，要求用户输入一个分数，然后将其约分为最简分式。最简分式是指分子和分母不具有可以约分的成分了。如6/12可以被约分为1/2。当分子大于分母时，不需要表达为整数又分数的形式，即11/8还是11/8；而当分子分母相等时，仍然表达为1/1的分数形式。 输入格式：输入在一行中给出一个分数，分子和分母中间以斜杠/分隔，如：12/34表示34分之12。分子和分母都是正整数（不包含0，如果不清楚正整数的定义的话）。 提示：在scanf的格式字符串中加入/，让scanf来处理这个斜杠。 输出格式：在一行中输出这个分数对应的最简分式，格式与输入的相同，即采用分子/分母的形式表示分数。如 5/6表示6分之5。 输入样例：166/120 输出样例：111/20 123456789101112131415161718192021#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(){ int zi,mu,i; scanf(\"%d/%d\",&amp;zi,&amp;mu); for(i=mu;i&gt;=2;i--){ if(zi%i==0&amp;&amp;mu%i==0){ zi=zi/i; mu=mu/i; } } printf(\"%d/%d\",zi,mu); return 0;}","link":"/2018/04/15/jichu7-24/"},{"title":"7-28 猴子选大王（20 分）","text":"7-28 猴子选大王（20 分）一群猴子要选新猴王。新猴王的选择方法是：让N只候选猴子围成一圈，从某位置起顺序编号为1~N号。从第1号开始报数，每轮从1报到3，凡报到3的猴子即退出圈子，接着又从紧邻的下一只猴子开始同样的报数。如此不断循环，最后剩下的一只猴子就选为猴王。请问是原来第几号猴子当选猴王？ 输入格式：输入在一行中给一个正整数$N（\\leq 1000）$。 输出格式：在一行中输出当选猴王的编号。 输入样例：111 输出样例：17 12345678910#include &lt;stdio.h&gt;int main(){ int m,i,s=0; scanf(\"%d\",&amp;m); for(i=1 ; i&lt;=m ; i++) s = (s+3) % i ; printf(\"%d\\n\",s+1); return 0 ;}","link":"/2018/04/15/jichu7-28/"},{"title":"7-27 冒泡法排序（20 分）","text":"7-27 冒泡法排序（20 分）将N个整数按从小到大排序的冒泡排序法是这样工作的：从头到尾比较相邻两个元素，如果前面的元素大于其紧随的后面元素，则交换它们。通过一遍扫描，则最后一个元素必定是最大的元素。然后用同样的方法对前$N−1$个元素进行第二遍扫描。依此类推，最后只需处理两个元素，就完成了对N个数的排序。 本题要求对任意给定的$K（\\lt N）$，输出扫描完第K遍后的中间结果数列。 输入格式：输入在第1行中给出$N\\text{和}K（1\\leq K\\lt N\\leq 100）$，在第2行中给出N个待排序的整数，数字间以空格分隔。 输出格式：在一行中输出冒泡排序法扫描完第K遍后的中间结果数列，数字间以空格分隔，但末尾不得有多余空格。 输入样例：126 22 3 5 1 6 4 输出样例：12 1 3 4 5 6 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;stdio.h&gt;#define MAX 101int main (void){ //====region for 前期输入工作======= int A[MAX] = {0}; int N,K; scanf(\"%d %d\", &amp;N, &amp;K); int count; for ( count = 0; count &lt; N; count++){ scanf(\"%d\", &amp;A[count]); } //====endregion===================== //=====实现冒泡排序================= int i; int tmp; for ( i =0;i &lt; K; i++){ for (count = 0;count &lt; N - i - 1; count++){ if ( A[count] &gt; A[count + 1]){ tmp = A[count + 1]; A[count + 1] = A[count]; A[count] = tmp; } } } //========冒泡算法结束=========================== //=========打印结果========================= for ( i =0; i&lt; N-1; i++){ printf(\"%d \", A[i]); } printf(\"%d\", A[N-1]); //========打印结束========================= return 0;}","link":"/2018/04/15/jichu7-27/"},{"title":"7-3 逆序的三位数（10 分）","text":"7-3 逆序的三位数（10 分）程序每次读入一个正3位数，然后输出按位逆序的数字。注意：当输入的数字含有结尾的0时，输出不应带有前导的0。比如输入700，输出应该是7。 输入格式：每个测试是一个3位的正整数。 输出格式：输出按位逆序的数。 输入样例：1123 输出样例：1321 1234567891011121314#include &lt;stdio.h&gt;int main(int argc, const char * argv[]){ int a, b; scanf(\"%d\", &amp;a); b = a % 10 * 100 + a / 10 % 10 * 10 + a / 100; printf(\"%d\\n\", b); return 0;}","link":"/2018/04/13/jichu7-3/"},{"title":"7-30 字符串的冒泡排序（20 分）","text":"7-30 字符串的冒泡排序（20 分）我们已经知道了将N个整数按从小到大排序的冒泡排序法。本题要求将此方法用于字符串序列，并对任意给定的$K（\\lt N）$，输出扫描完第K遍后的中间结果序列。 输入格式：输入在第1行中给出N和$K（1\\leq K\\lt N\\leq 100）$，此后N行，每行包含一个长度不超过10的、仅由小写英文字母组成的非空字符串。 输出格式：输出冒泡排序法扫描完第K遍后的中间结果序列，每行包含一个字符串。 输入样例：12345676 2bestcateastafreeday 输出样例：123456bestacatdayeastfree 1234567891011121314151617181920212223242526272829#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main(){ int m,n; while(scanf(\"%d%d\",&amp;m,&amp;n)!=EOF) { char a[101][11]; char b[11]; int i,j; for(i=0;i&lt;m;i++) scanf(\"%s\",&amp;*a[i]); for(j=0;j&lt;n;j++) { for(i=0;i&lt;m-1-j;i++) { if(strcmp(a[i],a[i+1])&gt;0) { strcpy(b,a[i]); strcpy(a[i],a[i+1]); strcpy(a[i+1],b); } } } for(i=0;i&lt;m;i++) printf(\"%s\\n\",a[i]); } return 0;}","link":"/2018/04/15/jichu7-30/"},{"title":"7-29 删除字符串中的子串（20 分）","text":"7-29 删除字符串中的子串（20 分）输入2个字符串S1和S2，要求删除字符串S1中出现的所有子串S2，即结果字符串中不能包含S2。 输入格式：输入在2行中分别给出不超过80个字符长度的、以回车结束的2个非空字符串，对应S1和S2。 输出格式：在一行中输出删除字符串S1中出现的所有子串S2后的结果字符串。 输入样例：12Tomcat is a male ccatatcat 输出样例：1Tom is a male 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;stdio.h&gt;char s1[80]={\"\"};char s2[80]={\"\"};int main(){ int i,j; int m=0;//s1共输入m个字符 int n=0;//s2共输入n个字符 int comp=0;//用于标记是否重复 int a,b; int c; for(i=0;;i++){ scanf(\"%c\",&amp;s1[i]); if(s1[i]=='\\n'){ break; } m++; } for(j=0;;j++){ scanf(\"%c\",&amp;s2[j]); if(s2[j]=='\\n'){ break; } n++; } for(a=0;a&lt;m;a++){ if(s1[a]==s2[0]){ comp=1; } for(b=0;b&lt;=n-1;b++){ if(s1[a+b]!=s2[b]){ comp=0; } } if(comp==1){ m=m-n; for(c=a;c&lt;m;c++){ s1[c]=s1[c+n]; } a=-1;//此处a=-1而不是0，防止s1数组初始位置开始即与s2重合 s1[m]='\\0'; comp=0; } } for(int i=0;i&lt;m;i++){ printf(\"%c\",s1[i]); }}","link":"/2018/04/15/jichu7-29/"},{"title":"7-26 单词长度（15 分）","text":"7-26 单词长度（15 分）你的程序要读入一行文本，其中以空格分隔为若干个单词，以.结束。你要输出每个单词的长度。这里的单词与语言无关，可以包括各种符号，比如it's算一个单词，长度为4。注意，行中可能出现连续的空格；最后的.不计算在内。 输入格式：输入在一行中给出一行文本，以.结束 提示：用scanf(&quot;%c&quot;,...);来读入一个字符，直到读到.为止。 输出格式：在一行中输出这行文本对应的单词的长度，每个长度之间以空格隔开，行末没有最后的空格。 输入样例：1It&apos;s great to see you here. 输出样例：14 5 2 3 3 4 123456789101112131415161718192021222324252627282930313233343536#include&lt;stdio.h&gt;int main(){ char c; int cot=0,ans[100]= {0},i=0; while ((c=getchar())!='.') { if (c!=' ') { cot++; ans[i]=cot; } else if (cot!=0) { ans[i] = cot; i++; cot=0; } } i=0; if (ans[0]==0) printf(\"%d\",ans[0]); else while(ans[i]!=0) { if (i==0) printf(\"%d\",ans[i]); else printf(\" %d\",ans[i]); i++; } return 0;}","link":"/2018/04/15/jichu7-26/"},{"title":"7-33 有理数加法（15 分）","text":"7-33 有理数加法（15 分）本题要求编写程序，计算两个有理数的和。 输入格式：输入在一行中按照a1/b1 a2/b2的格式给出两个分数形式的有理数，其中分子和分母全是整形范围内的正整数。 输出格式：在一行中按照a/b的格式输出两个有理数的和。注意必须是该有理数的最简分数形式，若分母为1，则只输出分子。 输入样例1：11/3 1/6 输出样例1：11/2 输入样例2：14/3 2/3 输出样例2：12 12345678910111213141516171819202122232425262728293031323334353637#include &lt;stdio.h&gt;int gcd(int, int);struct fraction{ int a; //分子 int b; //分母};int main(void){ struct fraction f1, f2, f3; int g; scanf(\"%d/%d %d/%d\", &amp;f1.a, &amp;f1.b, &amp;f2.a, &amp;f2.b); f3.a = f1.a*f2.b + f2.a*f1.b; f3.b = f1.b*f2.b; g = gcd(f3.a, f3.b); f3.a /= g; f3.b /= g; if (f3.b == 1) printf(\"%d\", f3.a); else printf(\"%d/%d\", f3.a, f3.b); return 0;}int gcd(int x, int y){ int r; while (1) { r = x%y; if (r == 0) break; x = y; y = r; } return y;}","link":"/2018/04/15/jichu7-33/"},{"title":"7-32 说反话-加强版（20 分）","text":"7-32 说反话-加强版（20 分）给定一句英语，要求你编写程序，将句中所有单词的顺序颠倒输出。 输入格式：测试输入包含一个测试用例，在一行内给出总长度不超过500 000的字符串。字符串由若干单词和若干空格组成，其中单词是由英文字母（大小写有区分）组成的字符串，单词之间用若干个空格分开。 输出格式：每个测试用例的输出占一行，输出倒序后的句子，并且保证单词间只有1个空格。 输入样例：1Hello World Here I Come 输出样例：1Come I Here World Hello 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;stdio.h&gt;char a[500001];char *p;int i;int m=0;int flag=0;int num=0;int main(){ for(i=0;i&lt;500001;i++){ //此处i&lt;500000就会在最后一个测试点报错 scanf(\"%c\",&amp;a[i]); if(a[i]=='\\n'){ m=i; a[i]='\\0'; break; }//从a[0]到a[i-1]共有i个字符 } for(i=m-1;i&gt;=0;i--){ if(a[i]!=' '&amp;&amp;a[i-1]!=' '&amp;&amp;i!=0){ num++; }else if(a[i]!=' '&amp;&amp;a[i-1]==' '){ num++; flag++; p=&amp;a[i]; }else if(a[i]!=' '&amp;&amp;i==0){ num++; flag++; p=&amp;a[i]; } if(flag==1&amp;&amp;num!=0){ for(;num&gt;0;num--){ printf(\"%c\",*p); p++; } num=0; flag++;//防止重复判断flag==1的情况 }else if(flag&gt;1&amp;&amp;num!=0){ if(a[i-1]==' '||i==0){ printf(\" \"); for(;num&gt;0;num--){ printf(\"%c\",*p); p++; } num=0; } } } return 0;}","link":"/2018/04/15/jichu7-32/"},{"title":"7-31 字符串循环左移（20 分）","text":"7-31 字符串循环左移（20 分）输入一个字符串和一个非负整数N，要求将字符串循环左移N次。 输入格式：输入在第1行中给出一个不超过100个字符长度的、以回车结束的非空字符串；第2行给出非负整数N。 输出格式：在一行中输出循环左移N次后的字符串。 输入样例：12Hello World!2 输出样例：1llo World!He 12345678910111213141516171819202122232425#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main(int argc, char const *argv[]){ char str[101]; int i = 0; int c; while((c=getchar()) != '\\n'){// 记录字符串 str[i] = (char) c; i++; } str[i] = '\\0'; char *start; start = &amp;str[0]; int sp; scanf(\"%d\", &amp;sp); char sa[101]; //生成新的字符串 sp = sp%(strlen(str)); strcpy(sa, start+sp); *(start + sp) = '\\0'; strcat(sa, start); printf(\"%s\\n\", sa);}","link":"/2018/04/15/jichu7-31/"},{"title":"7-34 通讯录的录入与显示（10 分）","text":"7-34 通讯录的录入与显示（10 分）通讯录中的一条记录包含下述基本信息：朋友的姓名、出生日期、性别、固定电话号码、移动电话号码。 本题要求编写程序，录入N条记录，并且根据要求显示任意某条记录。 输入格式：输入在第一行给出正整数$N（\\leq 10）$；随后N行，每行按照格式姓名 生日 性别 固话 手机给出一条记录。其中姓名是不超过10个字符、不包含空格的非空字符串；生日按yyyy/mm/dd的格式给出年月日；性别用M表示“男”、F表示“女”；固话和手机均为不超过15位的连续数字，前面有可能出现+。 在通讯录记录输入完成后，最后一行给出正整数K，并且随后给出K个整数，表示要查询的记录编号（从0到N−1顺序编号）。数字间以空格分隔。 输出格式：对每一条要查询的记录编号，在一行中按照姓名 固话 手机 性别 生日的格式输出该记录。若要查询的记录不存在，则输出Not Found。 输入样例：123453Chris 1984/03/10 F +86181779452 13707010007LaoLao 1967/11/30 F 057187951100 +8618618623333QiaoLin 1980/01/01 M 84172333 100862 1 7 输出样例：12LaoLao 057187951100 +8618618623333 F 1967/11/30Not Found 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;typedef struct node{ char name[11]; char birthday[11]; char sex; char num[17]; char phone[17]; struct node* next;}type;void output(type* head,int N);type* input(int N);int main(void){ type *head; int N; //int i=0,j=0; scanf(\"%d\",&amp;N); head=input(N); output(head,N); return 0;}type* input(int N){ type *p,*q,*head; int i=0; p=q=(type*)malloc(sizeof(type)); for(i=0;i&lt;N;i++) { scanf(\"%s %s %c %s %s\\n\",p-&gt;name,p-&gt;birthday,&amp;(p-&gt;sex),p-&gt;num,p-&gt;phone); if(i==0) { head=p; } else { q-&gt;next=p; } q=p; p=(type*)malloc(sizeof(type)); } q-&gt;next=NULL; p-&gt;next=NULL; return head;}void output(type* head,int N){ int K,i,j; scanf(\"%d\",&amp;K); int a[K]; type *q; //p=q=(type*)malloc(sizeof(type)); for(i=0;i&lt;K;i++) { scanf(\"%d\",&amp;a[i]); } for(i=0;i&lt;K;i++) { if(a[i]&lt;N&amp;&amp;a[i]&gt;=0) { q=head; for(j=0;j&lt;a[i];j++) { q=q-&gt;next; } printf(\"%s %s %s %c %s\\n\",q-&gt;name,q-&gt;num,q-&gt;phone,q-&gt;sex,q-&gt;birthday); } else { printf(\"Not Found\\n\"); } }}","link":"/2018/04/15/jichu7-34/"},{"title":"7-35 有理数均值（20 分）","text":"7-35 有理数均值（20 分）本题要求编写程序，计算N个有理数的平均值。 输入格式：输入第一行给出正整数$N（\\leq 100）$；第二行中按照a1/b1 a2/b2 …的格式给出N个分数形式的有理数，其中分子和分母全是整形范围内的整数；如果是负数，则负号一定出现在最前面。 输出格式：在一行中按照a/b的格式输出N个有理数的平均值。注意必须是该有理数的最简分数形式，若分母为1，则只输出分子。 输入样例1：1241/2 1/6 3/6 -5/10 输出样例1：11/6 输入样例2：1224/3 2/3 输出样例2：11 1234567891011121314151617181920212223242526272829303132333435#include&lt;stdio.h&gt;int gcd(int p,int q){ if (q==0) return p; int r = p%q; return gcd(q,r);}int main(){ int N,sumA=0,sumB=1; scanf(\"%d\",&amp;N); for(int i=0; i&lt;N; i++) { int a=0,b=1; scanf(\"%d/%d\",&amp;a,&amp;b); sumA *= b; sumA += a*sumB; sumB *= b; if(i==N-1) sumB*=N; int divisor = gcd(sumA,sumB); sumA/=divisor;sumB/=divisor; } if (sumA==0) printf(\"0\"); else if(sumB==1) printf(\"%d\",sumA); else printf(\"%d/%d\",sumA,sumB); return 0;}","link":"/2018/04/15/jichu7-35/"},{"title":"7-37 整数分解为若干项之和（20 分）","text":"7-37 整数分解为若干项之和（20 分）将一个正整数N分解成几个正整数相加，可以有多种分解方法，例如$17=6+1, \\quad 7=5+2, \\quad 7=5+1+1, \\dots$。编程求出正整数N的所有整数分解式子。 输入格式：每个输入包含一个测试用例，即正整数$N (0\\lt N\\leq 30)$。 输出格式：按递增顺序输出N的所有整数分解式子。递增顺序是指：对于两个分解序列N1={n1,n2,⋯}和N2={m1,m2,⋯}，若存在i使得n1=m1,⋯,ni=mi，但是ni+1&lt;mi+1,则N1序列必定在N2序列之前输出。每个式子由小到大相加，式子间用分号隔开，且每输出4个式子后换行。 输入样例：17 输出样例：12347=1+1+1+1+1+1+1;7=1+1+1+1+1+2;7=1+1+1+1+3;7=1+1+1+2+27=1+1+1+4;7=1+1+2+3;7=1+1+5;7=1+2+2+27=1+2+4;7=1+3+3;7=1+6;7=2+2+37=2+5;7=3+4;7=7 1234567891011121314151617181920212223242526272829303132333435363738394041/*深度优先搜索*/#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int item[31];int top=0;/*当前数组元素个数*/int sum=0;/*累加和*/int n;/*所给的数*/int k;/*记录每行输出是否满了四个*/void dfs(int number){ if(sum==n){ k++; printf(\"%d=%d\",n,item[0]); for(int i=1;i&lt;=top-1;i++) printf(\"+%d\",item[i]); if(k%4==0||top==1) printf(\"\\n\"); else printf(\";\"); } if(sum&gt;n){ return; } for(int i=number;i&lt;=n;i++){ sum=sum+i; item[top++]=i; dfs(i); sum=sum-i; top--; }}int main(){ scanf(\"%d\",&amp;n); dfs(1); return 0;}","link":"/2018/04/15/jichu7-37/"},{"title":"7-4 BCD解密（10 分）","text":"7-4 BCD解密（10 分）BCD数是用一个字节来表达两位十进制的数，每四个比特表示一位。所以如果一个BCD数的十六进制是0x12，它表达的就是十进制的12。但是小明没学过BCD，把所有的BCD数都当作二进制数转换成十进制输出了。于是BCD的0x12被输出成了十进制的18了！ 现在，你的程序要读入这个错误的十进制数，然后输出正确的十进制数。提示：你可以把18转换回0x12，然后再转换回12。 输入格式：输入在一行中给出一个[0, 153]范围内的正整数，保证能转换回有效的BCD数，也就是说这个整数转换成十六进制时不会出现A-F的数字。 输出格式：输出对应的十进制数。 输入样例：118 输出样例：112 123456789101112#include &lt;stdio.h&gt; int main() { int x; int n, a; scanf(\"%d\", &amp;x); a = x % 16; n = x / 16 * 10 + a; printf(\"%d\", n); return 0; } //由于他给的输入范围恰好为16进制的0~9，实际上是把16进制的数转换成10进制输出，比较简单","link":"/2018/04/13/jichu7-4/"},{"title":"7-36 复数四则运算（15 分）","text":"7-36 复数四则运算（15 分）本题要求编写程序，计算2个复数的和、差、积、商。 输入格式：输入在一行中按照a1 b1 a2 b2的格式给出2个复数C1=a1+b1i和C2=a2+b2i的实部和虚部。题目保证C2不为0。 输出格式：分别在4行中按照(a1+b1i) 运算符 (a2+b2i) = 结果的格式顺序输出2个复数的和、差、积、商，数字精确到小数点后1位。如果结果的实部或者虚部为0，则不输出。如果结果为0，则输出0.0。 输入样例1：12 3.08 -2.04 5.06 输出样例1：1234(2.0+3.1i) + (-2.0+5.1i) = 8.1i(2.0+3.1i) - (-2.0+5.1i) = 4.0-2.0i(2.0+3.1i) * (-2.0+5.1i) = -19.7+3.8i(2.0+3.1i) / (-2.0+5.1i) = 0.4-0.6i 输入样例2：11 1 -1 -1.01 输出样例2：1234(1.0+1.0i) + (-1.0-1.0i) = 0.0(1.0+1.0i) - (-1.0-1.0i) = 2.0+2.0i(1.0+1.0i) * (-1.0-1.0i) = -2.0i(1.0+1.0i) / (-1.0-1.0i) = -1.0 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394//两个复数运算前不变化，但输出时要保留后一位；//运算结果，由题意，要先保留一位小数#include &lt;stdio.h&gt;#include &lt;math.h&gt;struct data{ double num1; double num2;};char item[4]=\"+-*/\";void myprintf(double num1,double num2,int flag){ if(flag){//运算结果输出 if(num1==0&amp;&amp;num2==0) printf(\"0.0\"); else{ if(num1!=0&amp;&amp;num2==0) printf(\"%.1f\",num1); else if(num1==0&amp;&amp;num2!=0) printf(\"%.1fi\",num2); else{ printf(\"%.1f\",num1); if(num2&gt;0) printf(\"+%.1fi\",num2); else printf(\"%.1fi\",num2); } } } else{//复数输出 if(num2&lt;0){ printf(\"%.1f%.1fi\",num1,num2); }else{ printf(\"%.1f+%.1fi\",num1,num2); } }}double simpl(double num){//运算结果保留一位小数 if(num&gt;0) num=(double)floor((num+0.05)*10)/10; else if(num&lt;0){ num=fabs(num); num=-(double)floor((num+0.05)*10)/10; } return num;}void getresult(struct data cal[],int time)//运算{ double temp1,temp2,temp; switch(time) { case 0:cal[2].num1=cal[0].num1+cal[1].num1; cal[2].num2=cal[0].num2+cal[1].num2; break; case 1:cal[2].num1=cal[0].num1-cal[1].num1; cal[2].num2=cal[0].num2-cal[1].num2; break; case 2:cal[2].num1=cal[0].num1*cal[1].num1-cal[0].num2*cal[1].num2; cal[2].num2=cal[0].num1*cal[1].num2+cal[0].num2*cal[1].num1; break; case 3:temp1=cal[0].num1*cal[1].num1+cal[0].num2*cal[1].num2; temp2=cal[0].num2*cal[1].num1-cal[0].num1*cal[1].num2; temp=cal[1].num2*cal[1].num2+cal[1].num1*cal[1].num1; cal[2].num1=temp1/temp; cal[2].num2=temp2/temp; break; } cal[2].num1=simpl(cal[2].num1); cal[2].num2=simpl(cal[2].num2); myprintf(cal[2].num1,cal[2].num2,1); printf(\"\\n\");}int main(){ struct data cal[3]; for(int i=0;i&lt;=1;i++){ scanf(\"%lf%lf\",&amp;cal[i].num1,&amp;cal[i].num2); } for(int i=0;i&lt;4;i++){ printf(\"(\"); myprintf(cal[0].num1,cal[0].num2,0); printf(\")\"); printf(\" %c \",item[i]); printf(\"(\"); myprintf(cal[1].num1,cal[1].num2,0); printf(\") = \"); //printf(\" = \",item[i]); getresult(cal,i); } return 0;}","link":"/2018/04/15/jichu7-36/"},{"title":"7-5 表格输出（5 分）","text":"7-5 表格输出（5 分）本题要求编写程序，按照规定格式输出表格。 输入格式：本题目没有输入。 输出格式：要求严格按照给出的格式输出下列表格： 123456789------------------------------------Province Area(km2) Pop.(10K)------------------------------------Anhui 139600.00 6461.00Beijing 16410.54 1180.70Chongqing 82400.00 3144.23Shanghai 6340.50 1360.26Zhejiang 101800.00 4894.00------------------------------------ 12345678910111213141516#include &lt;stdio.h&gt; int main(){ printf(\"------------------------------------\\n\"); printf(\"Province Area(km2) Pop.(10K)\\n\"); printf(\"------------------------------------\\n\"); printf(\"Anhui 139600.00 6461.00\\n\"); printf(\"Beijing 16410.54 1180.70\\n\"); printf(\"Chongqing 82400.00 3144.23\\n\"); printf(\"Shanghai 6340.50 1360.26\\n\"); printf(\"Zhejiang 101800.00 4894.00\\n\"); printf(\"------------------------------------\\n\"); return 0;}","link":"/2018/04/15/jichu7-5/"},{"title":"7-38 数列求和-加强版（20 分）","text":"7-38 数列求和-加强版（20 分）给定某数字$A(1 \\leq A \\leq 9)$以及非负整数$N(0 \\leq N \\leq 100000)$，求数列之和$S=A+A A+A A A+\\cdots+A A \\cdots A(N \\text{个} A)。$例如$A=1, N=3$时，$S=1+11+111=123$。 输入格式：输入数字A与非负整数N。 输出格式：输出其N项数列之和S的值。 输入样例：11 3 输出样例：1123 123456789101112131415161718192021222324252627282930313233343536#include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;math.h&gt; int num[1000000]; int main() { int A; int N; int i; int j; int t; int flag; scanf(\"%d%d\",&amp;A,&amp;N); if(N == 0) printf(\"0\\n\"); else { flag = 0; for(i=N, j=0; i&gt;=1; i--, j++) { t = A*i + flag; flag = t / 10; num[j] = t % 10; } if(flag &gt; 0) { num[j] = flag; j++; } for(i=j-1; i&gt;=0; i--) { printf(\"%d\",num[i]); } } return 0; }","link":"/2018/04/15/jichu7-38/"},{"title":"7-6 混合类型数据格式化输入（5 分）","text":"7-6 混合类型数据格式化输入（5 分）本题要求编写程序，顺序读入浮点数1、整数、字符、浮点数2，再按照字符、整数、浮点数1、浮点数2的顺序输出。 输入格式：输入在一行中顺序给出浮点数1、整数、字符、浮点数2，其间以1个空格分隔。 输出格式：在一行中按照字符、整数、浮点数1、浮点数2的顺序输出，其中浮点数保留小数点后2位。 输入样例：12.12 88 c 4.7 输出样例：1c 88 2.12 4.70 1234567891011#include &lt;stdio.h&gt; int main(){ int a; double b,c; char d; scanf(\"%lf %d %c %lf\",&amp;b,&amp;a,&amp;d,&amp;c); printf(\"%c %d %.2lf %.2lf\",d,a,b,c); return 0;}","link":"/2018/04/15/jichu7-6/"},{"title":"7-7 12-24小时制（15 分）","text":"7-7 12-24小时制（15 分）编写一个程序，要求用户输入24小时制的时间，然后显示12小时制的时间。 输入格式：输入在一行中给出带有中间的:符号（半角的冒号）的24小时制的时间，如12:34表示12点34分。当小时或分钟数小于10时，均没有前导的零，如5:6表示5点零6分。 提示：在scanf的格式字符串中加入:，让scanf来处理这个冒号。 输出格式：在一行中输出这个时间对应的12小时制的时间，数字部分格式与输入的相同，然后跟上空格，再跟上表示上午的字符串AM或表示下午的字符串PM。如5:6 PM表示下午5点零6分。注意，在英文的习惯中，中午12点被认为是下午，所以24小时制的12:00就是12小时制的12:0 PM；而0点被认为是第二天的时间，所以是0:0 AM。 输入样例：121:11 输出样例：19:11 PM 1234567891011121314151617181920212223242526#include&lt;stdio.h&gt;int main(){ char c; int a, b; scanf(\"%d%c%d\", &amp;a, &amp;c, &amp;b); if (a &gt;= 12) { if (a &gt;= 13)//计算大于等于13点的 { if (a == 24) printf(\"0:%d AM\\n\", b); else { a = a - 12; printf(\"%d:%d PM\\n\", a, b); } } else printf(\"%d:%d PM\\n\", a, b);//计算12点的 } else//计算小于12点的 printf(\"%d:%d AM\\n\", a, b); return 0;}","link":"/2018/04/15/jichu7-7/"},{"title":"JPA高級動態查詢","text":"1234567891011121314 @Overridepublic List&lt;String&gt; findAllByUserAndStatusAndDepartmentIn(User user, String key, Department department) { CriteriaBuilder criteriaBuilder = entityManager.getCriteriaBuilder(); CriteriaQuery&lt;String&gt; query = criteriaBuilder.createQuery(String.class); Root&lt;User&gt; root = query.from(User.class); query.select(root.get(\"id\")); Join&lt;User,Department&gt; join = root.join(\"departments\", JoinType.LEFT); query.orderBy(criteriaBuilder.desc(root.get(\"createdDate\"))); Predicate restrictions = criteriaBuilder.conjunction(); restrictions = criteriaBuilder.and(join.get(\"id\").in(department.getId())); query.where(restrictions); List&lt;String&gt; result = entityManager.createQuery(query).getResultList(); return result;}","link":"/2020/01/03/jpa-criteraBuilder/"},{"title":"leetcode-1-two-sum","text":"DescriptionGiven an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactlyone solution, and you may not use the same element twice. Example: 1234Given nums = [2, 7, 11, 15], target = 9,Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1]. 思路0從給定數組中找到兩個元素的和為指定值的兩個索引，最暴力的做法就是循環兩次，復雜度為$0(n^2)$ 123456789101112class Solution { public int[] twoSum(int[] nums, int target) { for (int i = 0; i &lt; nums.length; ++i) { for (int j = i + 1; j &lt; nums.length; ++j) { if (nums[i] + nums[j] == target) { return new int[]{i, j}; } } } return null; }} 思路1用HashMap為存儲，鍵為目標值減去當前元素的值，索引為值。比如 i = 0 時，此時首先要判斷 nums[0] = 2 是否在 map 中，如果不存在，那麽插入鍵值對 key = 9 - 2 = 7, value = 0，之後當 i = 1 時，此時判斷 nums[1] = 7 key = 9 - 7 = 2,value = 1 key =2 已存在於 map 中，那麽取出該 value = 0 作為第一個返回值，當前 i 作為第二個返回值 123456789101112131415161718192021222324252627import java.util.HashMap;public class Solution { public int[] twoSum(int[] nums, int target) { HashMap&lt;Integer,Integer&gt; hashMap = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++){ int key = target - nums[i]; if (hashMap.containsKey(key)){ return new int[]{hashMap.get(key), i}; } hashMap.put(nums[i],i); } throw new IllegalArgumentException(\"No two sum solution\"); }} #### 123456789101112131415class Solution(object): def twoSum(self, nums, target): \"\"\" :type nums: List[int] :type target: int :rtype: List[int] \"\"\" numberIndexDict = {} for i, x in enumerate(nums): y = target - x if y in numberIndexDict: return [numberIndexDict[y], i] # 存下标 numberIndexDict[x] =","link":"/2018/09/01/leetcode-1-two-sum/"},{"title":"7-8 超速判断（10 分）","text":"7-8 超速判断（10 分）模拟交通警察的雷达测速仪。输入汽车速度，如果速度超出60 mph，则显示“Speeding”，否则显示“OK”。 输入格式：输入在一行中给出1个不超过500的非负整数，即雷达测到的车速。 输出格式：在一行中输出测速仪显示结果，格式为：Speed: V - S，其中V是车速，S或者是Speeding、或者是OK。 输入样例1：140 输出样例1：1Speed: 40 - OK 输入样例2：175 输出样例2：1Speed: 75 - Speeding 123456789101112#include&lt;stdio.h&gt;int main(){ int speed; scanf(\"%d\",&amp;speed); if(speed&lt;=60) printf(\"Speed: %d - OK\",speed); else printf(\"Speed: %d - Speeding\",speed); return 0;}","link":"/2018/04/15/jichu7-8/"},{"title":"7-9 用天平找小球（10 分）","text":"7-9 用天平找小球（10 分）三个球A、B、C，大小形状相同且其中有一个球与其他球重量不同。要求找出这个不一样的球。 输入格式：输入在一行中给出3个正整数，顺序对应球A、B、C的重量。 输出格式：在一行中输出唯一的那个不一样的球。 输入样例：11 1 2 输出样例：1C 12345678910111213141516#include&lt;stdio.h&gt;int main(){ int a,b,c; scanf(\"%d%d%d\",&amp;a,&amp;b,&amp;c); if(a==b&amp;&amp;a!=c) printf(\"C\"); if(a==c&amp;&amp;a!=b) printf(\"B\"); if(b==c&amp;&amp;b!=a) printf(\"A\"); return 0;}","link":"/2018/04/15/jichu7-9/"},{"title":"經常面試到的SQL題(查詢重複數據和清除重複數據)","text":"sql查詢消除重複數據 如數據庫有一名為biau的表： 字段與數據例如下如：biau id name address 1 小王 重慶 2 小張 北京 3 小明 上海 4 小紅 重慶 要求用sql查詢出按不同address（地址）的排列的所有數據(即地址不能重複，如有重複只選取一次，其他列數據可以重複) 查询SQL如下 id name address 4 小紅 重慶 3 小明 上海 2 小張 北京 1select * from biau where id in (select max(id) from biau group by address) order by id desc 常見的SQL問題：◆選擇重複，消除重複和選擇出序列有例表：emp| emp_no | name | age ||:————-:|:————-:|:————-:|| 001 | Tom | 17 || 002 | Sun | 14 || 003 | Tom | 15 || 004 | Tom | 16 | 要求：列出所有名字重複的人的記錄(1)最直觀的思路：要知道所有名字有重複人資料，首先必須知道哪個名字重複了：1select name from emp group by name having count(*)&gt;1 所有名字重複人的記錄是:1select * from emp where name in(select name from emp group by name having count(*)&gt;1) (2)稍微再聰明一點，就會想到，如果對每個名字都和原表進行比較，大於2個人名字與這條記錄相同的就是合格的 ，就有1select * from emp where (select count(*) from emp e where e.name=emp.name)&gt;1 –注意一下這個&gt;1，想下如果是 =1，如果是 =2 如果是&gt;2 如果 e 是另外一張表 而且是=0那結果 就更好玩了:)這個過程是 在判斷工號為001的人的時候先取得 001的名字（emp.name） 然後和原表的名字進行比較 e.name注意e是emp的一個別名。再稍微想得多一點，就會想到，如果有另外一個名字相同的人工號不與她他相同那麼這條記錄符合要求：1select * from emp where exists (select * from emp e where e.name=emp.name and e.emp_no&lt;&gt;emp.emp_no) 此思路的join寫法：1select emp.* from emp,emp e where emp.name=e.name and emp.emp_no&lt;&gt;e.emp_no /* 這個語句較規範的join寫法是1select emp.* from emp inner join emp e on emp.name=e.name and emp.emp_no&lt;&gt;e.emp_no 但個人比較傾向於前一種寫法，關鍵是更清晰 */b、有例表：emp name age Tom 16 Sun 14 Tom 16 Tom 16 —————————————————-清除重複—————————————————-過濾掉所有多餘的重複記錄(1)我們知道distinct、group by 可以過濾重複，於是就有最直觀的1select distinct * from emp 或 select name,age from emp group by name,age 獲得需要的數據，如果可以使用臨時表就有解法：1select distinct * into #tmp from emp delete from emp insert into emp select * from #tmp (2)但是如果不可以使用臨時表，那該怎麼辦？我們觀察到我們沒辦法區分數據（物理位置不一樣，對 SQL Server來說沒有任何區別），思路自然是想辦法把數據區分出來了，既然現在的所有的列都沒辦法區分數據，唯一的辦法就是再加個列讓它區分出來，加什麼列好？最佳選擇是identity列：1alter table emp add chk int identity(1,1) 表示例： name age chk Tom 16 1 Sun 14 2 Tom 16 3 Tom 16 4 重複記錄可以表示為：1select * from emp where (select count(*) from emp e where e.name=emp.name)&gt;1 要刪除的是：1delete from emp where (select count(*) from emp e where e.name=emp.name and e.chk&gt;=emp.chk)&gt;1 再把添加的列刪掉，出現結果。1alter table emp drop column chk (3)另一個思路：視圖1select min(chk) from emp group by name having count(*)&gt;1 獲得有重複的記錄chk最小的值,於是可以1delete from emp where chk not in (select min(chk) from emp group by name) 寫成join的形式也可以:(1)有例表：emp emp_no name age 001 Tom 17 002 Sun 14 003 Tom 15 004 Tom 16 ◆要求生成序列號(1)最簡單的方法，根據b問題的解法：12alter table emp add chk int identity(1,1)或 select *,identity(int,1,1) chk into #tmp from emp ◆如果需要控制順序怎麼辦？1select top 100000 *,identity(int,1,1) chk into #tmp from emp order by age (2) 假如不可以更改表結構，怎麼辦？如果不可以唯一區分每條記錄是沒有辦法的，在可以唯一區分每條記錄的時候,可以使用a 中的count的思路解決這個問題1select emp.*,(select count(*) from emp e where e.emp_no&lt;=emp.emp_no) from emp order by (select count(*) from emp e where e.emp_no&lt;=emp.emp_no)","link":"/2016/10/22/jingchangmienshrdaudeSQLti(chasiunchungfushujiuhecingchuchungfushujiu)/"},{"title":"leetcode-125-valid-parentheses","text":"DescriptionGiven a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases. Note: For the purpose of this problem, we define empty string as valid palindrome. Example 1: 12Input: &quot;A man, a plan, a canal: Panama&quot;Output: true Example 2: 12Input: &quot;race a car&quot;Output: false #### 123456789101112131415161718import java.util.Stack;public class Solution { public boolean isValid(String s) { Stack&lt;Character&gt; stack = new Stack&lt;Character&gt;(); //使用foreach循环 for (char c : s.toCharArray()) { if (c == '(') stack.push(')'); else if (c == '{') stack.push('}'); else if (c == '[') stack.push(']'); else if (stack.isEmpty() || stack.pop() != c) return false; } return stack.isEmpty(); }}","link":"/2018/09/01/leetcode-125-valid-parentheses/"},{"title":"leetcode-142-linked-list-cycle-ii","text":"DescriptionGiven a linked list, return the node where the cycle begins. If there is no cycle, return null. To represent a cycle in the given linked list, we use an integer pos which represents the position (0-indexed) in the linked list where tail connects to. If pos is -1, then there is no cycle in the linked list. Note: Do not modify the linked list. Example 1: 123Input: head = [3,2,0,-4], pos = 1Output: tail connects to node index 1Explanation: There is a cycle in the linked list, where tail connects to the second node. Example 2: 123Input: head = [1,2], pos = 0Output: tail connects to node index 0Explanation: There is a cycle in the linked list, where tail connects to the first node. Example 3: 123Input: head = [1], pos = -1Output: no cycleExplanation: There is no cycle in the linked list. 思路0哈希表,如果我們用一個 Set 保存已經訪問過的節點，我們可以遍歷整個列表並返回第壹個出現重復的節點。 12345678910111213141516public class Solution { public ListNode detectCycle(ListNode head) { Set&lt;ListNode&gt; visited = new HashSet&lt;ListNode&gt;(); ListNode node = head; while (node != null) { if (visited.contains(node)) { return node; } visited.add(node); node = node.next; } return null; }} ####思路1 Floyd 算法,Floyd 的算法被劃分成兩個不同的 階段 。在第壹階段，找出列表中是否有環，如果沒有環，可以直接返回 null 並退出。否則，用 相遇節點 來找到環的入口。 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class Solution { private ListNode getIntersect(ListNode head) { ListNode tortoise = head; ListNode hare = head; // A fast pointer will either loop around a cycle and meet the slow // pointer or reach the `null` at the end of a non-cyclic list. while (hare != null &amp;&amp; hare.next != null) { tortoise = tortoise.next; hare = hare.next.next; if (tortoise == hare) { return tortoise; } } return null;} public ListNode detectCycle(ListNode head) { if (head == null) { return null; } // If there is a cycle, the fast/slow pointers will intersect at some // node. Otherwise, there is no cycle, so we cannot find an e***ance to // a cycle. ListNode intersect = getIntersect(head); if (intersect == null) { return null; } // To find the e***ance to the cycle, we have two pointers traverse at // the same speed -- one from the front of the list, and the other from // the point of intersection. ListNode ptr1 = head; ListNode ptr2 = intersect; while (ptr1 != ptr2) { ptr1 = ptr1.next; ptr2 = ptr2.next; } return ptr1; }}","link":"/2018/09/01/leetcode-142-linked-list-cycle-ii/"},{"title":"leetcode-141-linked-list-cycle","text":"DescriptionGiven a linked list, determine if it has a cycle in it. To represent a cycle in the given linked list, we use an integer pos which represents the position (0-indexed) in the linked list where tail connects to. If pos is -1, then there is no cycle in the linked list. Example 1: 123Input: head = [3,2,0,-4], pos = 1Output: trueExplanation: There is a cycle in the linked list, where tail connects to the second node. Example 2: 123Input: head = [1,2], pos = 0Output: trueExplanation: There is a cycle in the linked list, where tail connects to the first node. Example 3: 123Input: head = [1], pos = -1Output: falseExplanation: There is no cycle in the linked list. 思路0給一個足夠大的數，如果還沒走出鏈錶很大概率有環。 1234567891011public class Solution { public boolean hasCycle(ListNode head) { if(head == null) return false; while(head.next != null &amp;&amp; head.next.val != Integer.MIN_VALUE){ head.val = Integer.MIN_VALUE; // 将已遍历的元素作标记 head = head.next; } if(head.next == null) return false; return true; }} ####思路1 題意可知這是判斷鏈錶是否是環形鏈表，那麼可以使用雙指針，通過使用通過使用具有不同速度的快、慢兩個指針遍歷鏈表，空間復雜度可以被降低至 O(1)O(1)。慢指針每次移動一步，而快指針每次移動兩步。如果列表中不存在環，最終快指針將會最先到達尾部，此時我們可以返回 false。 12345678910111213141516171819202122232425262728/** * Definition for singly-linked list. * class ListNode { * int val; * ListNode next; * ListNode(int x) { * val = x; * next = null; * } * } */public class Solution { public boolean hasCycle(ListNode head) { if (head == null || head.next == null) { return false; } ListNode slow = head; ListNode fast = head.next; while (slow != fast) { if (fast == null || fast.next == null) { return false; } slow = slow.next; fast = fast.next.next; } return true; }} 思路2我們可以通過檢查壹個結點此前是否被訪問過來判斷鏈表是否為環形鏈表。常用的方法是使用哈希表。我們遍歷所有結點並在哈希表中存儲每個結點的引用（或內存地址）。如果當前結點為空結點 null（即已檢測到鏈表尾部的下壹個結點），那麽我們已經遍歷完整個鏈表，並且該鏈表不是環形鏈表。如果當前結點的引用已經存在於哈希表中，那麽返回 true（即該鏈表為環形鏈表）。 123456789101112public boolean hasCycle(ListNode head) { Set&lt;ListNode&gt; nodesSeen = new HashSet&lt;&gt;(); while (head != null) { if (nodesSeen.contains(head)) { return true; } else { nodesSeen.add(head); } head = head.next; } return false;}","link":"/2018/09/01/leetcode-141-linked-list-cycle/"},{"title":"leetcode-19-remove-nth-node-from-end-of-list.md","text":"DescriptionGiven a linked list, remove the n-th node from the end of list and return its head. Example: 123Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2.After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5. Note: Given n will always be valid. Follow up: Could you do this in one pass? #### 123456789101112131415161718192021222324252627282930313233/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { * val = x; * next = null; * } * } */public class Solution { public ListNode removeNthFromEnd(ListNode head, int n) { if(head == null){ return head; } ListNode dummy = new ListNode(0); dummy.next = head; head = dummy; ListNode slow = head; ListNode fast = head; for(int i = 0; i &lt;n; i++){ fast = fast.next; } while(fast.next != null){ fast = fast.next; slow = slow.next; } ListNode temp = slow.next; slow.next = slow.next.next; return dummy.next; }}","link":"/2018/09/01/leetcode-19-remove-nth-node-from-end-of-list/"},{"title":"leetcode-15-three-sum","text":"DescriptionGiven an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero. Note: The solution set must not contain duplicate triplets. Example: 1234567Given array nums = [-1, 0, 1, 2, -1, -4],A solution set is:[ [-1, 0, 1], [-1, -1, 2]] #### 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * @note leetcode-三数之和为0 * @apiNote 思路为 先排序， 然后有两个指针 head和end。 要计算的第一个数一定是负数,所以只要后两个数相加等于 * 0-第一个数 即可。 * @since 19-8-26 10:27 by jdk 1.8 */public class ThreeSum { private static List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) { List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); //进行排序 Arrays.sort(nums); for (int i = 0; i &lt; nums.length; i++) { if (nums[i] &gt; 0) { return result; } //之前的相等，我选择跳过 if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) { continue; } int header = i + 1; int end = nums.length - 1; int val = 0 - nums[i]; while (header &lt; end) { if (nums[header] + nums[end] == val) { List&lt;Integer&gt; list = Arrays.asList(nums[i], nums[header], nums[end]); result.add(list); while (header &lt; end &amp;&amp; nums[end] == nums[end - 1]) end--; while (header &lt; end &amp;&amp; nums[header] == nums[header + 1]) header++; end--; header++; } else if (nums[header] + nums[end] &gt; val) { end--; } else { header++; } } } return result; } public static void main(String[] args) { int[] nums = {}; List&lt;List&lt;Integer&gt;&gt; lists = threeSum(nums); System.out.println(lists); }} #### 1234567891011121314151617181920212223242526272829303132333435# O(n * n)class Solution(object): def threeSum(self, nums): \"\"\" :type nums: List[int] :rtype: List[List[int]] \"\"\" res = [] nums.sort() # 排序 for i in xrange(0, len(nums) - 2): # 如果与前一个值相同，则跳过 # 避免重复计算 if i &gt; 0 and nums[i] == nums[i-1]: continue l, r = i + 1, len(nums) - 1 while l &lt; r: s = nums[i] + nums[l] + nums[r] if s &lt; 0: # 和过小，增大 nums[l] l += 1 elif s &gt; 0: # 值过大，减小 nums[r] r -= 1 else: # 存储目标结果 res.append((nums[i], nums[l], nums[r])) # 避免 l,r 重复计算 while l &lt; r and nums[l] == nums[l + 1]: l += 1 while l &lt; r and nums[r] == nums[r - 1]: r -= 1 # 下一组目标值 l += 1 r -= 1 return res","link":"/2019/08/26/leetcode-15-three-sum/"},{"title":"leetcode-155-min-stack","text":"DescriptionDesign a stack that supports push, pop, top, and retrieving the minimum element in constant time. push(x) – Push element x onto stack. pop() – Removes the element on top of the stack. top() – Get the top element. getMin() – Retrieve the minimum element in the stack. Example: 12345678MinStack minStack = new MinStack();minStack.push(-2);minStack.push(0);minStack.push(-3);minStack.getMin(); --&gt; Returns -3.minStack.pop();minStack.top(); --&gt; Returns 0.minStack.getMin(); --&gt; Returns -2. #### 123456789101112131415161718192021222324252627282930313233343536373839404142class MinStack { class MinNode{ int min, val; public MinNode(int min, int val){ this.min = min; this.val = val; } } Stack&lt;MinNode&gt; st; int min; public MinStack() { st = new Stack&lt;MinNode&gt;(); min = Integer.MAX_VALUE; } public void push(int x) { if(x &lt;= min) min = x; MinNode t = new MinNode(min, x); st.push(t); } public void pop() { if(!st.isEmpty()){ MinNode t = st.pop(); //need to reset the min to what it was before we saw this value if(!st.isEmpty()) min = st.peek().min; else min = Integer.MAX_VALUE; } } public int top() { if(st.isEmpty()) return -1; return st.peek().val; } public int getMin() { if(st.isEmpty()) return -1; return st.peek().min; }}","link":"/2018/09/01/leetcode-155-min-stack/"},{"title":"leetcode-20-valid-parentheses","text":"DescriptionGiven a string containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid. An input string is valid if: Open brackets must be closed by the same type of brackets. Open brackets must be closed in the correct order. Note that an empty string is also considered valid. Example 1: 12Input: &quot;()&quot;Output: true Example 2: 12Input: &quot;()[]{}&quot;Output: true Example 3: 12Input: &quot;(]&quot;Output: false Example 4: 12Input: &quot;([)]&quot;Output: false Example 5: 12Input: &quot;{[]}&quot;Output: true 思路題意是判斷括號匹配是否正確，很明顯，我們可以用棧來解決這個問題，當出現左括號的時候入棧，當遇到右括號時，判斷棧頂的左括號是否何其匹配即可，最終判斷是否空棧即可。 12345678910111213141516public boolean isValid(String s){ Stack&lt;Character&gt; stack = new Stack&lt;&gt;(); Map&lt;Character,Character&gt; map= new HashMap&lt;&gt;(); map.put(')','('); map.put(']','['); map.put('}','{'); for(char c : s.toCharArray() ){ if(stack.isEmpty()){ stack.push(c); }else if(stack.isEmpty() || map.get(c)!=stack.pop()){ return false; } } return stack.isEmpty(); }","link":"/2018/09/01/leetcode-20-valid-parentheses/"},{"title":"leetcode-206-reverse-linked-list","text":"DescriptionReverse a singly linked list. Example: 12Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULLOutput: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL Follow up: A linked list can be reversed either iteratively or recursively. Could you implement both? ####思路0 題意是將一個有序鏈錶反轉，首先使用迭代方法來遍歷列表。假設n是列表的長度，時間複雜度為$O(n)$ 123456789101112131415161718192021/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */class Solution { public ListNode reverseList(ListNode head) { ListNode prev = null; ListNode curr = head; while (curr != null) { ListNode nextTemp = curr.next; curr.next = prev; prev = curr; curr = nextTemp; } return prev; }} 思路1首先使用遞歸方法來遍歷列表。假設n是列表的長度，時間複雜度為$O(n) 1234567public ListNode reverseList(ListNode head) { if (head == null || head.next == null) return head; ListNode p = reverseList(head.next); head.next.next = head; head.next = null; return p;}","link":"/2018/09/01/leetcode-206-reverse-linked-list/"},{"title":"leetcode-2-add-two-numbers","text":"DescriptionYou are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Example: 123Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 0 -&gt; 8Explanation: 342 + 465 = 807. #### 1234567891011121314151617181920212223242526272829303132/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { * val = x; * next = null; * } * } */public class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { ListNode dummyHead = new ListNode(0); ListNode p = l1, q = l2, curr = dummyHead; int carry = 0; while (p != null || q != null) { int x = (p != null) ? p.val : 0; int y = (q != null) ? q.val : 0; int sum = carry + x + y; carry = sum / 10; curr.next = new ListNode(sum % 10); curr = curr.next; if (p != null) p = p.next; if (q != null) q = q.next; } if (carry &gt; 0) { curr.next = new ListNode(carry); } return dummyHead.next;}}","link":"/2018/09/02/leetcode-2-add-two-numbers/"},{"title":"leetcode-224-basic-calculator","text":"DescriptionImplement a basic calculator to evaluate a simple expression string. The expression string may contain open ( and closing parentheses ), the plus + or minus sign -, non-negative integers and empty spaces ``. Example 1: 12Input: &quot;1 + 1&quot;Output: 2 Example 2: 12Input: &quot; 2-1 + 2 &quot;Output: 3 Example 3: 12Input: &quot;(1+(4+5+2)-3)+(6+8)&quot;Output: 23 Note: #### 12345678910111213141516171819202122232425262728public int calculate(String s) { s = s.replaceAll(\"\\\\s+\", \"\"); int cal = 0, o = 1; char[] exp = s.toCharArray(); Deque&lt;Integer&gt; stack = new ArrayDeque&lt;&gt;(); for (int i = 0; i &lt; exp.length; i++){ switch(exp[i]){ case '(': stack.offerFirst(cal); stack.offerFirst(o); cal = 0; o = 1; break; case ')': cal = stack.poll() * cal + stack.poll(); break; case '+': case '-': o = exp[i] == '+' ? 1 : -1; break; default: int num = exp[i] - '0'; while(i + 1 &lt; exp.length &amp;&amp; Character.isDigit(exp[i + 1])) num = num * 10 + (exp[++i] - '0'); cal += o * num; } } return cal; }","link":"/2018/09/01/leetcode-224-basic-calculator/"},{"title":"leetcode-225-implement-stacks-using-queue","text":"Description Implement the following operations of a stack using queues. push(x) – Push element x onto stack. pop() – Removes the element on top of the stack. top() – Get the top element. empty() – Return whether the stack is empty. Example: 1234567MyStack stack = new MyStack();stack.push(1);stack.push(2); stack.top(); // returns 2stack.pop(); // returns 2stack.empty(); // returns false Notes: You must use only standard operations of a queue – which means only push to back, peek/pop from front, size, and is empty operations are valid. Depending on your language, queue may not be supported natively. You may simulate a queue by using a list or deque (double-ended queue), as long as you use only standard operations of a queue. You may assume that all operations are valid (for example, no pop or top operations will be called on an empty stack). 思路0題意可知是用隊列實現棧，那麼聲明一個個隊列。 123456789101112131415161718192021222324252627282930313233343536class MyQueue { Queue&lt;Integer&gt; queue; public MyStack() { this.queue=new LinkedList&lt;Integer&gt;(); } // Push element x onto stack. public void push(int x) { queue.add(x); for(int i=0;i&lt;queue.size()-1;i++) { queue.add(queue.poll()); } } // Removes the element on top of the stack. public void pop() { queue.poll(); } // Get the top element. public int top() { return queue.peek(); } // Return whether the stack is empty. public boolean empty() { return queue.isEmpty(); }}","link":"/2018/09/01/leetcode-225-implement-stacks-using-queue/"},{"title":"leetcode-21-merge-two-sorted-lists","text":"DescriptionMerge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists. Example: 12Input: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 思路題意是用一個新鏈表來合並兩個已排序的鏈表，那我們只需要從頭開始比較已排序的兩個鏈表，新鏈表指針每次指向值小的節點，依次比較下去，最後，當其中壹個鏈表到達了末尾，我們只需要把新鏈表指針指向另一個沒有到末尾的鏈表此時的指針即可。 123456789101112131415161718192021222324252627282930313233/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { * val = x; * next = null; * } * } */public class Solution { public ListNode mergeTwoLists(ListNode l1, ListNode l2) { ListNode head= new ListNode(0); ListNode p = head; while(l1!=null&amp;&amp;l2!=null){ if(l1.val&lt;=l2.val){ p.next=l1; l1=l1.next; }else{ p.next=l2; l2= l2.next; } p=p.next; } if(l1!=null){ p.next=l1; } if(l2!=null){ p.next=l2; } return head.next;}}","link":"/2018/09/01/leetcode-21-merge-two-sorted-lists/"},{"title":"leetcode-232-implement-queue-using-stacks","text":"Description Implement the following operations of a queue using stacks. push(x) – Push element x to the back of queue. pop() – Removes the element from in front of queue. peek() – Get the front element. empty() – Return whether the queue is empty. Example: 1234567MyQueue queue = new MyQueue();queue.push(1);queue.push(2); queue.peek(); // returns 1queue.pop(); // returns 1queue.empty(); // returns false Notes: You must use only standard operations of a stack – which means only push to top, peek/pop from top, size, and is emptyoperations are valid. Depending on your language, stack may not be supported natively. You may simulate a stack by using a list or deque (double-ended queue), as long as you use only standard operations of a stack. You may assume that all operations are valid (for example, no pop or peek operations will be called on an empty queue). 思路0題意可知是用棧實現隊列，那麼聲明兩個棧，一個是輸入棧一個是輸出棧。要輸入的數據放進到輸入棧中，而輸出棧把最後的進來的數據放進去出棧。 1234567891011121314151617181920212223242526272829class MyQueue { Stack&lt;Integer&gt; input = new Stack&lt;Integer&gt;(); Stack&lt;Integer&gt; output = new Stack&lt;Integer&gt;(); // Push element x to the back of queue. public void push(int x) { input.push(x); } // Removes the element from in front of queue. public void pop() { peek(); output.pop(); } // Get the front element. public int peek() { if(output.empty()){ while(!input.empty()){ output.push(input.pop()); } } return output.peek(); } // Return whether the queue is empty. public boolean empty() { return input.empty() &amp;&amp; output.empty(); }}","link":"/2018/09/01/leetcode-232-implement-queue-using-stacks/"},{"title":"leetcode-24-swap-nodes-in-pairs","text":"DescriptionGiven a linked list, swap every two adjacent nodes and return its head. Example: 1Given 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3. Note: Your algorithm should use only constant extra space. You may not modify the values in the list’s nodes, only nodes itself may be changed. ####思路0 題意是讓妳交換鏈表中相鄰的兩個節點，最終返回交換後鏈表的頭，限定妳空間復雜度為$ O(1)$。我們可以用遞歸來算出子集合的結果，遞歸的終點就是指針指到鏈表末少於兩個元素時，如果不是終點，那麽我們就對其兩節點進行交換，這裏我們需要一個臨時節點來作為交換橋梁，就不多說了。 1234567891011121314151617/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */class Solution { public ListNode swapPairs(ListNode head) { if (head == null || head.next == null) return head; ListNode node = head.next; head.next = swapPairs(node.next); node.next = head; return node; }} 思路1另一種實現方式就是用循環來實現了，兩兩交換節點，也需要一個臨時節點來作為交換橋梁，直到當前指針指到鏈表末少於兩個元素時停止 12345678910111213141516171819202122/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */class Solution { public ListNode swapPairs(ListNode head) { ListNode prev = new ListNode(0), curr = prev; prev.next = head; while (curr.next != null &amp;&amp; curr.next.next != null) { ListNode nextTemp = curr.next.next; cur.next.next = nextTemp.next; nextTemp.next = curr.next; curr.next = temp; cur = curr.next.next; } return prev.next; }}","link":"/2018/09/01/leetcode-24-swap-nodes-in-pairs/"},{"title":"leetcode-25-reverse-nodes-in-k-group","text":"DescriptionGiven a linked list, reverse the nodes of a linked list kat a time and return its modified list. k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is. Example: Given this linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5 For k = 2, you should return: 2-&gt;1-&gt;4-&gt;3-&gt;5 For k = 3, you should return: 3-&gt;2-&gt;1-&gt;4-&gt;5 Note: Only constant extra memory is allowed. You may not alter the values in the list’s nodes, only nodes itself may be changed. 思路0題意可知，要就是做length/k次單鏈表反轉 123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */class Solution { public ListNode reverseKGroup(ListNode head, int k) { ListNode dummy = new ListNode(0); dummy.next = head; ListNode pre = dummy; ListNode end = dummy; while (end.next != null) { for (int i = 0; i &lt; k &amp;&amp; end != null; i++) end = end.next; if (end == null) break; ListNode start = pre.next; ListNode next = end.next; end.next = null; pre.next = reverse(start); start.next = next; pre = start; end = pre; } return dummy.next; } private ListNode reverse(ListNode head) { ListNode pre = null; ListNode curr = head; while (curr != null) { ListNode next = curr.next; curr.next = pre; pre = curr; curr = next; } return pre; }}","link":"/2018/09/01/leetcode-25-reverse-nodes-in-k-group/"},{"title":"leetcode-26-remove-duplicates-from-sorted-array","text":"DescriptionGiven a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory. Example 1: 12345Given nums = [1,1,2],Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively.It doesn&apos;t matter what you leave beyond the returned length. Example 2: 12345Given nums = [0,0,1,1,1,2,2,3,3,4],Your function should return length = 5, with the first five elements of nums being modified to 0, 1, 2, 3, and 4 respectively.It doesn&apos;t matter what values are set beyond the returned length. Clarification: Confused why the returned value is an integer but your answer is an array? Note that the input array is passed in by reference, which means modification to the input array will be known to the caller as well. Internally you can think of this: 12345678// nums is passed in by reference. (i.e., without making a copy)int len = removeDuplicates(nums);// any modification to nums in your function would be known by the caller.// using the length returned by your function, it prints the first len elements.for (int i = 0; i &lt; len; i++) { print(nums[i]);} 思路題意是讓妳從一個有序的數組中移除重復的元素，並返回之後數組的長度。我的思路是判斷長度小於等於 1 的話直接返回原長度即可，否則的話遍歷一遍數組，用一個 tail 變量指向尾部，如果後面的元素和前面的元素不同，就讓 tail 變量加一，最後返回 tail 即可。 12345678910111213class Solution { public int removeDuplicates(int[] nums) { int len = nums.length; if (len &lt;= 1) return len; int tail = 1; for (int i = 1; i &lt; len; ++i) { if (nums[i - 1] != nums[i]) { nums[tail++] = nums[i]; } } return tail; }}","link":"/2019/09/01/leetcode-26-remove-duplicates-from-sorted-array/"},{"title":"leetcode-3-longest-substring-without-repeating-characters","text":"DescriptionGiven a string, find the length of the longest substring without repeating characters. Example 1: 123Input: &quot;abcabcbb&quot;Output: 3 Explanation: The answer is &quot;abc&quot;, with the length of 3. Example 2: 123Input: &quot;bbbbb&quot;Output: 1Explanation: The answer is &quot;b&quot;, with the length of 1. Example 3: 1234Input: &quot;pwwkew&quot;Output: 3Explanation: The answer is &quot;wke&quot;, with the length of 3. Note that the answer must be a substring, &quot;pwke&quot; is a subsequence and not a substring. #### 12345678910111213141516171819import java.util.HashMap;public class Solution { public int lengthOfLongestSubstring(String s) { if(s == null || s.length() == 0) return 0; //新建一个map进行存储char HashMap&lt;Character,Integer&gt; map = new HashMap&lt;Character,Integer&gt;(); int leftBound = 0; int max = 0; for(int i=0; i&lt;s.length();i++){ char c = s.charAt(i); //窗口左边可能为下一个char，或者不变 leftBound = Math.max(leftBound,(map.containsKey(c))? map.get(c)+1:0); max = Math.max(max, i-leftBound+1);//当前窗口长度 map.put(c,i); } return max; }}","link":"/2018/09/04/leetcode-3-longest-substring-without-repeating-characters/"},{"title":"leetcode-27-remove-element","text":"DescriptionGiven an array nums and a value val, remove all instances of that value in-place and return the new length. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory. The order of elements can be changed. It doesn’t matter what you leave beyond the new length. Example 1: 12345Given nums = [3,2,2,3], val = 3,Your function should return length = 2, with the first two elements of nums being 2.It doesn&apos;t matter what you leave beyond the returned length. Example 2: 1234567Given nums = [0,1,2,2,3,0,4,2], val = 2,Your function should return length = 5, with the first five elements of nums containing 0, 1, 3, 0, and 4.Note that the order of those five elements can be arbitrary.It doesn&apos;t matter what values are set beyond the returned length. Clarification: Confused why the returned value is an integer but your answer is an array? Note that the input array is passed in by reference, which means modification to the input array will be known to the caller as well. Internally you can think of this: 12345678// nums is passed in by reference. (i.e., without making a copy)int len = removeElement(nums, val);// any modification to nums in your function would be known by the caller.// using the length returned by your function, it prints the first len elements.for (int i = 0; i &lt; len; i++) { print(nums[i]);} 思路題意是移除數組中值等於 val 的元素，並返回之後數組的長度，並且題目中指定空間復雜度為 O(1)，我的思路是用 tail 標記尾部，遍歷該數組時當索引元素不等於 val 時，tail 加壹，尾部指向當前元素，最後返回 tail 即可。 123456789101112class Solution { public int removeElement(int[] nums, int val) { int len = nums.length; int tail = 1; for (int i = 1; i &lt; len; ++i) { if (nums[1] != val) { nums[tail++] = nums[i]; } } return tail; }}","link":"/2019/09/01/leetcode-27-remove-element/"},{"title":"leetcode-28-implement-strstr","text":"DescriptionImplement strStr(). Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack. Example 1: 12Input: haystack = &quot;hello&quot;, needle = &quot;ll&quot;Output: 2 Example 2: 12Input: haystack = &quot;aaaaa&quot;, needle = &quot;bba&quot;Output: -1 Clarification: What should we return when needle is an empty string? This is a great question to ask during an interview. For the purpose of this problem, we will return 0 when needle is an empty string. This is consistent to C’s strstr() and Java’s indexOf()). 思路題意是從主串中找到子串的索引，如果找不到則返回-1，當子串長度大於主串，直接返回-1，然後我們只需要遍歷比較即可。 12345678910111213class Solution { public int strStr(String haystack, String needle) { int l1 = haystack.length(), l2 = needle.length(); if (l1 &lt; l2) return -1; for (int i = 0; ; i++) { if (i + l2 &gt; l1) return -1; for (int j = 0; ; j++) { if (j == l2) return i; if (haystack.charAt(i + j) != needle.charAt(j)) break; } } }}","link":"/2019/09/01/leetcode-28-implement-strstr/"},{"title":"leetcode-35-search-insert-position","text":"DescriptionGiven a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order. You may assume no duplicates in the array. Example 1: 12Input: [1,3,5,6], 5Output: 2 Example 2: 12Input: [1,3,5,6], 2Output: 1 Example 3: 12Input: [1,3,5,6], 7Output: 4 Example 1: 12Input: [1,3,5,6], 0Output: 0 思路題意是讓妳從壹個沒有重復元素的已排序數組中找到插入位置的索引。因為數組已排序，所以我們可以想到二分查找法，因為查找到的條件是找到第壹個等於或者大於 target 的元素的位置，所以二分法略作變動即可。 1234567891011class Solution { public int searchInsert(int[] nums, int target) { int left = 0, right = nums.length - 1, mid = (right + left) &gt;&gt; 1; while (left &lt;= right) { if (target &lt;= nums[mid]) right = mid - 1; else left = mid + 1; mid = (right + left) &gt;&gt; 1; } return left; }}","link":"/2019/09/01/leetcode-35-search-insert-position/"},{"title":"leetcode-682-baseball-game","text":"DescriptionYou’re now a baseball game point recorder. Given a list of strings, each string can be one of the 4 following types: Integer (one round’s score): Directly represents the number of points you get in this round. &quot;+&quot; (one round’s score): Represents that the points you get in this round are the sum of the last two valid round’s points. &quot;D&quot; (one round’s score): Represents that the points you get in this round are the doubled data of the last valid round’s points. &quot;C&quot; (an operation, which isn’t a round’s score): Represents the last valid round’s points you get were invalid and should be removed. Each round’s operation is permanent and could have an impact on the round before and the round after. You need to return the sum of the points you could get in all the rounds. Example 1: 12345678Input: [&quot;5&quot;,&quot;2&quot;,&quot;C&quot;,&quot;D&quot;,&quot;+&quot;]Output: 30Explanation: Round 1: You could get 5 points. The sum is: 5.Round 2: You could get 2 points. The sum is: 7.Operation 1: The round 2&apos;s data was invalid. The sum is: 5. Round 3: You could get 10 points (the round 2&apos;s data has been removed). The sum is: 15.Round 4: You could get 5 + 10 = 15 points. The sum is: 30. Example 2: 1234567891011Input: [&quot;5&quot;,&quot;-2&quot;,&quot;4&quot;,&quot;C&quot;,&quot;D&quot;,&quot;9&quot;,&quot;+&quot;,&quot;+&quot;]Output: 27Explanation: Round 1: You could get 5 points. The sum is: 5.Round 2: You could get -2 points. The sum is: 3.Round 3: You could get 4 points. The sum is: 7.Operation 1: The round 3&apos;s data is invalid. The sum is: 3. Round 4: You could get -4 points (the round 3&apos;s data has been removed). The sum is: -1.Round 5: You could get 9 points. The sum is: 8.Round 6: You could get -4 + 9 = 5 points. The sum is 13.Round 7: You could get 9 + 5 = 14 points. The sum is 27. Note: The size of the input list will be between 1 and 1000. Every integer represented in the list will be between -30000 and 30000. #### 12345678910111213141516171819class Solution { public int calPoints(String[] ops) { List&lt;Integer&gt; s = new ArrayList&lt;Integer&gt;(); for (String op : ops) { int n = s.size(); if (op.equals(\"+\")) s.add(s.get(n - 1) + s.get(n - 2)); else if (op.equals(\"C\")) s.remove(n - 1); else if (op.equals(\"D\")) s.add(s.get(n - 1) * 2); else s.add(Integer.parseInt(op)); } return s.stream().reduce(0, Integer::sum); }}","link":"/2018/09/01/leetcode-682-baseball-game/"},{"title":"leetcode-4-median-of-two-sorted-arrays","text":"DescriptionThere are two sorted arrays nums1 and nums2 of size m and n respectively. Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)). You may assume nums1 and nums2 cannot be both empty. Example 1: 1234nums1 = [1, 3]nums2 = [2]The median is 2.0 Example 2: 1234nums1 = [1, 2]nums2 = [3, 4]The median is (2 + 3)/2 = 2.5 #### 123456789101112131415161718192021222324252627public double findMedianSortedArrays(int[] A, int[] B) { int m = A.length, n = B.length; // 不论总数是奇数还是偶数，以l和r为下标的两数的均值都是medium int l = (m + n + 1) / 2; int r = (m + n + 2) / 2; return (getkth(A, 0, B, 0, l) + getkth(A, 0, B, 0, r)) / 2.0; } private int getkth(int[] A, int aStart, int[] B, int bStart, int k) { if (aStart &gt;= A.length) return B[bStart + k - 1]; if (bStart &gt;= B.length) return A[aStart + k - 1]; if (k == 1) return Math.min(A[aStart], B[bStart]); int aMin = Integer.MAX_VALUE, bMin = Integer.MAX_VALUE; if (aStart + k / 2 - 1 &lt; A.length) aMin = A[aStart + k / 2 - 1]; if (bStart + k / 2 - 1 &lt; B.length) bMin = B[bStart + k / 2 - 1]; if (aMin &lt; bMin) return getkth(A, aStart + k / 2, B, bStart, k - k / 2); else return getkth(A, aStart, B, bStart + k / 2, k - k / 2); }","link":"/2018/09/03/leetcode-4-median-of-two-sorted-arrays/"},{"title":"leetcode-496-next-greater-element-i","text":"Description You are given two arrays (without duplicates)nums1 and nums2 where nums1’s elements are subset of nums2. Find all the next greater numbers for nums1‘s elements in the corresponding places of nums2. The Next Greater Number of a number x in nums1 is the first greater number to its right in nums2. If it does not exist, output -1 for this number. Example 1: 123456Input: nums1 = [4,1,2], nums2 = [1,3,4,2].Output: [-1,3,-1]Explanation: For number 4 in the first array, you cannot find the next greater number for it in the second array, so output -1. For number 1 in the first array, the next greater number for it in the second array is 3. For number 2 in the first array, there is no next greater number for it in the second array, so output -1. **Example 2:** 12345Input: nums1 = [2,4], nums2 = [1,2,3,4].Output: [3,-1]Explanation: For number 2 in the first array, the next greater number for it in the second array is 3. For number 4 in the first array, there is no next greater number for it in the second array, so output -1. **Note:** 1. All elements in `nums1` and `nums2` are unique. 2. The length of both `nums1` and `nums2` would not exceed 1000. #### 12345678910111213141516171819202122232425class Solution{ public int[] nextGreaterElement(int[] nums1, int[] nums2) { for(int i = 0; i &lt; nums1.length; i++) { boolean find = false; boolean change = false; for(int j = 0; j &lt; nums2.length; j++) { if(find &amp;&amp; nums2[j] &gt; nums1[i]) { nums1[i] = nums2[j]; change = true; break; } if(nums2[j] == nums1[i]) find = true; } if(!change) nums1[i] = -1; } return nums1; }}","link":"/2018/09/01/leetcode-496-next-greater-element-i/"},{"title":"leetcode-844-backspace-string-compare","text":"DescriptionGiven two strings S and T, return if they are equal when both are typed into empty text editors. #means a backspace character. Example 1: 123Input: S = &quot;ab#c&quot;, T = &quot;ad#c&quot;Output: trueExplanation: Both S and T become &quot;ac&quot;. Example 2: 123Input: S = &quot;ab##&quot;, T = &quot;c#d#&quot;Output: trueExplanation: Both S and T become &quot;&quot;. Example 3: 123Input: S = &quot;a##c&quot;, T = &quot;#a#c&quot;Output: trueExplanation: Both S and T become &quot;c&quot;. Example 4: 123Input: S = &quot;a#c&quot;, T = &quot;b&quot;Output: falseExplanation: S becomes &quot;c&quot; while T becomes &quot;b&quot;. Note: 1 &lt;= S.length &lt;= 200 1 &lt;= T.length &lt;= 200 S and T only contain lowercase letters and '#' characters. Follow up: Can you solve it in O(N) time and O(1)space? #### 1234567891011121314151617181920212223242526class Solution {public: bool backspaceCompare(string S, string T) { vector&lt;char&gt; s1, t1; for(int i = 0;i&lt;S.size();i++) { if(S[i] == '#' &amp;&amp; !s1.empty()) s1.pop_back(); else if(S[i] == '#' &amp;&amp; s1.empty()) continue; else s1.push_back(S[i]); } for(int i = 0;i&lt;T.size();i++) { if(T[i] == '#' &amp;&amp; !t1.empty()) t1.pop_back(); else if(T[i] == '#' &amp;&amp; t1.empty()) continue; else t1.push_back(T[i]); } return s1 == t1; }};","link":"/2018/09/01/leetcode-844-backspace-string-compare/"},{"title":"leetcode-1-two-sum","text":"DescriptionGiven a 32-bit signed integer, reverse digits of an integer. Example 1: 12Input: 123Output: 321 Example 2: 12Input: -123Output: -321 Example 3: 12Input: 120Output: 21 Note: Assume we are dealing with an environment which could only hold integers within the 32-bit signed integer range. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows. 思路題意是給妳一個整型數，求它的逆序整型數，而且有個小坑點，當它的逆序整型數溢出的話，那麽就返回 0，用我們代碼表示的話可以求得結果保存在 long 中，最後把結果和整型的兩個範圍比較即可。 12345678class Solution { public int reverse(int x) { long res = 0; for (; x != 0; x /= 10) res = res * 10 + x % 10; return res &gt; Integer.MAX_VALUE || res &lt; Integer.MIN_VALUE ? 0 : (int) res; }}","link":"/2018/09/01/leetcode-7-reverse-integer/"},{"title":"leetcode-876-middle-of-the-linked-list","text":"DescriptionGiven a non-empty, singly linked list with head node head, return a middle node of linked list. If there are two middle nodes, return the second middle node. Example 1: 12345Input: [1,2,3,4,5]Output: Node 3 from this list (Serialization: [3,4,5])The returned node has value 3. (The judge&apos;s serialization of this node is [3,4,5]).Note that we returned a ListNode object ans, such that:ans.val = 3, ans.next.val = 4, ans.next.next.val = 5, and ans.next.next.next = NULL. Example 2: 123Input: [1,2,3,4,5,6]Output: Node 4 from this list (Serialization: [4,5,6])Since the list has two middle nodes with values 3 and 4, we return the second one. Note: The number of nodes in the given list will be between 1 and 100. #### 12345678910class Solution { public ListNode middleNode(ListNode head) { ListNode slow = head, fast = head; while (fast != null &amp;&amp; fast.next != null) { slow = slow.next; fast = fast.next.next; } return slow; }}","link":"/2018/09/01/leetcode-876-middle-of-the-linked-list/"},{"title":"练习10-1 使用递归函数计算1到n之和（10 分）","text":"练习10-1 使用递归函数计算1到n之和（10 分）本题要求实现一个用递归计算$1+2+3+\\ldots+n$的和的简单函数。 函数接口定义：1int sum( int n ); 该函数对于传入的正整数n返回1+2+3+…+n的和；若n不是正整数则返回0。题目保证输入输出在长整型范围内。建议尝试写成递归函数。 裁判测试程序样例：123456789101112131415#include &lt;stdio.h&gt;int sum( int n );int main(){ int n; scanf(&quot;%d&quot;, &amp;n); printf (&quot;%d\\n&quot;, sum(n)); return 0;}/* 你的代码将被嵌在这里 */ 输入样例1：110 输出样例1：155 输入样例2：10 输出样例2：10 12345678910111213141516171819202122#include &lt;stdio.h&gt;int sum( int n );int main(){ int n; scanf(\"%d\", &amp;n); printf (\"%d\\n\", sum(n)); return 0;} int sum( int n ){ int s; if ( n == 0) s = 0; else s = n + sum( n - 1); return s;}","link":"/2018/02/08/liensi10-1/"},{"title":"leetcode-92-reverse-linked-list-ii","text":"DescriptionReverse a linked list from position m to n. Do it in one-pass. Note: 1 ≤ m ≤ n ≤ length of list. Example: 12Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4Output: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL #### 1234567891011121314151617181920212223242526272829303132/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { * val = x; * next = null; * } * } */public class Solution { public ListNode reverseBetween(ListNode head, int m, int n) { if (m == n) return head; ListNode dummy = new ListNode(0); dummy.next = head; ListNode pNode = dummy; ListNode start = head; for (int i = 1; i &lt; m; i ++ ) { pNode = start; start = start.next; }for (int i = 0; i &lt; n - m; i ++ ) { ListNode temp = start.next; start.next = temp.next; temp.next = pNode.next; pNode.next = temp; } return dummy.next; }}","link":"/2018/09/01/leetcode-92-reverse-linked-list-ii/"},{"title":"练习2-1 Programming in C is fun!（5 分）","text":"练习2-1 Programming in C is fun!（5 分）本题要求编写程序，输出一个短句“Programming in C is fun!”。 输入格式:本题目没有输入。 输出格式:在一行中输出短句“Programming in C is fun!”。 123456#include&lt;stdio.h&gt;int main(void){ printf(\"Programming in C is fun!\\n\"); return 0;}","link":"/2018/01/14/liensi2-1/"},{"title":"练习2-11 计算分段函数[2]（10 分）","text":"练习2-11 计算分段函数[2]（10 分）本题目要求计算下列分段函数f(x)的值： $$f(x)=\\begin{cases}x^{0.5}, &amp; \\text{$x \\ge 0$时} \\\\\\(x+1)^2+2x+\\frac{1}{x}, &amp; \\text{$x \\lt 0$时} \\end{cases}$$注：可在头文件中包含math.h，并调用sqrt函数求平方根，调用pow函数求幂。 输入格式:输入在一行中给出实数x。 输出格式:在一行中按“f(x) = result”的格式输出，其中x与result都保留两位小数。 输入样例1:110 输出样例1:1f(10.00) = 3.16 输入样例2:1-0.5 输出样例2:1f(-0.50) = -2.75 12345678910111213#include&lt;stdio.h&gt;#include&lt;math.h&gt; int main(void){ double x,re; scanf(\"%lf\",&amp;x); if(x &gt;= 0){ re=pow( x , 0.5 ); }else{ re=pow ( x + 1,2) + 2 * x + 1.0 / x; } printf(\"f(%.2f) = %.2f\",x,re);}","link":"/2018/01/14/liensi2-11/"},{"title":"练习2-10 计算分段函数[1]（10 分）","text":"练习2-10 计算分段函数[1]（10 分）本题目要求计算下列分段函数f(x)的值： $$y=f(x)=\\begin{cases}\\frac{1}{x}, &amp; x \\neq 0 \\\\\\\\0, &amp; x = 0 \\end{cases}$$ 输入格式:输入在一行中给出实数x。 输出格式:在一行中按“f(x) = result”的格式输出，其中x与result都保留一位小数。 输入样例1:110 输出样例1:1f(10.0) = 0.1 输入样例2:10 输出样例2:1f(0.0) = 0.0 12345678910111213#include&lt;stdio.h&gt; int main(void) { float x,y; scanf(\"%f\",&amp;x); if(x != 0){ y=1/x; }else{ y=0; } printf(\"f(%.1f) = %.1f\",x,y); return 0; }","link":"/2018/01/14/liensi2-10/"},{"title":"练习2-12 输出华氏-摄氏温度转换表（15 分）","text":"练习2-12 输出华氏-摄氏温度转换表（15 分）输入2个正整数lower和upper（lower≤upper≤100），请输出一张取值范围为[lower，upper]、且每次增加2华氏度的华氏-摄氏温度转换表。 温度转换的计算公式：$C=5\\times(F−32)\\div9$，其中：C表示摄氏温度，F表示华氏温度。 输入格式:在一行中输入2个整数，分别表示lower和upper的值，中间用空格分开。 输出格式:第一行输出：”fahr celsius” 接着每行输出一个华氏温度fahr（整型）与一个摄氏温度celsius（占据6个字符宽度，靠右对齐，保留1位小数）。 若输入的范围不合法，则输出”Invalid.”。 输入样例1:132 35 输出样例1:123fahr celsius32 0.034 1.1 输入样例2:140 30 输出样例2:1Invalid. 123456789101112131415#include&lt;stdio.h&gt; int main(void) { int fahr,lower,upper; double celsius; scanf(\"%d%d\",&amp;lower,&amp;upper); if(lower&lt;=upper &amp;&amp; upper&lt;=100){ printf(\"fahr celsius\\n\"); for (fahr = lower;fahr&lt;= upper;fahr=fahr+2){ celsius = (5.0/9.0)*(fahr-32); printf(\"%d%6.1f\\n\" ,fahr,celsius); } }else printf(\"Invalid.\\n\"); return 0; }","link":"/2018/01/14/liensi2-12/"},{"title":"练习2-13 求N分之一序列前N项和（15 分）","text":"练习2-13 求N分之一序列前N项和（15 分）本题要求编写程序，计算序列 $1 + \\frac{1}{2} + \\frac{1}{3} + \\cdots$ 的前N项之和。 输入格式:输入在一行中给出一个正整数N。 输出格式:在一行中按照“sum = S”的格式输出部分和的值S，精确到小数点后6位。题目保证计算结果不超过双精度范围。 输入样例:16 输出样例:1sum = 2.450000 123456789101112#include&lt;stdio.h&gt; int main(void) { int N,i; double s=0,item; scanf(\"%d\",&amp;N); for(i=1;i&lt;=N;i++) { item=1.0/i; s=s+item; } printf(\"sum = %.6lf\",s); return 0; }","link":"/2018/01/16/liensi2-13/"},{"title":"练习2-18 生成3的乘方表（15 分）","text":"练习2-18 求组合数（15 分）本题要求编写程序，根据公式$C_n^m=\\frac{n!}{m!(n−m)!}$算出从n个不同元素中取出m个元素（m≤n）的组合数。 建议定义和调用函数fact(n)计算n!，其中n的类型是int，函数类型是double。 输入格式:输入在一行中给出两个正整数m和n（m≤n），以空格分隔。 输出格式:按照格式“result = 组合数计算结果”输出。题目保证结果在double类型范围内。 输入样例:12 7 输出样例:1result = 21 1234567891011121314151617181920212223#include&lt;stdio.h&gt;double fact(int n); int main(void){ double result; int m,n,d; double x,y,z,a; scanf(\"%d %d\",&amp;m,&amp;n); d=n-m; x=fact(m); y=fact(n); z=fact(d); result = y/x/z; printf(\"result = %.f\",result); return 0; } double fact (int n){ int i; double a; a=1; for(i=1;i&lt;=n;i++){ a=a*i; } return a;}","link":"/2018/01/16/liensi2-18/"},{"title":"练习2-3 输出倒三角图案（5 分）","text":"练习2-3 输出倒三角图案（5 分）本题要求编写程序，输出指定的由“*”组成的倒三角图案。 输入格式:本题目没有输入。 输出格式:按照下列格式输出由“*”组成的倒三角图案。 1234* * * * * * * * * * 123456789#include&lt;stdio.h&gt; int main(void) { printf(\"* * * *\\n\"); printf(\" * * *\\n\"); printf(\" * *\\n\"); printf(\" *\\n\"); return 0; }","link":"/2018/01/14/liensi2-3/"},{"title":"练习2-4 温度转换（5 分）","text":"练习2-4 温度转换（5 分）本题要求编写程序，计算华氏温度150°F对应的摄氏温度。计算公式：$C=5\\times(F−32)\\div9$，式中：C表示摄氏温度，F表示华氏温度，输出数据要求为整型。 输入格式:本题目没有输入。 输出格式:按照下列格式输出 1fahr = 150, celsius = 计算所得摄氏温度的整数值 123456789#include&lt;stdio.h&gt; int main(void) { int celsius, fahr; fahr=150; celsius=5 * ( fahr - 32 ) / 9; printf(\"fahr = 150, celsius = %d\\n\", celsius); return 0; }","link":"/2018/01/14/liensi2-4/"},{"title":"练习2-6 计算物体自由下落的距离（5 分）","text":"练习2-6 计算物体自由下落的距离（5 分）一个物体从100米的高空自由落下。编写程序，求它在前3秒内下落的垂直距离。设重力加速度为10米/$秒^2$。 输入格式:本题目没有输入。 输出格式:按照下列格式输出 1height = 垂直距离值 结果保留2位小数。 1234567891011#include &lt;stdio.h&gt;#include &lt;math.h&gt;int main(void){ int g = 10, t = 3; double height; height = g * pow( t, 2 ) / 2; printf( \"height = %.2f\\n\", height ); return 0;}","link":"/2018/01/14/liensi2-6/"},{"title":"练习2-8 计算摄氏温度（10 分）","text":"练习2-8 计算摄氏温度（10 分）给定一个华氏温度F，本题要求编写程序，计算对应的摄氏温度C。计算公式：$C=5\\times(F−32)\\div9$。题目保证输入与输出均在整型范围内。 输入格式:输入在一行中给出一个华氏温度。 输出格式:在一行中按照格式“Celsius = C”输出对应的摄氏温度C的整数值。 输入样例:1150 输出样例:1Celsius = 65 12345678910#include&lt;stdio.h&gt; int main(void) { int celsius, fahr; while ( scanf( \"%d\", &amp;fahr ) != EOF ) { celsius = 5 *( fahr - 32 )/ 9; printf(\"Celsius = %d\\n\", celsius); } return 0;}","link":"/2018/01/14/liensi2-8/"},{"title":"练习2-17 生成3的乘方表（15 分）","text":"练习2-17 生成3的乘方表（15 分）输入一个非负整数$n$，生成一张3的乘方表，输出$3^{0} \\sim 3^{n}$的值。可调用幂函数计算3的乘方。 输入格式:输入在一行中给出一个非负整数$n$。 输出格式:按照幂的递增顺序输出$n+1$行，每行格式为“pow(3,i) = 3的i次幂的值”。题目保证输出数据不超过长整型整数的范围。 输入样例:13 输出样例:1234pow(3,0) = 1pow(3,1) = 3pow(3,2) = 9pow(3,3) = 27 12345678910111213#include&lt;stdio.h&gt; #include&lt;math.h&gt; int main(void) { int n,i; double a; scanf(\"%d\",&amp;n); for(i=0;i&lt;=n;i++){ a=pow(3,i); printf(\"pow(3,%d) = %.0f\\n\",i,a); } return 0; }","link":"/2018/01/16/liensi2-17/"},{"title":"练习2-14 求奇数分之一序列前N项和（15 分）","text":"练习2-14 求奇数分之一序列前N项和（15 分）本题要求编写程序，计算序列 $1 + \\frac{1}{3} + \\frac{1}{5} + \\cdots$的前N项之和。 输入格式:输入在一行中给出一个正整数N。 输出格式:在一行中按照“sum = S”的格式输出部分和的值S，精确到小数点后6位。题目保证计算结果不超过双精度范围。 输入样例:123 输出样例:1sum = 2.549541 1234567891011#include&lt;stdio.h&gt; int main(void) { int N,i; double s=0,item; scanf(\"%d\",&amp;N); for(i=1;i&lt;=N;i++) { item=1.0/(2*i-1); s=s+item; } printf(\"sum = %.6lf\",s); return 0; }","link":"/2018/01/16/liensi2-14/"},{"title":"练习2-15 求简单交错序列前N项和（15 分）","text":"练习2-15 求简单交错序列前N项和（15 分）本题要求编写程序,计算序列 $1 - \\frac{1}{4} + \\frac{1}{7} - \\frac{1}{10} + \\cdots $的前N项之和。 输入格式:输入在一行中给出一个正整数N。 输出格式:在一行中按照“sum = S”的格式输出部分和的值S，精确到小数点后三位。题目保证计算结果不超过双精度范围。 输入样例:110 输出样例:1sum = 0.819 1234567891011121314#include&lt;stdio.h&gt; int main(void) {int N,i,flag=1,fm=1; double s=0,item; scanf(\"%d\",&amp;N); for(i=1;i&lt;=N;i++) { item=flag*1.0/fm; s=s+item; flag=-flag; fm=fm+3; } printf(\"sum = %.3lf\",s); return 0; }","link":"/2018/01/16/liensi2-15/"},{"title":"练习2-9 整数四则运算（10 分）","text":"练习2-9 整数四则运算（10 分）本题要求编写程序，计算2个正整数的和、差、积、商并输出。题目保证输入和输出全部在整型范围内。 输入格式:输入在一行中给出2个正整数A和B。 输出格式:在4行中按照格式“A 运算符 B = 结果”顺序输出和、差、积、商。 输入样例:13 2 输出样例:12343 + 2 = 53 - 2 = 13 * 2 = 63 / 2 = 1 123456789101112131415#include &lt;stdio.h&gt;int main(void){ int a, b; while ( scanf( \"%d %d\", &amp;a, &amp;b ) != EOF ) { printf( \"%d + %d = %d\\n\", a, b, a + b ); printf( \"%d - %d = %d\\n\", a, b, a - b ); printf( \"%d * %d = %d\\n\", a, b, a * b ); printf( \"%d / %d = %d\\n\", a, b, a / b ); } return 0;}","link":"/2018/01/14/liensi2-9/"},{"title":"练习3-3 统计学生平均成绩与及格人数（15 分）","text":"练习3-3 统计学生平均成绩与及格人数（15 分）本题要求编写程序，计算学生们的平均成绩，并统计及格（成绩不低于60分）的人数。题目保证输入与输出均在整型范围内。 输入格式:输入在第一行中给出非负整数N，即学生人数。第二行给出N个非负整数，即这N位学生的成绩，其间以空格分隔。 输出格式:按照以下格式输出： 12average = 成绩均值count = 及格人数 其中平均值精确到小数点后一位。 输入样例:12577 54 92 73 60 输出样例:12average = 71.2count = 4 1234567891011121314151617#include &lt;stdio.h&gt; int main() { int n,x=0,i; double a[10001],sum=0; scanf(\"%d\",&amp;n); for(i=0;i&lt;n;i++) { scanf(\"%lf\",&amp;a[i]); if(a[i]&gt;=60) x++; sum+=a[i]; } if(n==0) printf(\"average = 0.0\\n\"); else printf(\"average = %.1f\\n\",sum/n); printf(\"count = %d\\n\",x); return 0; }","link":"/2018/01/21/liensi3-3/"},{"title":"练习3-2 计算符号函数的值（10 分）","text":"练习3-2 计算符号函数的值（10 分）对于任一整数n，符号函数sign(n)的定义如下： $$\\operatorname{sign}(n)=\\left{\\begin{array}{ll}{-1,} &amp; {(n0)}\\end{array}\\right.$$ 请编写程序计算该函数对任一输入整数的值。 输入格式:输入在一行中给出整数n。 输出格式:在一行中按照格式“sign(n) = 函数值”输出该整数n对应的函数值。 输入样例1:110 输出样例1:1sign(10) = 1 输入样例2:10 输出样例2:1sign(0) = 0 输入样例3:1-98 输出样例3:1sign(-98) = -1 12345678910111213#include&lt;stdio.h&gt; int main(void){ int n,p; scanf(\"%d\",&amp;n); if(n&lt;0) p=-1; else if(n==0) p=0; else if(n&gt;0) p=1; printf(\"sign(%d) = %d\",n,p); return 0; }","link":"/2018/01/21/liensi3-2/"},{"title":"练习3-7 成绩转换（15 分）","text":"练习3-7 成绩转换（15 分）本题要求编写程序将一个百分制成绩转换为五分制成绩。转换规则： 大于等于90分为A； 小于90且大于等于80为B； 小于80且大于等于70为C； 小于70且大于等于60为D； 小于60为E。 输入格式:输入在一行中给出一个整数的百分制成绩。 输出格式:在一行中输出对应的五分制成绩。 输入样例:190 输出样例:1A 1234567891011121314151617181920212223242526272829303132#include&lt;stdio.h&gt; int main() { int t,a;char x;//用个字符变量比较方便 scanf(\"%d\",&amp;t); while(t--) { scanf(\"%d\",&amp;a); if (a&gt;=90) { x='A'; } else if (a&gt;=80) { x='B'; } else if (a&gt;=70) { x='C'; } else if (a&gt;=60) { x='D'; } else { x='E'; } printf(\"%c\\n\",x); } return 0; }","link":"/2018/01/22/liensi3-7/"},{"title":"练习3-4 统计字符（15 分）","text":"练习3-4 统计字符（15 分）本题要求编写程序，输入10个字符，统计其中英文字母、空格或回车、数字字符和其他字符的个数。 输入格式:输入为10个字符。最后一个回车表示输入结束，不算在内。 输出格式:在一行内按照 1letter = 英文字母个数, blank = 空格或回车个数, digit = 数字字符个数, other = 其他字符个数 的格式输出。 输入样例:12aZ &amp;09 Az 输出样例:1letter = 4, blank = 3, digit = 2, other = 1 1234567891011121314151617#include&lt;stdio.h&gt;int main(void){ int i,letter,blank,digit,other; char ch; letter=blank=digit=other=0; for(i=1;i&lt;=10;i++){ scanf(\"%c\",&amp;ch); if(ch&gt;='A'&amp;&amp;ch&lt;='Z'||(ch&gt;='a'&amp;&amp;ch&lt;='z')) letter++; else if(ch==' '||ch=='\\n') blank++; else if(ch&gt;='0'&amp;&amp;ch&lt;='9') digit++; else other++; } printf(\"letter = %d, blank = %d, digit = %d, other = %d\",letter,blank,digit,other); return 0; }","link":"/2018/01/22/liensi3-4/"},{"title":"练习3-5 输出闰年（15 分）","text":"练习3-5 输出闰年（15 分）输出21世纪中截止某个年份以来的所有闰年年份。注意：闰年的判别条件是该年年份能被4整除但不能被100整除、或者能被400整除。 输入格式:输入在一行中给出21世纪的某个截止年份。 输出格式:逐行输出满足条件的所有闰年年份，即每个年份占一行。输入若非21世纪的年份则输出”Invalid year!”。若不存在任何闰年，则输出“None”。 输入样例1:12048 输出样例1:123456789101112200420082012201620202024202820322036204020442048 输入样例2:12000 输出样例2:1Invalid year! 1234567891011121314#include&lt;stdio.h&gt; int main(void) { int year, i; scanf(\"%d\", &amp;year); if(year &lt; 2001 || year &gt; 2100) /* 21世纪共100年，2001年为起始年 */ printf(\"Invalid year!\\n\"); else { for(i = 2001; i &lt;= year; ++i) { if((i % 4 == 0 &amp;&amp; i % 100 != 0) || (i % 400 == 0)) printf(\"%d\\n\", i); } } return 0; }","link":"/2018/01/22/liensi3-5/"},{"title":"练习4-10 找出最小值（20 分）","text":"练习4-10 找出最小值（20 分）本题要求编写程序，找出给定一系列整数中的最小值。 输入格式：输入在一行中首先给出一个正整数n，之后是n个整数，其间以空格分隔。 输出格式：在一行中按照“min = 最小值”的格式输出n个整数中的最小值。 输入样例：14 -2 -123 100 0 输出样例：1min = -123 12345678910111213#include &lt;stdio.h&gt; int main(void ) { int i,a,min,n; scanf(\"%d\",&amp;n); min=a; for(i=1;i&lt;=n;i++){ scanf(\"%d\",&amp;a); if(min&gt;a) min=a; } printf(\"min = %d\\n\",min); return 0; }","link":"/2018/01/22/liensi4-10/"},{"title":"练习4-11 统计素数并求和（20 分）","text":"练习4-11 统计素数并求和（20 分）本题要求统计给定整数M和N区间内素数的个数并对它们求和。 输入格式:输入在一行中给出两个正整数$M$和$N（1\\leq M\\leq N\\leq 500）$。 输出格式:在一行中顺序输出M和N区间内素数的个数以及它们的和，数字间以空格分隔。 输入样例:110 31 输出样例:17 143 123456789101112131415161718192021222324252627#include&lt;stdio.h&gt;int main() { int m,n; int i; int cnt=0; int sum=0; scanf(\"%d%d\",&amp;m,&amp;n); if(m==1) m=2; for(i=m;i&lt;=n;i++){ int isPrime=1; int k; for(k=2;k&lt;i-1;k++){ if(i%k==0){ isPrime=0; break; } } if(isPrime){ cnt++; sum+=i; } } printf(\"%d %d\\n\",cnt,sum); return 0; }","link":"/2018/01/22/liensi4-11/"},{"title":"练习3-8 查询水果价格（15 分）","text":"练习3-8 查询水果价格（15 分）给定四种水果，分别是苹果（apple）、梨（pear）、桔子（orange）、葡萄（grape），单价分别对应为3.00元/公斤、2.50元/公斤、4.10元/公斤、10.20元/公斤。 首先在屏幕上显示以下菜单： 12345[1] apple[2] pear[3] orange[4] grape[0] exit 用户可以输入编号1~4查询对应水果的单价。当连续查询次数超过5次时，程序应自动退出查询；不到5次而用户输入0即退出；输入其他编号，显示价格为0。 输入格式:输入在一行中给出用户连续输入的若干个编号。 输出格式:首先在屏幕上显示菜单。然后对应用户的每个输入，在一行中按格式“price = 价格”输出查询结果，其中价格保留两位小数。当用户连续查询次数超过5次、或主动输入0时，程序结束。 输入样例1:13 -1 0 2 输出样例1:1234567[1] apple[2] pear[3] orange[4] grape[0] exitprice = 4.10price = 0.00 输入样例2:11 2 3 3 4 4 5 6 7 8 输出样例2:12345678910[1] apple[2] pear[3] orange[4] grape[0] exitprice = 3.00price = 2.50price = 4.10price = 4.10price = 10.20 1234567891011121314151617181920212223#include&lt;stdio.h&gt; int main(void){ int n,i; double price; printf(\"[1] apple\\n\"); printf(\"[2] pear\\n\"); printf(\"[3] orange\\n\"); printf(\"[4] grape\\n\"); printf(\"[0] exit\\n\"); for(i=1;i&lt;=5;i++){ scanf(\"%d\",&amp;n); if(n==0) break; switch(n){ case 1:price=3.00;break; case 2:price=2.50;break; case 3:price=4.10;break; case 4:price=10.20;break; default:price=0.00;break; } printf(\"price = %.2f\\n\",price); } return 0; }","link":"/2018/01/22/liensi3-8/"},{"title":"练习4-3 求给定精度的简单交错序列部分和（15 分）","text":"练习4-3 求给定精度的简单交错序列部分和（15 分）本题要求编写程序，计算序列部分和$ 1 - \\frac{1}{4} + \\frac{1}{7} - \\frac{1}{10} + \\cdots $直到最后一项的绝对值不大于给定精度eps。 输入格式:输入在一行中给出一个正实数eps。 输出格式:在一行中按照“sum = S”的格式输出部分和的值S，精确到小数点后六位。题目保证计算结果不超过双精度范围。 输入样例1:14E-2 输出样例1:1sum = 0.854457 输入样例2:10.02 输出样例2:1sum = 0.826310 12345678910111213141516#include&lt;stdio.h&gt; #include&lt;math.h&gt; int main(void){ int fz=1,fm=1,flag=1; double eps,item,sum=0; scanf(\"%lf\",&amp;eps); item=eps+1; while(fabs(item)&gt;eps){ item=flag*1.0/fm; sum=sum+item; fm=fm+3; flag=-flag; } printf(\"sum = %.6f\",sum); return 0; }","link":"/2018/01/22/liensi4-3/"},{"title":"练习4-6 猜数字游戏（15 分）","text":"练习4-6 猜数字游戏（15 分）猜数字游戏是令游戏机随机产生一个100以内的正整数，用户输入一个数对其进行猜测，需要你编写程序自动对其与随机产生的被猜数进行比较，并提示大了（“Too big”），还是小了（“Too small”），相等表示猜到了。如果猜到，则结束程序。程序还要求统计猜的次数，如果1次猜出该数，提示“Bingo!”；如果3次以内猜到该数，则提示“Lucky You!”；如果超过3次但是在N（&gt;3）次以内（包括第N次）猜到该数，则提示“Good Guess!”；如果超过N次都没有猜到，则提示“Game Over”，并结束程序。如果在到达N次之前，用户输入了一个负数，也输出“Game Over”，并结束程序。 输入格式:输入第一行中给出两个不超过100的正整数，分别是游戏机产生的随机数、以及猜测的最大次数N。最后每行给出一个用户的输入，直到出现负数为止。 输出格式:在一行中输出每次猜测相应的结果，直到输出猜对的结果或“Game Over”则结束。 输入样例:123456758 47050565860-2 输出样例:1234Too bigToo smallToo smallGood Guess! 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;stdio.h&gt;int main() { int key, n; scanf(\"%d %d\",&amp;key,&amp;n); int i; int m; int flag = 0; for (i = 1;i &lt;= n;i ++) { scanf(\"%d\",&amp;m); if (m &lt; 0) break; if (m &gt; key) printf(\"Too big\\n\"); if (m &lt; key) printf(\"Too small\\n\"); if (m == key) { if (i == 1) { flag = 1; printf(\"Bingo!\\n\"); break; } if (i == 2 || i == 3) { flag = 1; printf(\"Lucky You!\\n\"); break; } if (i &gt; 3) { flag = 1; printf(\"Good Guess!\\n\"); break; } } } if (flag == 0) printf(\"Game Over\\n\"); return 0;}","link":"/2018/01/22/liensi4-6/"},{"title":"练习4-7 求e的近似值（15 分）","text":"练习4-7 求e的近似值（15 分）自然常数e可以用级数$1+\\frac{1}{1}!+\\frac{1}{2!}+\\cdots+\\frac{1}{n!}$来近似计算。本题要求对给定的非负整数$n$，求该级数的前$n$项和。 输入格式:输入第一行中给出非负整数$n（≤1000）$。 输出格式:在一行中输出部分和的值，保留小数点后八位。 输入样例:110 输出样例:12.71828180 12345678910111213141516171819202122#include&lt;stdio.h&gt; double fact(int n); int main(){ double count=1; int i; int n; scanf(\"%d\",&amp;n); for(i=1;i&lt;=n;i++) { count=count+1.0/fact(i); } printf(\"%.8f\\n\",count); return 0; } double fact(int n) { int i; double sum=1; for(i=1;i&lt;=n;i++) { sum=sum*i; } return sum; }","link":"/2018/01/22/liensi4-7/"},{"title":"练习5-1 求m到n之和（10 分）","text":"练习5-1 求m到n之和（10 分）本题要求实现一个计算$\\mathrm{m} \\sim \\mathrm{n}(m&lt;n)$之间所有整数的和的简单函数。 函数接口定义：1int sum( int m, int n ); 其中m和n是用户传入的参数，保证有m&lt;n。函数返回的是m~n之间所有整数的和。 裁判测试程序样例：123456789101112131415#include &lt;stdio.h&gt;int sum(int m, int n);int main(){ int m, n; scanf(\"%d %d\", &amp;m, &amp;n); printf(\"sum = %d\\n\", sum(m, n)); return 0;}/* 你的代码将被嵌在这里 */ 输入样例：1-5 8 输出样例：1sum = 21 123456789101112131415161718192021#include &lt;stdio.h&gt;int sum(int m, int n);int main(){ int m, n; scanf(\"%d %d\", &amp;m, &amp;n); printf(\"sum = %d\\n\", sum(m, n)); return 0;}int sum(int m, int n){ int sum=0,i; for(i=m;i&lt;=n;i++){ sum+=i; } return sum;}","link":"/2018/01/24/liensi5-1/"},{"title":"练习5-3 数字金字塔（15 分）","text":"练习5-3 数字金字塔（15 分）本题要求实现函数输出n行数字金字塔。 函数接口定义：1void pyramid( int n ); 其中n是用户传入的参数，为[1, 9]的正整数。要求函数按照如样例所示的格式打印出n行数字金字塔。注 意每个数字后面跟一个空格。 裁判测试程序样例：123456789101112131415#include &lt;stdio.h&gt;void pyramid( int n );int main(){ int n; scanf(\"%d\", &amp;n); pyramid(n); return 0;}/* 你的代码将被嵌在这里 */ 输入样例：15 输出样例：12345 1 2 2 3 3 3 4 4 4 4 5 5 5 5 5 12345678910111213141516171819202122232425#include &lt;stdio.h&gt;void pyramid( int n );int main(){ int n; scanf(\"%d\", &amp;n); pyramid(n); return 0;}void pyramid(int n){ int i, j; for (i=1; i&lt;=n; i++) { for (j=1; j&lt;=n-i; j++) printf(\" \"); for (j=1; j&lt;=i; j++) printf(\"%d \", i); putchar('\\n'); }}","link":"/2018/01/24/liensi5-3/"},{"title":"练习5-2 找两个数中最大者（10 分）","text":"练习5-2 找两个数中最大者（10 分）本题要求对两个整数a和b，输出其中较大的数。 函数接口定义：1int max( int a, int b ); 其中a和b是用户传入的参数，函数返回的是两者中较大的数。 裁判测试程序样例：123456789101112131415#include &lt;stdio.h&gt;int max( int a, int b );int main(){ int a, b; scanf(\"%d %d\", &amp;a, &amp;b); printf(\"max = %d\\n\", max(a, b)); return 0;}/* 你的代码将被嵌在这里 */ 输入样例：1-5 8 输出样例：1max = 8 123456789101112131415161718192021222324#include &lt;stdio.h&gt;int max( int a, int b );int main(){ int a, b; scanf(\"%d %d\", &amp;a, &amp;b); printf(\"max = %d\\n\", max(a, b)); return 0;}int max(int a, int b){ int result; if (a &gt;= b) result = a; else result = b; return result;}","link":"/2018/01/24/liensi5-2/"},{"title":"练习7-10 查找指定字符（15 分）","text":"练习7-10 查找指定字符（15 分）本题要求编写程序，从给定字符串中查找某指定的字符。 输入格式：输入的第一行是一个待查找的字符。第二行是一个以回车结束的非空字符串（不超过80个字符）。 输出格式：如果找到，在一行内按照格式“index = 下标”输出该字符在字符串中所对应的最大下标（下标从0开始）；否则输出”Not Found”。 输入样例1：mprogramming 输出样例1：index = 7 输入样例2：a1234输出样例2： Not Found 1234567891011121314#include&lt;stdio.h&gt;#include&lt;string.h&gt;char buf[80],search[80];int main(){ scanf(\"%s\",search); scanf(\"%s\",buf); char * pos = strstr(buf,search); if (pos==NULL) printf(\"Not Found\\n\"); else printf(\"index = %d\\n\",pos-buf+1); return 0;}","link":"/2018/01/24/liensi7-10/"},{"title":"练习7-11 字符串逆序（15 分）","text":"练习7-11 字符串逆序（15 分）输入一个字符串，对该字符串进行逆序，输出逆序后的字符串。 输入格式：输入在一行中给出一个不超过80个字符长度的、以回车结束的非空字符串。 输出格式：在一行中输出逆序后的字符串。 输入样例：Hello World! 输出样例：!dlroW olleH 12345678910111213141516171819#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main(){ char str[81]; int i = 0; int c; while((c=getchar()) != '\\n'){// 记录字符串 str[i] = (char) c; i++; } i--; for(;i&gt;=0;i--){ printf(\"%c\", str[i]); }}","link":"/2018/01/24/liensi7-11/"},{"title":"练习7-3 将数组中的数逆序存放（20 分）","text":"练习7-3 将数组中的数逆序存放（20 分）本题要求编写程序，将给定的n个整数存入数组中，将数组中的这$n$个数逆序存放，再按顺序输出数组中的元素。 输入格式:输入在第一行中给出一个正整数$n（1\\le n\\le 10）$。第二行输入$n$个整数，用空格分开。 输出格式:在一行中输出这$n$个整数的处理结果，相邻数字中间用一个空格分开，行末不得有多余空格。 输入样例:410 8 1 2 输出样例:2 1 8 10 123456789101112131415161718192021222324#include&lt;stdio.h&gt;int main(void){ int i,n,temp; int ri; int a[10]; scanf(\"%d\",&amp;n); for(i=0;i&lt;n;i++) scanf(\"%d\",&amp;a[i]); i=0; for(i=0;i&lt;n/2;i++) { temp=a[i]; a[i]=a[n-1-i]; a[n-1-i]=temp; } for(i=0;i&lt;n;i++) printf(\"%d \",a[i]); putchar('\\n'); }","link":"/2018/01/24/liensi7-3/"},{"title":"练习7-4 找出不是两个数组共有的元素（20 分）","text":"练习7-4 找出不是两个数组共有的元素（20 分）给定两个整型数组，本题要求找出不是两者共有的元素。 输入格式:S输入分别在两行中给出两个整型数组，每行先给出正整数$N（\\leq 20）$，随后是N个整数，其间以空格分隔。 输出格式:在一行中按照数字给出的顺序输出不是两数组共有的元素，数字间以空格分隔，但行末不得有多余的空格。题目保证至少存在一个这样的数字。同一数字不重复输出。 输入样例:10 3 -5 2 8 0 3 5 -15 9 10011 6 4 8 2 6 -5 9 0 100 8 1 输出样例:3 5 -15 6 4 1 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;stdio.h&gt;int main(void){ int n,m,a[20],b[20],c[40],i,j,d,k=0,f,e=0,flag1,flag2; scanf(\"%d\",&amp;n); for(i=0;i&lt;n;i++){ scanf(\"%d\",&amp;a[i]); } scanf(\"%d\",&amp;m); for(j=0;j&lt;m;j++){ scanf(\"%d\",&amp;b[j]); } for(i=0;i&lt;n;i++) for(j=0;j&lt;m;j++){ if(a[i]==b[j]){ c[k]=a[i];k++; } } if(k==0){ for(i=0;i&lt;n;i++){ if(e==0){printf(\"%d\",a[i]);e++;} else printf(\" %d\",a[i]); } for(j=0;j&lt;m;j++){ if(e==0){printf(\"%d\",b[j]);e++;} else printf(\" %d\",b[j]); } } for(i=0;i&lt;n;i++){ flag1=1; for(j=0;j&lt;k;j++){ if(a[i]!=c[j]) f=1; else{f=0;break;} } if(f){ for(d=0;d&lt;i;++d){ if(a[d]==a[i]) {flag1=0;break;} } if(flag1){ if(e==0){printf(\"%d\",a[i]);e++;} else printf(\" %d\",a[i]); } } } for(i=0;i&lt;m;i++){ for(j=0;j&lt;k;j++){ flag2=1; if(b[i]!=c[j]) f=1; else{f=0;break;} } if(f){ for(d=0;d&lt;i;++d){ if(b[d]==b[i]){flag2=0;break;} } if(flag2){ if(e==0){printf(\"%d\",b[i]);e++;} else printf(\" %d\",b[i]); } } } return 0;}","link":"/2018/01/24/liensi7-4/"},{"title":"练习7-2 求最大值及其下标（20 分）","text":"练习7-2 求最大值及其下标（20 分）本题要求编写程序，找出给定的n个数中的最大值及其对应的最小下标（下标从0开始）。 ## 输入格式: 输入在第一行中给出一个正整数$n（1\\lt n\\le10）$。第二行输入n个整数，用空格分开。 ## 输出格式: 在一行中输出最大值及最大值的最小下标，中间用一个空格分开。 ## 输入样例: 62 8 10 1 9 10 ## 输出样例: 10 2 12345678910111213141516171819#include &lt;stdio.h&gt; int main( ) { int i, index, n, temp; int a[10]; scanf(\"%d\", &amp;n); for(i = 0; i &lt; n; i++) scanf(\"%d\", &amp;a[i]); index=0; a[index]=a[0]; for(i=1;i&lt;n;i++){ if(a[index]&lt;a[i]){ a[index]=a[i]; index=i; } } printf(\"%d %d\\n\", a[index],index); }","link":"/2018/01/24/liensi7-2/"},{"title":"练习7-8 方阵循环右移（20 分）","text":"练习7-8 方阵循环右移（20 分）本题要求编写程序，将给定n×n方阵中的每个元素循环向右移m个位置，即将第$0,1, \\cdots, n-1$列变换为第$n-m, n-m+1, \\cdots, n-1,0,1, \\cdots, n-1-1$列。 输入格式：输入第一行给出两个正整数$m$和$n（1\\le n\\le 6）$。接下来一共n行，每行n个整数，表示一个n阶的方阵。 输出格式：按照输入格式输出移动后的方阵：即输出n行，每行n个整数，每个整数后输出一个空格。 输入样例：2 31 2 34 5 67 8 9 输出样例：2 3 15 6 48 9 7 1234567891011121314151617181920#include &lt;stdio.h&gt; int main() { int a[10][10]; int i,j,n,m; scanf(\"%d %d\",&amp;m,&amp;n); for(i=0;i&lt;n;i++) { for(j=0;j&lt;n;j++) { scanf(\"%d\",&amp;a[i][j]); m%=n; } } for(i=0;i&lt;n;i++) { for(j=0;j&lt;n;j++) { printf(\"%d \",a[i][(n-m+j)%n]); } printf(\"\\n\"); } return 0; }}","link":"/2018/01/24/liensi7-8/"},{"title":"练习7-9 计算天数（15 分）","text":"练习7-9 计算天数（15 分）本题要求编写程序计算某年某月某日是该年中的第几天。 输入格式:输入在一行中按照格式“yyyy/mm/dd”（即“年/月/日”）给出日期。注意：闰年的判别条件是该年年份能被4整除但不能被100整除、或者能被400整除。闰年的2月有29天。 输出格式:在一行输出日期是该年中的第几天。 输入样例1:2009/03/02 输出样例1:61 输入样例2:2000/03/02 输出样例2:62 12345678910111213141516171819#include&lt;stdio.h&gt;int main(int argc, const char * argv[]){ int year,month,day,i,num=0; int m[12]={31,28,31,30,31,30,31,31,30,31,30,31}; scanf(\"%d/%d/%d\",&amp;year,&amp;month,&amp;day); if(((year%4==0)&amp;&amp;(year%100!=0))||(year%400==0)) { if(month&gt;2) num=1; } for(i=0;i&lt;(month-1);i++) { num+=m[i]; } num=num+day; printf(\"%d\",num); return 0;}","link":"/2018/01/24/liensi7-9/"},{"title":"练习8-8 移动字母（10 分）","text":"练习8-8 移动字母（10 分）本题要求编写函数，将输入字符串的前3个字符移到最后。 函数接口定义：void Shift( char s[] );其中char s[]是用户传入的字符串，题目保证其长度不小于3；函数Shift须将按照要求变换后的字符串仍然存在s[]里。 裁判测试程序样例：123456789101112131415161718192021#include &lt;stdio.h&gt;#include &lt;string.h&gt;#define MAXS 10void Shift( char s[] );void GetString( char s[] ); /* 实现细节在此不表 */int main(){ char s[MAXS]; GetString(s); Shift(s); printf(\"%s\\n\", s); return 0; }/* 你的代码将被嵌在这里 */ 输入样例：abcdef 输出样例：defabc 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;stdio.h&gt;#include &lt;string.h&gt;#define MAXS 10void Shift( char s[] );void GetString( char s[] ); /* 实现细节在此不表 */int main(){ char s[MAXS]; GetString(s); Shift(s); printf(\"%s\\n\", s); return 0; }void GetString(char s[]){ gets(s);}void Shift(char s[]){ int i, count; char str[5]; for (i=0; i&lt;3; i++) str[i] = s[i]; for (i=0; s[i+3] != '\\0'; i++) s[i] = s[i+3]; count = i; for (i=0; i&lt;3;i++) { s[count] = str[i]; count++; }}","link":"/2018/01/24/liensi8-8/"},{"title":"练习7-7 矩阵运算（20 分）","text":"练习7-7 矩阵运算（20 分）给定一个n×n的方阵，本题要求计算该矩阵除副对角线、最后一列和最后一行以外的所有元素之和。副对角线为从矩阵的右上角至左下角的连线。 输入格式:输入第一行给出正整数$n（1\\lt n\\leq 10）$；随后n行，每行给出n个整数，其间以空格分隔。 输出格式:在一行中给出该矩阵除副对角线、最后一列和最后一行以外的所有元素之和。 输入样例:42 3 4 15 6 1 17 1 8 11 1 1 1 输出样例:35 123456789101112131415161718192021222324252627#include&lt;stdio.h&gt;int main(void){ int a[6][6]; int i,j,sum,n; printf(\"Input n: \"); scanf(\"%d\",&amp;n); printf(\"Input array: \\n\"); for(i=0;i&lt;n;i++){ //this for(j=0;j&lt;n;j++) //and this scanf(\"%d\",&amp;a[i][j]); } sum=0; for(i=0;i&lt;n;i++) for(j=0;j&lt;n;j++) { if((i+j!=(n-1))&amp;&amp;(i!=(n-1))&amp;&amp;(j!=(n-1))) sum=sum+a[i][j]; } printf(\"sum=%d\\n\",sum); return 0; }","link":"/2018/01/24/liensi7-7/"},{"title":"markdown","text":"MarkdownA markdown example shows how to write a markdown file. This document integrates core syntax and extensions (GMF). Block Elements Paragraphs and Line Breaks Headers Blockquotes Lists Code Blocks Horizontal Rules Table Span Elements Links Emphasis Code Images Strikethrough Miscellaneous Automatic Links Backslash Escapes Inline HTML Block ElementsParagraphs and Line BreaksParagraphsHTML Tag: &lt;p&gt; One or more blank lines. (A blank line is a line containing nothing but spaces or tabs is considered blank.) Code: This will be inline. This is second paragraph. Preview: This will beinline. This is second paragraph. Line BreaksHTML Tag: &lt;br /&gt; End a line with two or more spaces. Code: This will be not inline. Preview: This will be notinline. HeadersMarkdown supports two styles of headers, Setext and atx. SetextHTML Tags: &lt;h1&gt;, &lt;h2&gt; “Underlined” using equal signs (=) as &lt;h1&gt; and dashes (-) as &lt;h2&gt; in any number. Code: This is an H1 ============= This is an H2 ------------- Preview: This is an H1This is an H2 atxHTML Tags: &lt;h1&gt;, &lt;h2&gt;, &lt;h3&gt;, &lt;h4&gt;, &lt;h5&gt;, &lt;h6&gt; Uses 1-6 hash characters (#) at the start of the line, corresponding to &lt;h1&gt; - &lt;h6&gt;. Code: # This is an H1 ## This is an H2 ###### This is an H6 Preview: This is an H1This is an H2This is an H6 Optionally, you may “close” atx-style headers. The closing hashes don’t need to match the number of hashes used to open the header. Code: # This is an H1 # ## This is an H2 ## ### This is an H3 ###### Preview: This is an H1This is an H2This is an H3 BlockquotesHTML Tag: &lt;blockquote&gt; Markdown uses email-style &gt; characters for blockquoting. It looks best if you hard wrap the text and put a &gt; before every line. Code: &gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet, &gt; consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus. &gt; Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. &gt; &gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse &gt; id sem consectetuer libero luctus adipiscing. Preview: This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisseid sem consectetuer libero luctus adipiscing. Markdown allows you to be lazy and only put the &gt; before the first line of a hard-wrapped paragraph. Code: &gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. &gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse id sem consectetuer libero luctus adipiscing. Preview: This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisseid sem consectetuer libero luctus adipiscing. Blockquotes can be nested (i.e. a blockquote-in-a-blockquote) by adding additional levels of &gt;. Code: &gt; This is the first level of quoting. &gt; &gt; &gt; This is nested blockquote. &gt; &gt; Back to the first level. Preview: This is the first level of quoting. This is nested blockquote. Back to the first level. Blockquotes can contain other Markdown elements, including headers, lists, and code blocks. Code: &gt; ## This is a header. &gt; &gt; 1. This is the first list item. &gt; 2. This is the second list item. &gt; &gt; Here&apos;s some example code: &gt; &gt; return shell_exec(&quot;echo $input | $markdown_script&quot;); Preview: This is a header. This is the first list item. This is the second list item. Here’s some example code: return shell_exec(&quot;echo $input | $markdown_script&quot;); ListsMarkdown supports ordered (numbered) and unordered (bulleted) lists. UnorderedHTML Tag: &lt;ul&gt; Unordered lists use asterisks (*), pluses (+), and hyphens (-). Code: * Red * Green * Blue Preview: Red Green Blue is equivalent to: Code: + Red + Green + Blue and: Code: - Red - Green - Blue OrderedHTML Tag: &lt;ol&gt; Ordered lists use numbers followed by periods: Code: 1. Bird 2. McHale 3. Parish Preview: Bird McHale Parish It’s possible to trigger an ordered list by accident, by writing something like this: Code: 1986. What a great season. Preview: What a great season. You can backslash-escape (\\) the period: Code: 1986\\. What a great season. Preview: 1986. What a great season. IndentedBlockquoteTo put a blockquote within a list item, the blockquote’s &gt; delimiters need to be indented: Code: * A list item with a blockquote: &gt; This is a blockquote &gt; inside a list item. Preview: A list item with a blockquote: This is a blockquoteinside a list item. Code BlockTo put a code block within a list item, the code block needs to be indented twice — 8 spaces or two tabs: Code: * A list item with a code block: &lt;code goes here&gt; Preview: A list item with a code block: &lt;code goes here&gt; Nested ListCode: * A * A1 * A2 * B * C Preview: A A1 A2 B C Code BlocksHTML Tag: &lt;pre&gt; Indent every line of the block by at least 4 spaces or 1 tab. Code: This is a normal paragraph: This is a code block. Preview: This is a normal paragraph: This is a code block. A code block continues until it reaches a line that is not indented (or the end of the article). Within a code block, ampersands (&amp;) and angle brackets (&lt; and &gt;) are automatically converted into HTML entities. Code: &lt;div class=&quot;footer&quot;&gt; &amp;copy; 2004 Foo Corporation &lt;/div&gt; Preview: &lt;div class=&quot;footer&quot;&gt; &amp;copy; 2004 Foo Corporation &lt;/div&gt; Following sections Fenced Code Blocks and Syntax Highlighting are extensions, you can use the other way to write the code block. Fenced Code BlocksJust wrap your code in ``` ```` (as shown below) and you won't need to indent it by four spaces.1234Code: Here&apos;s an example: function test() { console.log(&quot;notice the blank line before this function?&quot;); } 123Preview:***Here&apos;s an example: function test() { console.log(“notice the blank line before this function?”);}12345678910***#### Syntax HighlightingIn your fenced block, add an optional language identifier and we&apos;ll run it through syntax highlighting ([Support Languages](https://github.com/github/linguist/blob/master/lib/linguist/languages.yml)).Code: ```ruby require &apos;redcarpet&apos; markdown = Redcarpet.new(&quot;Hello World!&quot;) puts markdown.to_html Preview: 123require 'redcarpet'markdown = Redcarpet.new(\"Hello World!\")puts markdown.to_html Horizontal RulesHTML Tag: &lt;hr /&gt;Places three or more hyphens (-), asterisks (*), or underscores (_) on a line by themselves. You may use spaces between the hyphens or asterisks. Code: * * * *** ***** - - - --------------------------------------- ___ Preview: - - - TableHTML Tag: &lt;table&gt; It’s an extension. Separates column by pipe (|) and header by dashes (-), and uses colon (:) for alignment. The outer pipes (|) and alignment are optional. There are 3 delimiters each cell at least for separating header. Code:12345678910111213| Left | Center | Right ||:-----|:------:|------:||aaa |bbb |ccc ||ddd |eee |fff | A | B ---|---123|456A |B --|--12|45 Preview: Left Center Right aaa bbb ccc ddd eee fff A B 123 456 A B 12 45 Span ElementsLinksHTML Tag: &lt;a&gt; Markdown supports two style of links: inline and reference. InlineInline link format like this: [Link Text](URL &quot;Title&quot;) Title is optional. Code: This is [an example](http://example.com/ &quot;Title&quot;) inline link. [This link](http://example.net/) has no title attribute. Preview: This is an example inline link. This link has no title attribute. If you’re referring to a local resource on the same server, you can use relative paths: Code: See my [About](/about/) page for details. Preview: See my About page for details. ReferenceYou could predefine link references. Format like this: [id]: URL &quot;Title&quot; Title is also optional. And the you refer the link, format like this: [Link Text][id] Code: [id]: http://example.com/ &quot;Optional Title Here&quot; This is [an example][id] reference-style link. Preview: This is an example reference-style link. That is: Square brackets containing the link identifier (not case sensitive, optionally indented from the left margin using up to three spaces); followed by a colon; followed by one or more spaces (or tabs); followed by the URL for the link; The link URL may, optionally, be surrounded by angle brackets. optionally followed by a title attribute for the link, enclosed in double or single quotes, or enclosed in parentheses. The following three link definitions are equivalent: Code: [foo]: http://example.com/ &quot;Optional Title Here&quot; [foo]: http://example.com/ &apos;Optional Title Here&apos; [foo]: http://example.com/ (Optional Title Here) [foo]: &lt;http://example.com/&gt; &quot;Optional Title Here&quot; Uses an empty set of square brackets, the link text itself is used as the name. Code: [Google]: http://google.com/ [Google][] Preview: Google EmphasisHTML Tags: &lt;em&gt;, &lt;strong&gt; Markdown treats asterisks (*) and underscores (_) as indicators of emphasis. One delimiter will be &lt;em&gt;; *double delimiters will be &lt;strong&gt;. Code: *single asterisks* _single underscores_ **double asterisks** __double underscores__ Preview: single asterisks _single underscores_ double asterisks double underscores But if you surround an * or _ with spaces, it’ll be treated as a literal asterisk or underscore. You can backslash escape it: Code: \\*this text is surrounded by literal asterisks\\* Preview: *this text is surrounded by literal asterisks* CodeHTML Tag: &lt;code&gt; Wraps it with backtick quotes (`). Code: Use the `printf()` function. Preview: Use the printf() function. To include a literal backtick character within a code span, you can use multiple backticks as the opening and closing delimiters: Code: ``There is a literal backtick (`) here.`` Preview: There is a literal backtick (`) here. The backtick delimiters surrounding a code span may include spaces — one after the opening, one before the closing. This allows you to place literal backtick characters at the beginning or end of a code span: Code: A single backtick in a code span: `` ` `` A backtick-delimited string in a code span: `` `foo` `` Preview: A single backtick in a code span: ` A backtick-delimited string in a code span: `foo` ImagesHTML Tag: &lt;img /&gt; Markdown uses an image syntax that is intended to resemble the syntax for links, allowing for two styles: inline and reference. InlineInline image syntax looks like this: ![Alt text](URL &quot;Title&quot;) Title is optional. Code: ![Alt text](/path/to/img.jpg) ![Alt text](/path/to/img.jpg &quot;Optional title&quot;) Preview: That is: An exclamation mark: !; followed by a set of square brackets, containing the alt attribute text for the image; followed by a set of parentheses, containing the URL or path to the image, and an optional title attribute enclosed in double or single quotes. ReferenceReference-style image syntax looks like this: ![Alt text][id] Code: [img id]: url/to/image &quot;Optional title attribute&quot; ![Alt text][img id] Preview: StrikethroughHTML Tag: &lt;del&gt; It’s an extension. GFM adds syntax to strikethrough text. Code:1~~Mistaken text.~~ Preview: Mistaken text. MiscellaneousAutomatic LinksMarkdown supports a shortcut style for creating “automatic” links for URLs and email addresses: simply surround the URL or email address with angle brackets. Code: &lt;http://example.com/&gt; &lt;address@example.com&gt; Preview: http://example.com/ address@example.com GFM will autolink standard URLs. Code:1https://github.com/emn178/markdown Preview: https://github.com/emn178/markdown Backslash EscapesMarkdown allows you to use backslash escapes to generate literal characters which would otherwise have special meaning in Markdown’s formatting syntax. Code: \\*literal asterisks\\* Preview: *literal asterisks* Markdown provides backslash escapes for the following characters: Code: \\ backslash ` backtick * asterisk _ underscore {} curly braces [] square brackets () parentheses # hash mark + plus sign - minus sign (hyphen) . dot ! exclamation mark Inline HTMLFor any markup that is not covered by Markdown’s syntax, you simply use HTML itself. There’s no need to preface it or delimit it to indicate that you’re switching from Markdown to HTML; you just use the tags. Code: This is a regular paragraph. &lt;table&gt; &lt;tr&gt; &lt;td&gt;Foo&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; This is another regular paragraph. Preview: This is a regular paragraph. Foo This is another regular paragraph. Note that Markdown formatting syntax is not processed within block-level HTML tags. Unlike block-level HTML tags, Markdown syntax is processed within span-level tags. Code: &lt;span&gt;**Work**&lt;/span&gt; &lt;div&gt; **No Work** &lt;/div&gt; Preview: Work No Work","link":"/2016/12/21/markdown/"},{"title":"练习8-2 计算两数的和与差（10 分）","text":"练习8-2 计算两数的和与差（10 分）本题要求实现一个计算输入的两数的和与差的简单函数。 函数接口定义：void sum_diff( float op1, float op2, float psum, float pdiff );其中op1和op2是输入的两个实数，psum和pdiff是计算得出的和与差。 裁判测试程序样例：12345678910111213141516#include &lt;stdio.h&gt;void sum_diff( float op1, float op2, float *psum, float *pdiff );int main(){ float a, b, sum, diff; scanf(\"%f %f\", &amp;a, &amp;b); sum_diff(a, b, &amp;sum, &amp;diff); printf(\"The sum is %.2f\\nThe diff is %.2f\\n\", sum, diff); return 0; } /* 你的代码将被嵌在这里 */ 输入样例：4 6 输出样例：The sum is 10.00The diff is -2.00 123456789101112131415161718#include &lt;stdio.h&gt;void sum_diff( float op1, float op2, float *psum, float *pdiff );int main(){ float a, b, sum, diff; scanf(\"%f %f\", &amp;a, &amp;b); sum_diff(a, b, &amp;sum, &amp;diff); printf(\"The sum is %.2f\\nThe diff is %.2f\\n\", sum, diff); return 0; }void sum_diff( float op1, float op2, float *psum, float *pdiff ){ *psum=op1+op2; *pdiff=op1-op2;}","link":"/2018/01/24/liensi8-2/"},{"title":"面試到的SQL題","text":"怎么把這樣一個表 year month amount 1991 1 1.1 1991 2 1.2 1991 3 1.3 1991 4 1.4 1992 1 2.1 1992 2 2.2 1992 3 2.3 1992 4 2.4 查询這樣一個結果 year m1 m2 m3 m4 1991 1.1 1.2 1.3 1.4 1992 2.1 2.2 2.3 2.4 解答一123456select year,sum(case month when '1' then amount end) m1,sum(case month when “2” then amount end) m2,sum(case month when “3” then amount end) m3,sum(case month when “4” then amount end) m4 from table group by year order by year 解答二123select year,group_concat(amount) from table group by year order by year 解答三1234select p1.year,p1.month,p1.amount,p2.amount,p3.amount,p4.amountfrom protest p1 INNER JOIN protest p2 ON p1.month = p2.month +1 INNER JOIN protest p3 ON p2.month = p3.month+1 INNER JOIN protest p4 ON p3.month = p4.month + 1 WHERE p1.year = p2.yearAND p2.year = p3.year AND p3.year = p4.year;","link":"/2017/04/23/meinshr1/"},{"title":"mvninstallojdbc14","text":"12mvn install:install-file -DgroupId=com.oracle -DartifactId=ojdbc14 -Dversion=10.2.0.4.0 -Dpackaging=jar -Dfile=d:\\html\\ojdbc14-10.2.0.4.0.jarmvn install:install-file -DgroupId=com.oracle -DartifactId ojdbc14 -Dversion=10.2.0.4.0 -Dpackaging=jar -Dfile=D:\\html\\ojdbc14-10.2.0.4.0.jar","link":"/2016/05/04/mvninstallojdbc14/"},{"title":"java代碼重構的經驗總結分享","text":"轉載： http://www.cnblogs.com/jun-ma/p/4967839.html相關文章： https://www.ibm.com/developerworks/cn/java/j-lo-java8streamapi/java代碼重構的經驗總結分享java代碼重構的經驗總結分享 幾天前的壹次上線，腦殘手抖不小心寫了bug，雖然組裏的老大沒有說什麽，但心裏面很是難過。同事說我之所以寫蟲子是因為我討厭if/else，這個習慣不好。的確，if/else可以幫助我們很方便的寫出流程控制代碼，簡潔明了，這個條件做什麽，那個條件做什麽，說得很清楚。說真的，我從來不反對if/else，從經驗上看，越復雜的業務場景下，代碼寫的越簡單單壹，通常越不容易出錯。以結果為導向的現代項目管理方式，這是壹種很有效實踐經驗。 同事說的沒錯，我的確很討厭if/else。這個習慣很大程度是受Thoughtworks壹位咨詢師朋友影響，他經常在我耳邊嶗刀，寫代碼要幹凈，要簡潔，要靈活多變，不要固守城規，不要動不動就if/else，switch/case。初入it領域，我壹直把這句話奉為經典。在以後的學習工作中也時刻提醒自己要讓自己的代碼盡可能的看起來簡潔，不失靈活。不喜歡if/else並不意味著拒絕它，該使用的時候必要使用，比如函數接口入參check，處理異常分支邏輯流程等。通常能不用分支語句，我盡量不會使用，因為我覺得if/else很醜，每每看到if/else代碼，總會以挑剔的眼光看待它，想想能不能重構的更好。大多數時候，關於什麽好的代碼，大家的意見往往分歧很大，每個人都有各自的想法，審查妳代碼的人可能會選擇另壹種實現方式，這並不能說明誰對誰錯。 OO設計遵循SOLID(單壹功能、開閉原則、裏氏替換、接口隔離以及依賴反轉)原則，使用這個原則去審視if/else，可能會發現很多問題，比如不符合單壹原則，它本身就像壹團漿糊，融合了各種作料，黏糊糊的很不幹凈；比如不符合開閉原則，每新增壹種場景，就需要修改源文件增加壹條分支語句，業務邏輯復雜些若有1000種場景就得有1000個分支流，這種情況下代碼不僅僅惡心問題了，效率上也存在很大問題。由此可見，if/else雖然簡單方便，但不恰當的使用會給編碼代碼帶來非常痛苦的體驗。針對這種惡心的if/else分支，我們當然首先想到的去重構它–在不改變代碼外部功能特征的前提下對代碼內部邏輯進行調整和優化，但，如何做呢？前段時間在項目中正好遇到壹個惡心的if/else例子，想在這篇博客裏和大家分享壹下去除if/else重構的歷程。 java代碼重構的經驗總結分享 if/else的惡瘤 有句話說的好–好文章是改出來，同樣，好的代碼也肯定是重構出來的，因為沒有哪個軟件工程師能夠拍著胸脯保證在項目之初代碼設計這塊，就考慮到了所有需求變化可能性的擴展。隨著項目的不斷成長，業務邏輯變的越來越復雜，代碼也開始變的越來越多，原有的設計可能不再滿足需求，那麽此時必須要重構。就系統整體架構而言，重構可能需要很大的改動，可能在架構流程上需要評審；就功能內代碼層次而言，這種重構在我們編碼過程中隨時可以進行，類似於if/else，swicth/case這種代碼的重構也屬於這種類型。今天我們要重構的if/else源碼如下所示，針對不同的status code，CountRecoder對象會執行不同的set方法，為不同內部屬性賦值。 12345678910111213141516171819public CountRecoder getCountRecoder(List countEntries) { CountRecoder countRecoder = new CountRecoder(); for (CountEntry countEntry : countEntries) { if (1 == countEntry.getCode()) { countRecoder.setCountOfFirstStage(countEntry.getCount()); } else if (2 == countEntry.getCode()) { countRecoder.setCountOfSecondStage(countEntry.getCount()); } else if (3 == countEntry.getCode()) { countRecoder.setCountOfThirdtage(countEntry.getCount()); } else if (4 == countEntry.getCode()) { countRecoder.setCountOfForthtage(countEntry.getCount()); } else if (5 == countEntry.getCode()) { countRecoder.setCountOfFirthStage(countEntry.getCount()); } else if (6 == countEntry.getCode()) { countRecoder.setCountOfSixthStage(countEntry.getCount()); } } return countRecoder;} CountRecoder對象是壹個簡單的Java Bean，用於保存壹天之中六種狀態分別對應的數據條目，提供了get和set方法。CountEntry是對應數據庫中每種狀態的數據條目記錄，包含狀態code和以及count兩個字段, 我們可以使用mybatis實現數據庫記錄和java對象之間的轉換。上面getCountRecoder的方法實現了將list轉換為CountRecoder的功能。 看到這段代碼，想必已經有很多人要呵呵了，像壹坨啥啥啥，長得這麽醜，真不知道它”爸媽”怎麽想的，怎麽敢”生”出來。啥都不說了，直接回爐重構吧。重構是門藝術，Martin flow曾寫過壹本書《重構改變代碼之道》，裏面詳細的記錄了重構的方法論，感興趣的朋友可以閱讀壹下。說到重構，通常我們在重構中會遇到壹個問題，那就是如何能夠保證重構的代碼不改變原有的外部功能特征 ？經過TDD訓練的朋友應該知道答案，那就是單元測試，重構之前要寫單元測試，準確的來說應該是補單元測試，畢竟TDD的核心理念是測試驅動開發。對於今天博客中分享的例子，因為代碼邏輯比較簡單，所以偷了懶，省卻了單元測試的歷程。 重構初體驗–反射 要重構上面的代碼，對設計模式精通的人可以立馬可以看出來這是使用策略模式/狀態模式的絕佳場景，將策略模式稍微變換，工廠模式應該也是ok的，當然也有些人會選擇使用反射。對於這些方法，這裏不壹壹列出，主要想講壹下使用反射和工廠模式如何解決消除if/else問題，那先說反射吧，代碼如下所示：1234567891011121314151617181920212223242526private static Map methodsMap = new HashMap&lt;&gt;();static { methodsMap.put(1, \"setCountOfFirstStage\"); methodsMap.put(2, \"setCountOfSecondStage\"); methodsMap.put(3, \"setCountOfThirdtage\"); methodsMap.put(4, \"setCountOfForthtage\"); methodsMap.put(5, \"setCountOfFirthStage\"); methodsMap.put(6, \"setCountOfSixthStage\");}public CountRecoder getCountRecoderByReflect(List countEntries) { CountRecoder countRecoder = new CountRecoder(); countEntries.stream().forEach(countEntry -&gt; fillCount(countRecoder, countEntry)); return countRecoder;}private void fillCount(CountRecoder shippingOrderCountDto, CountEntry countEntry) { String name = methodsMap.get(countEntry.getCode()); try { Method declaredMethod = CountRecoder.class.getMethod(name, Integer.class); declaredMethod.invoke(shippingOrderCountDto, countEntry.getCount()); } catch (Exception e) { System.out.println(e); }} 重構初體驗–所謂模式 使用反射去掉if/else的原理很簡單，使用HashMap建立狀態碼和需要調用的方法的方法名之間的映射關系，對於每個CountEntry，首先取出狀態碼，然後根據狀態碼獲得相應的要調用方法的方法名，然後使用java的反射機制就可以實現對應方法的調用了。本例中使用反射的確可以幫助我們完美的去掉if/else的身影，但是，眾所周知，反射效率很低，在高並發的條件下，反射絕對不是壹個良好的選擇。除去反射這種方法，能想到的就剩下使用策略模式或者與其類似的狀態模式，以及工廠模式了，我們以工廠模式為例，經典的架構UML架構圖通常由三個組成要素： 抽象產品角色：通常是壹個抽象類或者接口，裏面定義了抽象方法具體產品角色：具體產品的實現類，繼承或是實現抽象策略類，通常由壹個或多個組成類組成。工廠角色：持有抽象產品類的引用，負責動態運行時產品的選擇和構建策略模式的架構圖和工廠模式非常類似，不過在策略模式裏執行的對象不叫產品，叫策略。在本例中，這裏的產品是虛擬產品，它是服務類性質的接口或者實現。Ok，按照工廠模式的思路重構我們的代碼，我們首先定義壹個抽象產品接口FillCountService，裏面定義產品的行為方法fillCount，代碼如下所示：123public interface FillCountService { void fillCount(CountRecoder countRecoder, int count);} 接著我們需要分別實現這六種服務類型的產品，在每種產品中封裝不同的服務算法，具體的代碼如下所示：1234567891011121314151617181920212223242526272829303132333435363738394041class FirstStageService implements FillCountService { @Override public void fillCount(CountRecoder countRecoder, int count) { countRecoder.setCountOfFirstStage(count); }}class SecondStageService implements FillCountService { @Override public void fillCount(CountRecoder countRecoder, int count) { countRecoder.setCountOfSecondStage(count); }}class ThirdStageService implements FillCountService { @Override public void fillCount(CountRecoder countRecoder, int count) { countRecoder.setCountOfThirdtage(count); }}class ForthStageService implements FillCountService { @Override public void fillCount(CountRecoder countRecoder, int count) { countRecoder.setCountOfForthtage(count); }}class FirthStageService implements FillCountService { @Override public void fillCount(CountRecoder countRecoder, int count) { countRecoder.setCountOfFirthStage(count); }}class SixthStageService implements FillCountService { @Override public void fillCount(CountRecoder countRecoder, int count) { countRecoder.setCountOfSixthStage(count); }} 緊接著，我們需要是實現工廠角色，在工廠內需要實現產品的動態選擇算法，使用HashMap維護狀態code和具體產品的對象之間的映射關系，就可以非常容易的實現這壹點，具體代碼如下所示：1234567891011121314151617public class FillCountServieFactory { private static Map fillCountServiceMap = new HashMap&lt;&gt;(); static { fillCountServiceMap.put(1, new FirstStageService()); fillCountServiceMap.put(2, new SecondStageService()); fillCountServiceMap.put(3, new ThirdStageService()); fillCountServiceMap.put(4, new ForthStageService()); fillCountServiceMap.put(5, new FirthStageService()); fillCountServiceMap.put(6, new SixthStageService()); } public static FillCountService getFillCountStrategy(int statusCode) { return fillCountServiceMap.get(statusCode); }} 客戶端在具體使用的時候就變的很簡單，那getCountRecoder方法就可以用下面的代碼實現:1234567public CountRecoder getCountRecoder(List countEntries) { CountRecoder countRecoder = new CountRecoder(); countEntries.stream().forEach(countEntry -&gt; FillCountServieFactory.getFillCountStrategy(countEntry.getCode()) .fillCount(countRecoder, countEntry.getCount())); return countRecoder;} 重構初體驗–Java8對模式設計的精簡 和反射壹樣使用設計模式也同樣完美的去除了if/else，但是不得不引入大量的具體服務實現類，同時程序中出現大量的模板代碼，使得我們程序看起來很不幹凈，幸好Java 8之後引入了Functional Interface，我們可以使用lambda表達式來去除這些模板代碼。將壹個接口變為Functional interface，可以通過在接口上添加FunctionalInterface註解實現，代碼如下所示：1234@FunctionalInterfacepublic interface FillCountService { void fillCount(CountRecoder countRecoder, int count);} 那麽具體的服務實現類就可以使用壹個簡單的lambda表達式代替，原先的FirstStageService類對象就可以使用下面的表達式代替： (countRecoder, count) -&gt; countRecoder.setCountOfFirstStage(count)那麽工廠類中的代碼就可以變為：1234567891011121314151617`public class FillCountServieFactory {` private static Map&lt;Integer, FillCountService&gt; fillCountServiceMap = new HashMap&lt;&gt;(); static { fillCountServiceMap.put(1, (countRecoder, count) -&gt; countRecoder.setCountOfFirstStage(count)); fillCountServiceMap.put(2, (countRecoder, count) -&gt; countRecoder.setCountOfSecondStage(count)); fillCountServiceMap.put(3, (countRecoder, count) -&gt; countRecoder.setCountOfThirdtage(count)); fillCountServiceMap.put(4, (countRecoder, count) -&gt; countRecoder.setCountOfForthtage(count)); fillCountServiceMap.put(5, (countRecoder, count) -&gt; countRecoder.setCountOfFirthStage(count)); fillCountServiceMap.put(6, (countRecoder, count) -&gt; countRecoder.setCountOfSixthStage(count)); } public static FillCountService getFillCountStrategy(int statusCode) { return fillCountServiceMap.get(statusCode); }`}` 這樣我們的代碼就重構完畢了，當然了還是有些不完美，程序中的魔法數字不利於閱讀理解，可以使用易讀的常量標識它們，在這裏就不做過多說明了。 總結 Craig Larman曾經說過軟件開發最重要的設計工具不是什麽技術，而是壹顆在設計原則方面訓練有素的頭腦。重構的最終結果不壹定會讓代碼變少，相反還有可能增加程序的復雜度和抽象性，就本例中的if/else而言，確實如此。我非常贊同我的壹位朋友說的話，做技術要有追求，沒錯if/else可以在代碼中工作的挺好，也可以很容易的被接替者所理解，但是我們可以有更好的選擇，因為簡單的代碼也可以變得很精彩。多勤多思，也許有壹天真的就可以達到Craig所說的在設計原則方面擁有訓練有素的頭腦，誰說不是這樣呢？加油吧。","link":"/2020/03/10/refactoring-java/"},{"title":"oracle imp exp","text":"1234567891011121314151617181920212223242526272829303132333435363738394041imp bookshop/123456@orcl file=D:\\java\\bookshop.dmp full=y;create temporary tablespace bookshop_temp tempfile 'D:\\app\\TOSHIBA\\oradata\\data\\bookshop_temp.dbf' size 50m autoextend on next 50m maxsize 20480m extent management local; create tablespace bookshop_data logging datafile 'D:\\app\\TOSHIBA\\oradata\\data\\bookshop_data.dbf' size 50m autoextend on next 50m maxsize 20480m extent management local; create user bookshop identified by 123456default tablespace bookshop_data temporary tablespace bookshop_temp;grant connect,resource,dba to bookshop;exp bookshop/123456@orcl file=D:\\java\\newbookshop.dmp tables=(ADMINS,ADMINTYPE,CART,CATEGORY,LEAVEWORD,MEMBER,MEMBERLEVEL,MERCHANDISE,ORDERDATA,RECORD)","link":"/2016/05/04/oracle-imp-exp/"},{"title":"个人简历","text":"联系方式 手机：1820206* Email：*@gmail.com QQ：42417658* 个人信息 黄汉杰/男/1991 本科/广州大学计算机系 工作年限：2年 技术博客：http://auhanjie.github.io Github：http://github.com/auhanjie 期望职位：JAVA开发程序员 期望薪资：税前月薪7k，特别喜欢的公司可例外 期望城市：珠海，深圳，广州 获奖证经历：2016-2017 全国大学英语四级考试514分/2016-2017 获得过校级一等奖学金，并被评为优秀大学生 教育背景2015/09~2017/06，广州大学 计算机科学与技术专业，获得学士学位2010/09~2013/06，广东科学技术职业学院 软体技术专业，大专毕业 工作经历2016/09~2016/10 实习生 广州静远科技开发有限公司 从事FOXTABLE软体开发工作，开发能耗统计分析系统，认真完成项目中的每一项任务。 2013/07~2014/07 Java软件开发工程师 易达通网络科技公司 从事Linux环境下的Java软件软件开发工作，工作期间，认真完成项目中的每一项任务。 2013/02~2013/06 Java Web实习生 珠海联迪软体系统有限公司 从事Java web开发，认真完成项目中的每一项任务。实习期间，参与开发清远市信访前后端系统。 易达通网络科技公司（ 2013年7月 ~ 2014年7月 ）黑龙江教育标引平台该项目对书籍进行标引管理，提供标引信息可以获取书籍信息，而且可以通过pdf,equb,txt等自动识别标引进行标注，让教育后台管理人员更加易用的管理。 此系统整体采用MVC模式的Spring框架，持久层使用的是Mybatis实现，数据源利用的是SpringIoC注入；模型层严格按照JavaBean规范要求；用Spring进行流程的控制，并实现了shiro权限控制管理，采用Redis 速度快，因为数据存在内存中，类似于HashMap，HashMap的优势（查找和操作的时间快）。数据库采用Mysql，适当建立索引机制，进行优化查询。而且采用MongoDB，它包括了一个可以显示数据库中每个操作性能特点的数据库分析器。通过这个分析器你可以找到比预期慢的查询(或写操作);利用这一信息，比如，可以确定是否需要添加索引。 广州银联的代收付平台系统在本项目中本人是高效的执行者角色。本人独立完成了整个项目的数据库索引优化工作，并参与开发与测试等环节中。作为核心程序员，我还完成了系统权限管理、报表查询设计的开发工作。 此系统整体采用MVC模式的Spring框架，持久层使用的是Spring的HibernateTemplate实现，数据源利用的是SpringIoC注入；模型层严格按照JavaBean规范要求；用Spring进行流程的控制，并实现了国际化，JSP用纯标签进行页面显示。为达到用户名唯一的目的用户注册采用Ajax技术进行后台校验。运用SpringIoC的注入对各层解耦，大大提高了程序的可扩展性，易于维护。本项目采用maven项目管理和构建自动化工具。数据库采用oracle11g开发设计。 通过拦截器实现了系统权限管理功能，提高安全性。同时通过拦截器记录请求信息，以便进行信息监控和信息统计；检查权限，比如监测请求进入之前是否登录，如果没有可以返回登录页面；监控性能，比如可以通过拦截器记录请求进入处理器的开始时间，在处理后再记录结束时间，由此可以统计该请求的处理时间。Hibernatre的优化，结合数据库，调整批处理的条数，比如batch-size参数是设定每次从数据库中取出的记录条数，一般设置为30,50,100，一般的说法是Oracle 数据库的JDBC驱动的默认值是15，当设置为30或50时，性能就明显提升,如果继续增长，超过100，则性能提升就不明显了。 SMS-短信收发平台系统该系统主要功能是SMS是个集多种短讯业务管理功能于一体的多功能短讯服务运营平台，具有稳定可靠、模组化、开放性、灵活性等特点。Web SMS系统无需安装任何软体，即可轻松管理客户名单及发送短讯，既可加强与客户的联系，可减低市场推广及行政上的资源及成本，是最佳的通讯及宣传工具。2013年，我参与了SMS-短信收发平台系统的开发。 作为核心程序员之一，我不但完成了发送短信界面设计、权限控制和报表查询的开发工作，更提出了高效的查询下拉列表插件，通过个性化提升了操作员查询体验。 该项目对Hibernate进行优化，适当地建立索引，如果数据量很大就少用关联，或者适当地建分区。在适合的的时间点清除缓存，一般会有大量的数据保存在session的一级缓存中，如果缓存太大时就会拖累性能，所以在必要时使用session.Clear()或者session.Erict(Object)清除全部缓存或某个对象。通过优化一对多的映射关系，提高性能，通过设置inverse在多的一方优化查询操作。遇到高并发和大访问量的情况，一、减少http请求（比如Js合并，css合并，图片合并，虽然文件大了，但是减少请求）二、添加异步请求（比如不太重要的东西先不展示，用户需要的时候再放一些事件，jQuery等添加异步请求获取）三、启用游览器缓冲和文件压缩。四、CDN加速（把前端的文件，前端的资源全部放到cdn中，用户就近访问，从而提高访问速度，从一定意义也解决了流量不够用的问题）。 其他项目easylink好易联支付平台系统LBN易联通支付平台系统SMC商户管理平台系统能耗统计分析系统项⽬清远市信访管理平台系统 技能清单以下均为我熟练使用的技能 Web开发：JSP/PHP/HTML5 系统框架：Mybatis/Hibernate/Struts2/StringMvc/String/Shiro/ThinkPHP 前端框架：Bootstrap/Jquery 数据库相关：MySQL/Oracle 版本管理、文档和自动化部署工具：Svn/Git/Maven 单元测试：Junit4 个⼈评价谦虚、谨慎而富有挑战精神，希望您能给我一个展示自我的机会。 致谢感谢您花时间阅读我的简历，期待能有机会和您共事。","link":"/2018/08/15/resume/"},{"title":"service和serviceImpl的选择","text":"service和serviceImpl的选择有些同行公司代码风格使用service层=service接口+serviceImpl实现类； 而有的同行公司的代码风格是service层=service类； 网上有人说是因为当项目的业务逻辑简单时，可选择service层=service类； 当项目的业务复杂时，可选择service层=service接口+serviceImpl实现类； 至于复杂和简单的度得自己把握； 今天在看 spring实战（第4版）的时候，看到解释 如下： spring鼓励应用程序的各个层以接口的形式暴露功能，在service层，可以使用service接口+serviceImple实现类，也可以使用service类，但考虑到“接口时实现松耦合的关键”，所以更加推荐使用 service接口+serviceImple实现类的方式来写service层代码。 核心是“松耦合”。","link":"/2018/09/08/service和serviceImpl的选择/"},{"title":"深圳奥統平","text":"單例模式 GIT和SVN區別 編程題 用string 相加，不能用lib兩個數組判斷，是否B屬於A的子類，有返回第一個數組的下標，無則返回-1 12345678910111213141516pubilc Sting add(Sting numberA,String numberB){ } system.out.println(add(\"123456789123456789123456789\",\"123456789123456789123456789\")); //24676895858588768055576705442138576768 system.out.println(add(\"1\",\"2\")); //3 system.out.println(add(\"A\",\"1\")); //ERROR pubilc int sub(int A[],int B[]){} system.out.println(sub(\"{4,5,6,7,8}\",\"{5,6}\")); //return 1 system.out.println(sub(\"{4,5,6,7,8}\",\"{5,4}\")); //return -1 system.out.println(sub(\"{4,5,6,7,8}\",\"{6,7,8}\")); //return 2","link":"/2016/12/21/shenjhenautungping/"},{"title":"深圳縱覽","text":"單例模式和工廠模式 springmvc的理解 servlet的生命週期和方法有哪些 構造函數和重載 jquery異步 轉發請求forward和Redirect JSP的運行機制 JSP的內置對象及其用途 spring的理解，依賴注入控制反轉 如何用jquery來進行異步表單提交","link":"/2016/12/21/shenjhenshrlanjhungkejigufenyousiengungsr/"},{"title":"深圳法本","text":"table1 序號 日期 客戶人數 01 1 1000 02 2 2000 03 3 3000 查询SQL如下 序號 日期 客戶人數 上一個客戶人數 环比 02 2 2000 1000 100% 03 3 3000 2000 125% 1234SELECT t.*,t1.客户人数 AS 上次客户人数,(t.客户人数-t1.客户人数)/t1.客户人数*100||'%' AS 环比FROM table1 t,table1 t1WHERE t.日期=t1.日期+1ORDER BY t.序号 List,SET和MAP有什麽實例 Stringmvc的特性 多線程 XML解析","link":"/2016/10/14/shenjhenfaben/"},{"title":"实验1-2 Welcome to You!（5 分）","text":"实验1-2 Welcome to You!（5 分）本题要求编写程序，输出一个短句“Welcome to You!”。 输入格式:本题目没有输入。 输出格式:在一行中输出短句“Welcome to You!”。 123456#include&lt;stdio.h&gt;int main(void){ printf(\"Welcome to You!\\n\"); return 0;}","link":"/2017/10/19/shryen1-2/"},{"title":"实验1-1 Hello World!（5 分）","text":"实验1-1 Hello World!（5 分）本题要求编写程序，输出一个短句“Hello World!”。 输入格式:本题目没有输入。 输出格式:在一行中输出短句“Hello World!”。 123456#include&lt;stdio.h&gt;int main(void){ printf(\"Hello World!\\n\"); return 0;}","link":"/2017/10/19/shryen1-1/"},{"title":"实验1-4 输出三角形（5 分）","text":"实验1-4 输出三角形（5 分）本题要求编写程序，输出指定的由“*”组成的三角图案。 输入格式：本题无输入 输出格式：按照下列格式输出由“*”组成的三角图案。 1234********** 123456789#include&lt;stdio.h&gt; int main(void) { printf(\"****\\n\"); printf(\"***\\n\"); printf(\"**\\n\"); printf(\"*\\n\"); return 0; }","link":"/2017/10/19/shryen1-4/"},{"title":"实验1-3 Programming in C is fun!（5 分）","text":"实验1-3 Programming in C is fun!（5 分）本题要求编写程序，输出一个短句“Programming in C is fun!”。 输入格式:本题目没有输入。 输出格式:在一行中输出短句“Programming in C is fun!”。 123456#include&lt;stdio.h&gt;int main(void){ printf(\"Programming in C is fun!\\n\"); return 0;}","link":"/2017/10/19/shryen1-3/"},{"title":"实验1-6 输出带框文字（5 分）","text":"实验1-6 输出带框文字（5 分）本题要求编写程序，输出指定的带框文字。 输入格式：本题无输入 输出格式：按照下列格式输出带框文字。 123************ Welcome************ 12345678#include&lt;stdio.h&gt; int main(void) { printf(\"************\\n\"); printf(\" Welcome\\n\"); printf(\"************\\n\"); return 0; }","link":"/2017/10/19/shryen1-6/"},{"title":"实验1-8 输出倒三角图案（5 分）","text":"实验1-8 输出倒三角图案（5 分）本题要求编写程序，输出指定的由“*”组成的倒三角图案。 输入格式:本题目没有输入。 输出格式:按照下列格式输出由“*”组成的倒三角图案。 1234* * * * * * * * * * 123456789#include&lt;stdio.h&gt; int main(void) { printf(\"* * * *\\n\"); printf(\" * * *\\n\"); printf(\" * *\\n\"); printf(\" *\\n\"); return 0; }","link":"/2017/10/19/shryen1-8/"},{"title":"实验1-4 输出三角形（5 分）","text":"实验1-5 输出菱形图案（5 分）本题要求编写程序，输出指定的由“A”组成的菱形图案。 输入格式：本题无输入 输出格式：按照下列格式输出由“A”组成的菱形图案。 123 AA A A 12345678#include&lt;stdio.h&gt; int main(void) { printf(\" A\\n\"); printf(\"A A\\n\"); printf(\" A\\n\"); return 0; }","link":"/2017/10/19/shryen1-5/"},{"title":"实验1-7 What is a computer?（5 分）","text":"实验1-7 What is a computer?（5 分）本题要求编写程序，输出一个短句“What is a computer?”。 输入格式:本题目没有输入。 输出格式:在一行中输出短句“What is a computer?”。 123456#include&lt;stdio.h&gt; int main(void) { printf(\"What is a computer?\\n\"); return 0; }","link":"/2017/10/19/shryen1-7/"},{"title":"实验10-3 递归求阶乘和（15 分）","text":"实验10-3 递归求阶乘和（15 分）本题要求实现一个计算非负整数阶乘的简单函数，并利用该函数求 $1!+2!+3!+\\cdots+n! $的值。 函数接口定义：12double fact( int n );double factsum( int n ); 函数fact应返回n的阶乘，建议用递归实现。函数factsum应返回 1!+2!+…+n! 的值。题目保证输入输出在双精度范围内。 裁判测试程序样例：1234567891011121314151617#include &lt;stdio.h&gt;double fact( int n );double factsum( int n );int main(){ int n; scanf(\"%d\",&amp;n); printf(\"fact(%d) = %.0f\\n\", n, fact(n)); printf(\"sum = %.0f\\n\", factsum(n)); return 0;}/* 你的代码将被嵌在这里 */ 输入样例1：110 输出样例1：12fact(10) = 3628800sum = 4037913 输入样例2：10 输出样例2：12fact(0) = 1sum = 0 123456789101112131415161718192021222324252627282930313233343536#include &lt;stdio.h&gt;double fact( int n );double factsum( int n );int main(){ int n; scanf(\"%d\",&amp;n); printf(\"fact(%d) = %.0f\\n\", n, fact(n)); printf(\"sum = %.0f\\n\", factsum(n)); return 0;}double fact(int n){ double result; if (n == 0 || n == 1) result = 1; else result = n*fact(n-1); return result;}double factsum(int n){ int i; double sum; sum=0; for (i=1; i&lt;=n; i++) sum = sum+fact(i); return sum;}","link":"/2018/01/10/shryen10-3/"},{"title":"实验10-10 递归实现顺序输出整数（15 分）","text":"实验10-10 递归实现顺序输出整数（15 分）本题要求实现一个函数，对一个整数进行按位顺序输出。 函数接口定义：1void printdigits( int n ); 函数printdigits应将n的每一位数字从高位到低位顺序打印出来，每位数字占一行。 裁判测试程序样例：123456789101112131415#include &lt;stdio.h&gt;void printdigits( int n );int main(){ int n; scanf(\"%d\", &amp;n); printdigits(n); return 0;}/* 你的代码将被嵌在这里 */ 输入样例：112345 输出样例：1234512345 123456789101112131415161718192021222324#include &lt;stdio.h&gt;void printdigits( int n );int main(){ int n; scanf(\"%d\", &amp;n); printdigits(n); return 0;} void printdigits(int num){ if (num &lt;= 9) printf(\"%d\\n\", num); else { printdigits(num / 10); printf(\"%d\\n\", num % 10); }}","link":"/2018/01/10/shryen10-10/"},{"title":"实验10-5 递归求简单交错幂级数的部分和（15 分）","text":"实验10-5 递归求简单交错幂级数的部分和（15 分）本题要求实现一个函数，计算下列简单交错幂级数的部分和： $f(x,n)=x−x^2+x^3−x^4+\\cdots+(−1)^{n−1}*x^n$ 函数接口定义：1double fn( double x, int n ); 其中题目保证传入的n是正整数，并且输入输出都在双精度范围内。函数fn应返回上述级数的部分和。建议尝试用递归实现。 裁判测试程序样例：12345678910111213141516#include &lt;stdio.h&gt;double fn( double x, int n );int main(){ double x; int n; scanf(\"%lf %d\", &amp;x, &amp;n); printf(\"%.2f\\n\", fn(x,n)); return 0;}/* 你的代码将被嵌在这里 */ 输入样例：10.5 12 输出样例：10.33 123456789101112131415161718192021222324#include &lt;stdio.h&gt;double fn( double x, int n );int main(){ double x; int n; scanf(\"%lf %d\", &amp;x, &amp;n); printf(\"%.2f\\n\", fn(x,n)); return 0;}double fn(double x, int n){ double result; if (n == 0 || n == 1) result = x; else result = x - x*fn(x, n-1); return result;}","link":"/2018/01/10/shryen10-5/"},{"title":"实验10-2 判断满足条件的三位数（15 分）","text":"实验10-2 判断满足条件的三位数（15 分）本题要求实现一个函数，统计给定区间内的三位数中有两位数字相同的完全平方数（如144、676）的个数。 函数接口定义：1int search( int n ); 其中传入的参数int n是一个三位数的正整数（最高位数字非0）。函数search返回[101, n]区间内所有满足条件的数的个数。 裁判测试程序样例：1234567891011121314151617#include &lt;stdio.h&gt;#include &lt;math.h&gt;int search( int n );int main(){ int number; scanf(\"%d\",&amp;number); printf(\"count=%d\\n\",search(number)); return 0;}/* 你的代码将被嵌在这里 */ 输入样例：1500 输出样例：1count=6 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;stdio.h&gt;#include &lt;math.h&gt;int search( int n );int main(){ int number; scanf(\"%d\",&amp;number); printf(\"count=%d\\n\",search(number)); return 0;}int search(int n){ int i, count, min, max, square, first, second, third; if (n &lt; 121) { count = 0; return count; } min = sqrt(121); max = sqrt(n); for (i = min, count = 0; i &lt;= max; i++) { square = i*i; first = square % 10; second = square / 10 % 10; third = square / 100; if (first == second || first == third || second == third) count++; } return count;}","link":"/2018/01/10/shryen10-2/"},{"title":"实验10-4 递归实现指数函数（15 分）","text":"实验10-4 递归实现指数函数（15 分）本题要求实现一个计算$x^n（n\\geq1）$的函数。 函数接口定义：1double calc_pow( double x, int n ); 函数calc_pow应返回x的n次幂的值。建议用递归实现。题目保证结果在双精度范围内。 裁判测试程序样例：12345678910111213141516#include &lt;stdio.h&gt;double calc_pow( double x, int n );int main(){ double x; int n; scanf(\"%lf %d\", &amp;x, &amp;n); printf(\"%.0f\\n\", calc_pow(x, n)); return 0;}/* 你的代码将被嵌在这里 */ 输入样例：12 3 输出样例：18 1234567891011121314151617181920212223242526#include &lt;stdio.h&gt;double calc_pow( double x, int n );int main(){ double x; int n; scanf(\"%lf %d\", &amp;x, &amp;n); printf(\"%.0f\\n\", calc_pow(x, n)); return 0;}double calc_pow(double x, int n){ double result; if (n == 0) result = 1; else result = x*calc_pow(x, n-1); return result;}","link":"/2018/01/10/shryen10-4/"},{"title":"实验10-1 圆形体体积计算器（20 分）","text":"实验10-1 圆形体体积计算器（20 分）本题要求实现一个常用圆形体体积的计算器。计算公式如下： 球体体积 $V= \\frac{4}{3} \\pi r^3$，其中r是球体半径。 圆柱体体积$ V=πr^2h$，其中r是底圆半径，h是高。 圆锥体体积$ V=\\frac{1}{3} \\pi r^2h$，其中r是底圆半径，h是高。 输入格式：在每次计算之前，要求输出如下界面： 123451-Ball2-Cylinder3-Coneother-ExitPlease enter your command: 然后从标准输入读进一个整数指令。 输出格式：如果读入的指令是1或2或3，则执行相应的体积计算；如果是其他整数，则程序结束运行。 当输入为1时，在计算球体体积之前，打印Please enter the radius:，然后读入球体半径，完成计算； 当输入为2时，在计算圆柱体体积之前，打印Please enter the radius and the height:，然后读入底圆半径和高，完成计算； 当输入为3时，在计算圆锥体体积之前，打印Please enter the radius and the height:，然后读入底圆半径和高，完成计算。 计算结果在一行内输出，保留小数点后两位。 输入样例：123451232.4 30 输出样例：123456789101112131415161718191-Ball2-Cylinder3-Coneother-ExitPlease enter your command:Please enter the radius:33.511-Ball2-Cylinder3-Coneother-ExitPlease enter your command:Please enter the radius and the height:18.101-Ball2-Cylinder3-Coneother-ExitPlease enter your command: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;math.h&gt; #define PI 3.141592654 void cal(int sel); int main(void) { int sel; while(1){ printf(\"1-Ball\\n\"); printf(\"2-Cylinder\\n\"); printf(\"3-Cone\\n\"); printf(\"other-Exit\\n\"); printf(\"Please enter your command:\"); scanf(\"%d\",&amp;sel); if(sel&lt;1||sel&gt;3) break; else cal(sel); } return 0; } void cal(int sel) { double vol_ball(void); double vol_cylind(void); double vol_cone(void); switch(sel) { case 1: printf(\"球体积为:%.2f\\n\",vol_ball()); break; case 2: printf(\"圆柱体积为:%.2f\\n\",vol_cylind()); break; case 3: printf(\"圆锥体积为:%.2f\\n\",vol_cone()); break; } } double vol_ball() { double r; printf(\"Please enter the radius::\"); scanf(\"%lf\",&amp;r); return (4.0/3.0*PI*r*r*r); } double vol_cylind() { double r,h; printf(\"Please enter the radius and the height:\"); scanf(\"%lf%lf\",&amp;r,&amp;h); return (PI*r*r*h); } double vol_cone(){ double r,h; printf(\"Please enter the radius and the height:\"); scanf(\"%lf%lf\",&amp;r,&amp;h); return (PI*r*r*h/3.0);}","link":"/2018/01/10/shryen10-1/"},{"title":"实验10-6 递归计算Ackermenn函数（15 分）","text":"实验10-6 递归计算Ackermenn函数（15 分）本题要求实现Ackermenn函数的计算，其函数定义如下：$$\\operatorname{ack}(m, n)=\\begin{cases}n+1, &amp; m = 0 \\\\\\\\\\operatorname{ack}(m-1, 1), &amp; n=0 \\&amp; \\&amp; m\\gt0 \\\\\\\\\\operatorname{ack}(m-1, \\operatorname{ack}(m, n-1)),&amp; m \\gt0 \\&amp; \\&amp; n\\gt 0\\end{cases}$$ 函数接口定义：1int Ack( int m, int n ); 其中m和n是用户传入的非负整数。函数Ack返回Ackermenn函数的相应值。题目保证输入输出都在长整型 范围内。 裁判测试程序样例：123456789101112131415#include &lt;stdio.h&gt;int Ack( int m, int n );int main(){ int m, n; scanf(\"%d %d\", &amp;m, &amp;n); printf(\"%d\\n\", Ack(m, n)); return 0;}/* 你的代码将被嵌在这里 */ 输入样例：12 3 输出样例：19 12345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;int Ack( int m, int n );int main(){ int m, n; scanf(\"%d %d\", &amp;m, &amp;n); printf(\"%d\\n\", Ack(m, n)); return 0;}int Ack(int m, int n){ int result; if (m == 0) result = n+1; else { if (n == 0) result = Ack(m - 1, 1); else result = Ack(m-1, Ack(m, n-1)); } return result;}","link":"/2018/01/10/shryen10-6/"},{"title":"实验10-7 递归求Fabonacci数列（10 分）","text":"实验10-7 递归求Fabonacci数列（10 分）本题要求实现求Fabonacci数列项的函数。Fabonacci数列的定义如下： $f(n)=f(n−2)+f(n−1) (n≥2)$，其中$f(0)=0，f(1)=1$。 函数接口定义：1int f( int n ); 函数f应返回第n个Fabonacci数。题目保证输入输出在长整型范围内。建议用递归实现。 裁判测试程序样例：123456789101112131415#include &lt;stdio.h&gt;int f( int n );int main(){ int n; scanf(\"%d\", &amp;n); printf(\"%d\\n\", f(n)); return 0;}/* 你的代码将被嵌在这里 */ 输入样例：16 输出样例：18 12345678910111213141516171819202122232425#include &lt;stdio.h&gt;int f( int n );int main(){ int n; scanf(\"%d\", &amp;n); printf(\"%d\\n\", f(n)); return 0;}int f(int n){ int result; if (n == 0) result = 0; else if (n == 1) result = 1; else result = f(n-2) + f(n-1); return result;}","link":"/2018/01/10/shryen10-7/"},{"title":"实验11-1-2 输出月份英文名（15 分）","text":"实验11-1-2 输出月份英文名（15 分）本题要求实现函数，可以返回一个给定月份的英文名称。 函数接口定义：1char *getmonth( int n ); 函数getmonth应返回存储了n对应的月份英文名称的字符串头指针。如果传入的参数n不是一个代表月份的数字，则返回空指针NULL。 裁判测试程序样例：123456789101112131415161718#include &lt;stdio.h&gt;char *getmonth( int n );int main(){ int n; char *s; scanf(\"%d\", &amp;n); s = getmonth(n); if ( s==NULL ) printf(\"wrong input!\\n\"); else printf(\"%s\\n\", s); return 0;}/* 你的代码将被嵌在这里 */ 输入样例1：15 输出样例1：1May 输入样例2：115 输出样例2：1wrong input! 123456789101112131415161718192021222324#include &lt;stdio.h&gt;char *getmonth( int n );int main(){ int n; char *s; scanf(\"%d\", &amp;n); s = getmonth(n); if ( s==NULL ) printf(\"wrong input!\\n\"); else printf(\"%s\\n\", s); return 0;}char *getmonth(int n){ char *s[] = {\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"}; if(n&lt;=0||n&gt;12) return NULL; else return(s[n-1]); }","link":"/2018/01/11/shryen11-1-2/"},{"title":"实验11-1-1 英文单词排序（25 分）","text":"实验11-1-1 英文单词排序（25 分）本题要求编写程序，输入若干英文单词，对这些单词按长度从小到大排序后输出。如果长度相同，按照输入的顺序不变。 输入格式：输入为若干英文单词，每行一个，以#作为输入结束标志。其中英文单词总数不超过20个，英文单词为长度小于10的仅由小写英文字母组成的字符串。 输出格式：输出为排序后的结果，每个单词后面都额外输出一个空格。 输入样例：123456blueredyellowgreenpurple# 输出样例：1red blue green yellow purple 12345678910111213141516171819202122232425262728293031323334#include &lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;void main(){ int i,j, n = 0; char *color[20], str[10], *temp; scanf(\"%s\", str); while(str[0] != '#') { color[n] = (char *)malloc(sizeof(char)*(strlen(str)+1)); strcpy(color[n], str); n++; scanf(\"%s\", str); } color[n] = '\\0'; for(i = 1; i &lt; n; i++ ) { for(j = 0; j &lt; n-i; j++) if(strcmp(color[j], color[j+1]) &gt; 0) { temp = color[j]; color[j] = color[j+1]; color[j+1] = temp; } } for(i = 0; i &lt; n; i++) { printf(\"%s \", color[i]); free(color[i]); } printf(\"\\n\");}","link":"/2018/01/10/shryen11-1-1/"},{"title":"实验10-9 十进制转换二进制（15 分）","text":"实验10-9 十进制转换二进制（15 分）本题要求实现一个函数，将正整数n转换为二进制后输出。 函数接口定义：1void dectobin( int n ); 函数dectobin应在一行中打印出二进制的n。建议用递归实现。 裁判测试程序样例：123456789101112131415#include &lt;stdio.h&gt;void dectobin( int n );int main(){ int n; scanf(\"%d\", &amp;n); dectobin(n); return 0;}/* 你的代码将被嵌在这里 */ 输入样例：110 输出样例：11010 1234567891011121314151617181920212223242526#include &lt;stdio.h&gt;void dectobin( int n );int main(){ int n; scanf(\"%d\", &amp;n); dectobin(n); return 0;}void dectobin(int n){ if (n == 0) printf(\"0\"); else if (n == 1) printf(\"1\"); else { dectobin(n/2); printf(\"%d\", n%2); }}","link":"/2018/01/10/shryen10-9/"},{"title":"实验10-8 递归计算P函数（15 分）","text":"实验10-8 递归计算P函数（15 分）$$ack(m,n)=\\begin{cases}1 &amp; (n=0) \\\\\\\\x &amp; (n=1)\\\\\\\\\\frac{(2n-1)P(n-1,x)-(n-1)P(n-2,x)}{n} &amp; (n&gt;1)\\end{cases}$$ 函数接口定义：1double P( int n, double x ); 其中n是用户传入的非负整数，x是双精度浮点数。函数P返回P(n,x)函数的相应值。题目保证输入输出都在双精度范围内。 裁判测试程序样例：12345678910111213141516#include &lt;stdio.h&gt;double P( int n, double x );int main(){ int n; double x; scanf(\"%d %lf\", &amp;n, &amp;x); printf(\"%.2f\\n\", P(n,x)); return 0;}/* 你的代码将被嵌在这里 */ 输入样例：110 1.7 输出样例：13.05 1234567891011121314151617181920212223242526#include &lt;stdio.h&gt;double P( int n, double x );int main(){ int n; double x; scanf(\"%d %lf\", &amp;n, &amp;x); printf(\"%.2f\\n\", P(n,x)); return 0;}double P( int n, double x ){ double result; if(n == 0) result = 1; else if(n == 1) result = x; else result = ((2 * n - 1) * P(n-1,x)-(n - 1) * P(n-2,x)) / n; return result;}","link":"/2018/01/10/shryen10-8/"},{"title":"实验11-1-3 查找星期（15 分）","text":"实验11-1-3 查找星期（15 分）本题要求实现函数，可以根据下表查找到星期，返回对应的序号。 序号 星期 0 Sunday 1 Monday 2 Tuesday 3 Wednesday 4 Thursday 5 Friday 6 Saturday 函数接口定义：1int getindex( char *s ); 函数getindex应返回字符串s序号。如果传入的参数s不是一个代表星期的字符串，则返回-1。 裁判测试程序样例：123456789101112131415161718192021#include &lt;stdio.h&gt;#include &lt;string.h&gt;#define MAXS 80int getindex( char *s );int main(){ int n; char s[MAXS]; scanf(\"%s\", s); n = getindex(s); if ( n==-1 ) printf(\"wrong input!\\n\"); else printf(\"%d\\n\", n); return 0;}/* 你的代码将被嵌在这里 */ 输入样例1：1Tuesday 输出样例1：12 输入样例2：1today 输出样例2：1wrong input! 1234567891011121314151617181920212223242526272829303132333435#include &lt;stdio.h&gt;#include &lt;string.h&gt;#define MAXS 80int getindex( char *s );int main(){ int n; char s[MAXS]; scanf(\"%s\", s); n = getindex(s); if ( n==-1 ) printf(\"wrong input!\\n\"); else printf(\"%d\\n\", n); return 0;}int getindex(char *s){ char a[7][MAXS] = {\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"}; int i; for (i=0; i&lt;7; i++) { if (strcmp(a[i],s) == 0) { return i; } } if(i=7) return -1;}","link":"/2018/01/11/shryen11-1-3/"},{"title":"实验11-1-4 计算最长的字符串长度（15 分）","text":"实验11-1-4 计算最长的字符串长度（15 分）本题要求实现一个函数，用于计算有n个元素的指针数组s中最长的字符串的长度。 函数接口定义：1int max_len( char *s[], int n ); 其中n个字符串存储在s[]中，函数max_len应返回其中最长字符串的长度。 裁判测试程序样例：12345678910111213141516171819202122232425#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#define MAXN 10#define MAXS 20int max_len( char *s[], int n );int main(){ int i, n; char *string[MAXN] = {NULL}; scanf(\"%d\", &amp;n); for(i = 0; i &lt; n; i++) { string[i] = (char *)malloc(sizeof(char)*MAXS); scanf(\"%s\", string[i]); } printf(\"%d\\n\", max_len(string, n)); return 0;}/* 你的代码将被嵌在这里 */ 输入样例：123454blueyellowredgreen 输出样例：16 12345678910111213141516171819202122232425262728293031323334#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#define MAXN 10#define MAXS 20int max_len( char *s[], int n );int main(){ int i, n; char *string[MAXN] = {NULL}; scanf(\"%d\", &amp;n); for(i = 0; i &lt; n; i++) { string[i] = (char *)malloc(sizeof(char)*MAXS); scanf(\"%s\", string[i]); } printf(\"%d\\n\", max_len(string, n)); return 0;}int max_len(char *s[], int n){ int m=0,i,l; for (i=0; i&lt;n; i++) { l=strlen(s[i]); if(m&lt;l) m=l; } return m;}","link":"/2018/01/11/shryen11-1-4/"},{"title":"实验11-1-7 藏头诗（15 分）","text":"实验11-1-7 藏头诗（15 分）本题要求编写一个解密藏头诗的程序。 输入格式：输入为一首中文藏头诗，一共四句，每句一行。注意：一个汉字占两个字节。 输出格式：取出每句的第一个汉字并连接在一起形成一个字符串并输出。同时在末尾输入一个换行符。 输入样例：1234一叶轻舟向东流帆稍轻握杨柳手风纤碧波微起舞顺水任从雅客流 输出样例：1一帆风顺 1234567891011121314151617181920212223242526#include &lt;stdio.h&gt;char *ch( char s[][2000],char t[]);int main(){ char s[100][2000], t[1000],*p=NULL; int i; for(i=0;i&lt;4;i++) scanf(\"%s\",&amp;s[i][2000]); p=ch(s,t); printf(\"%s\\n\",p); return 0;}char *ch(char s[][2000], char t[]){ int j; for (j=0; j&lt;4;j++) { t[2*j]=s[j+1][0]; t[2*j+1]=s[j+1][1]; } t[2*j]='\\0'; return t;}","link":"/2018/01/11/shryen11-1-7/"},{"title":"实验11-1-5 字符串的连接（15 分）","text":"实验11-1-5 字符串的连接（15 分）本题要求实现一个函数，将两个字符串连接起来。 函数接口定义：1char *str_cat( char *s, char *t ); 函数str_cat应将字符串t复制到字符串s的末端，并且返回字符串s的首地址。 裁判测试程序样例：1234567891011121314151617181920#include &lt;stdio.h&gt;#include &lt;string.h&gt;#define MAXS 10char *str_cat( char *s, char *t );int main(){ char *p; char str1[MAXS+MAXS] = {'\\0'}, str2[MAXS] = {'\\0'}; scanf(\"%s%s\", str1, str2); p = str_cat(str1, str2); printf(\"%s\\n%s\\n\", p, str1); return 0;}/* 你的代码将被嵌在这里 */ 输入样例：12abcdef 输出样例：12abcdefabcdef 12345678910111213141516171819202122232425#include &lt;stdio.h&gt;#include &lt;string.h&gt;#define MAXS 10char *str_cat( char *s, char *t );int main(){ char *p; char str1[MAXS+MAXS] = {'\\0'}, str2[MAXS] = {'\\0'}; scanf(\"%s%s\", str1, str2); p = str_cat(str1, str2); printf(\"%s\\n%s\\n\", p, str1); return 0;}char *str_cat( char *s, char *t ){ char *p; p=strcat(s,t); return p;}","link":"/2018/01/11/shryen11-1-5/"},{"title":"实验11-1-8 查找子串（20 分）","text":"实验11-1-8 查找子串（20 分）本题要求实现一个字符串查找的简单函数。 函数接口定义：1char *search( char *s, char *t ); 函数search在字符串s中查找子串t，返回子串t在s中的首地址。若未找到，则返回NULL。 裁判测试程序样例：12345678910111213141516171819202122#include &lt;stdio.h&gt;#define MAXS 30char *search(char *s, char *t);void ReadString( char s[] ); /* 裁判提供，细节不表 */int main(){ char s[MAXS], t[MAXS], *pos; ReadString(s); ReadString(t); pos = search(s, t); if ( pos != NULL ) printf(\"%d\\n\", pos - s); else printf(\"-1\\n\"); return 0;}/* 你的代码将被嵌在这里 */ 输入样例1：12The C Programming Languageram 输出样例1：110 输入样例2：12The C Programming Languagebored 输出样例2：1-1 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;stdio.h&gt;#define MAXS 30char *search(char *s, char *t);void ReadString( char s[] ); /* 裁判提供，细节不表 */int main(){ char s[MAXS], t[MAXS], *pos; ReadString(s); ReadString(t); pos = search(s, t); if ( pos != NULL ) printf(\"%d\\n\", pos - s); else printf(\"-1\\n\"); return 0;}void ReadString(char s[]){ gets(s);}char *search(char *s, char *t){ int i, j, sLen, tLen; for (i=0; s[i]!='\\0'; i++); sLen=i; for (j=0; t[j]!='\\0'; j++); tLen=j; i=j=0; while (i &lt; sLen &amp;&amp; j &lt; tLen) { if (s[i] == t[j]) { i++; j++; } else { i = i - j + 1; j = 0; } } if (j == tLen) return &amp;s[i - j]; else return NULL;}","link":"/2018/01/11/shryen11-1-8/"},{"title":"实验11-1-6 指定位置输出字符串（20 分）","text":"实验11-1-6 指定位置输出字符串（20 分）本题要求实现一个函数，对给定的一个字符串和两个字符，打印出给定字符串中从与第一个字符匹配的位置开始到与第二个字符匹配的位置之间的所有字符。 函数接口定义：1char *match( char *s, char ch1, char ch2 ); 函数match应打印s中从ch1到ch2之间的所有字符，并且返回ch1的地址。 裁判测试程序样例：12345678910111213141516171819#include &lt;stdio.h&gt;#define MAXS 10char *match( char *s, char ch1, char ch2 );int main(){ char str[MAXS], ch_start, ch_end, *p; scanf(\"%s\\n\", str); scanf(\"%c %c\", &amp;ch_start, &amp;ch_end); p = match(str, ch_start, ch_end); printf(\"%s\\n\", p); return 0;}/* 你的代码将被嵌在这里 */ 输入样例1：12programr g 输出样例1：12rogrogram 输入样例2：12programz o 输出样例2：12(空行)(空行) 输入样例3：12programg z 输出样例3：12gramgram 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;stdio.h&gt;#define MAXS 10char *match( char *s, char ch1, char ch2 );int main(){ char str[MAXS], ch_start, ch_end, *p; scanf(\"%s\\n\", str); scanf(\"%c %c\", &amp;ch_start, &amp;ch_end); p = match(str, ch_start, ch_end); printf(\"%s\\n\", p); return 0;}char *match(char *s, char ch1, char ch2){ int i, ch1index, ch2index, flag; char *p, ch = '\\0'; flag = 0; ch1index = ch2index = 0; for (i=0; s[i] != '\\0'; i++) { if (s[i] == ch1) { ch1index = i; flag = 1; break; } } if (!flag) { printf(\"\\n\"); p = &amp;ch; return p; } for (; s[i] != '\\0'; i++) { if (s[i] == ch2) { ch2index = i; flag = 0; break; } } for (i=ch1index; i&lt;=ch2index; i++) printf(\"%c\", s[i]); if(flag) { for (i=ch1index; s[i] != '\\0'; i++) printf(\"%c\", s[i]); } printf(\"\\n\"); p = &amp;s[ch1index]; return p;}","link":"/2018/01/11/shryen11-1-6/"},{"title":"实验11-1-9 藏尾诗（20 分）","text":"实验11-1-9 藏尾诗（20 分）本题要求编写一个解密藏尾诗的程序。 输入格式：输入为一首中文藏尾诗，一共四句。每句一行，但句子不一定是等长的，最短一个汉字，最长九个汉字。注意：一个汉字占两个字节。 输出格式：取出每句的最后一个汉字并连接在一起形成一个字符串并输出。同时在末尾输入一个换行符。 输入样例：1234悠悠田园风然而心难平兰花轻涌浪兰香愈幽静 输出样例：1风平浪静 12345678910111213141516171819202122232425#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include \"math.h\"#include \"string.h\"int main(){ char *p[4],str[20]; int i; for(i=0;i&lt;=3;i++){ gets(str); p[i]=(char *)malloc(sizeof(str)+1); strcpy(p[i],str); } int n; for(i=0;i&lt;=3;i++){ n=strlen(p[i]); printf(\"%s\",p[i]+n-2); } return 0;}","link":"/2018/01/11/shryen11-1-9/"},{"title":"实验11-2-1 建立学生信息链表（20 分）","text":"实验11-2-1 建立学生信息链表（20 分）本题要求实现一个将输入的学生成绩组织成单向链表的简单函数。 函数接口定义：1void input(); 该函数利用scanf从输入中获取学生的信息，并将其组织成单向链表。链表节点结构定义如下： 123456struct stud_node { int num; /*学号*/ char name[20]; /*姓名*/ int score; /*成绩*/ struct stud_node *next; /*指向下个结点的指针*/}; 单向链表的头尾指针保存在全局变量head和tail中。 输入为若干个学生的信息（学号、姓名、成绩），当输入学号为0时结束。 裁判测试程序样例：123456789101112131415161718192021222324252627#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;struct stud_node { int num; char name[20]; int score; struct stud_node *next;};struct stud_node *head, *tail;void input();int main(){ struct stud_node *p; head = tail = NULL; input(); for ( p = head; p != NULL; p = p-&gt;next ) printf(\"%d %s %d\\n\", p-&gt;num, p-&gt;name, p-&gt;score); return 0;}/* 你的代码将被嵌在这里 */ 输入样例：123451 zhang 782 wang 803 li 754 zhao 850 输出样例：12341 zhang 782 wang 803 li 754 zhao 85 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;struct stud_node { int num; char name[20]; int score; struct stud_node *next;};struct stud_node *head, *tail;void input();int main(){ struct stud_node *p; head = tail = NULL; input(); for ( p = head; p != NULL; p = p-&gt;next ) printf(\"%d %s %d\\n\", p-&gt;num, p-&gt;name, p-&gt;score); return 0;}void input(){ struct stud_node *q; q=(struct stud_node *)malloc(sizeof(struct stud_node)); scanf(\"%d\", &amp;q-&gt;num); while(q-&gt;num != 0) { scanf(\"%s %d\", q-&gt;name, &amp;q-&gt;score); if(head == NULL) { head = q; head-&gt;next = NULL; } if(tail != NULL) { tail-&gt;next = q; } tail = q; tail-&gt;next = NULL; q=(struct stud_node *)malloc(sizeof(struct stud_node)); scanf(\"%d\", &amp;q-&gt;num); }}","link":"/2018/01/12/shryen11-2-1/"},{"title":"实验11-2-2 学生成绩链表处理（20 分）","text":"实验11-2-2 学生成绩链表处理（20 分）本题要求实现两个函数，一个将输入的学生成绩组织成单向链表；另一个将成绩低于某分数线的学生结点从链表中删除。 函数接口定义：12struct stud_node *createlist();struct stud_node *deletelist( struct stud_node *head, int min_score ); 函数createlist利用scanf从输入中获取学生的信息，将其组织成单向链表，并返回链表头指针。链表节点结构定义如下： 123456struct stud_node { int num; /*学号*/ char name[20]; /*姓名*/ int score; /*成绩*/ struct stud_node *next; /*指向下个结点的指针*/}; 输入为若干个学生的信息（学号、姓名、成绩），当输入学号为0时结束。 函数deletelist从以head为头指针的链表中删除成绩低于min_score的学生，并返回结果链表的头指针。 裁判测试程序样例：12345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;struct stud_node { int num; char name[20]; int score; struct stud_node *next;};struct stud_node *createlist();struct stud_node *deletelist( struct stud_node *head, int min_score );int main(){ int min_score; struct stud_node *p, *head = NULL; head = createlist(); scanf(\"%d\", &amp;min_score); head = deletelist(head, min_score); for ( p = head; p != NULL; p = p-&gt;next ) printf(\"%d %s %d\\n\", p-&gt;num, p-&gt;name, p-&gt;score); return 0;}/* 你的代码将被嵌在这里 */ 输入样例：1234561 zhang 782 wang 803 li 754 zhao 85080 输出样例：122 wang 804 zhao 85 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;struct stud_node { int num; char name[20]; int score; struct stud_node *next;};struct stud_node *createlist();struct stud_node *deletelist( struct stud_node *head, int min_score );int main(){ int min_score; struct stud_node *p, *head = NULL; head = createlist(); scanf(\"%d\", &amp;min_score); head = deletelist(head, min_score); for ( p = head; p != NULL; p = p-&gt;next ) printf(\"%d %s %d\\n\", p-&gt;num, p-&gt;name, p-&gt;score); return 0;}struct stud_node *createlist(){ struct stud_node *head, *tail, *q; head = tail = NULL; int num; scanf (\"%d\", &amp;num); while (num != 0) { q = (struct stud_node *)malloc (sizeof (struct stud_node)); scanf (\"%s %d\", q-&gt;name, &amp;q-&gt;score); q-&gt;num = num; q-&gt;next = NULL; if (head == NULL) head = q; else tail-&gt;next = q; tail = q; scanf (\"%d\", &amp;num); } return head;}struct stud_node *deletelist( struct stud_node *head, int min_score ){ struct stud_node *ptr1, *ptr2; while (head != NULL &amp;&amp; head-&gt;score &lt; min_score) { ptr2 = head; head = head-&gt;next; free(ptr2); } if (head == NULL) return NULL; ptr1 = head; ptr2 = head-&gt;next; while (ptr2 != NULL) { if (ptr2-&gt;score &lt; min_score) { ptr1-&gt;next = ptr2-&gt;next; free(ptr2); } else ptr1 = ptr2; ptr2 = ptr1-&gt;next; } return head;}","link":"/2018/01/12/shryen11-2-2/"},{"title":"实验11-2-3 逆序数据建立链表（20 分）","text":"实验11-2-3 逆序数据建立链表（20 分）本题要求实现一个函数，按输入数据的逆序建立一个链表。 函数接口定义：1struct ListNode *createlist(); 函数createlist利用scanf从输入中获取一系列正整数，当读到−1时表示输入结束。按输入数据的逆序建立一个链表，并返回链表头指针。链表节点结构定义如下： 1234struct ListNode { int data; struct ListNode *next;}; 裁判测试程序样例：1234567891011121314151617181920212223#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;struct ListNode { int data; struct ListNode *next;};struct ListNode *createlist();int main(){ struct ListNode *p, *head = NULL; head = createlist(); for ( p = head; p != NULL; p = p-&gt;next ) printf(\"%d \", p-&gt;data); printf(\"\\n\"); return 0;}/* 你的代码将被嵌在这里 */ 输入样例：11 2 3 4 5 6 7 -1 输出样例：17 6 5 4 3 2 1 123456789101112131415161718192021222324252627282930313233343536#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;struct ListNode { int data; struct ListNode *next;};struct ListNode *createlist();int main(){ struct ListNode *p, *head = NULL; head = createlist(); for ( p = head; p != NULL; p = p-&gt;next ) printf(\"%d \", p-&gt;data); printf(\"\\n\"); return 0;}struct ListNode *createlist(){ struct ListNode *head = NULL, *now = NULL; int a; while (1) { scanf(\"%d\", &amp;a); if (a == -1)return head; now = (struct ListNode*)malloc(sizeof(struct ListNode)); now-&gt;data = a; now-&gt;next = head; head = now; }}","link":"/2018/01/12/shryen11-2-3/"},{"title":"实验11-2-6 奇数值结点链表（20 分）","text":"实验11-2-6 奇数值结点链表（20 分）本题要求实现两个函数，分别将读入的数据存储为单链表、将链表中奇数值的结点重新组成一个新的链表。链表结点定义如下： 1234struct ListNode { int data; ListNode *next;}; 函数接口定义：12struct ListNode *readlist();struct ListNode *getodd( struct ListNode **L ); 函数readlist从标准输入读入一系列正整数，按照读入顺序建立单链表。当读到−1时表示输入结束，函数应返回指向单链表头结点的指针。 函数getodd将单链表L中奇数值的结点分离出来，重新组成一个新的链表。返回指向新链表头结点的指针，同时将L中存储的地址改为删除了奇数值结点后的链表的头结点地址（所以要传入L的指针）。 裁判测试程序样例：1234567891011121314151617181920212223242526272829303132#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;struct ListNode { int data; struct ListNode *next;};struct ListNode *readlist();struct ListNode *getodd( struct ListNode **L );void printlist( struct ListNode *L ){ struct ListNode *p = L; while (p) { printf(\"%d \", p-&gt;data); p = p-&gt;next; } printf(\"\\n\");}int main(){ struct ListNode *L, *Odd; L = readlist(); Odd = getodd(&amp;L); printlist(Odd); printlist(L); return 0;}/* 你的代码将被嵌在这里 */ 输入样例：11 2 2 3 4 5 6 7 -1 输出样例：121 3 5 7 2 2 4 6 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;struct ListNode { int data; struct ListNode *next;};struct ListNode *readlist();struct ListNode *getodd( struct ListNode **L );void printlist( struct ListNode *L ){ struct ListNode *p = L; while (p) { printf(\"%d \", p-&gt;data); p = p-&gt;next; } printf(\"\\n\");}int main(){ struct ListNode *L, *Odd; L = readlist(); Odd = getodd(&amp;L); printlist(Odd); printlist(L); return 0;}void PushBack(int X, struct ListNode **rear){ struct ListNode *TmpCell; TmpCell = malloc(sizeof(struct ListNode)); TmpCell-&gt;data = X; TmpCell-&gt;next = NULL; (*rear)-&gt;next = TmpCell; *rear = TmpCell;}struct ListNode *readlist(){ struct ListNode *TmpCell, *head, *tail; int data; head = tail = malloc(sizeof(struct ListNode)); head-&gt;next = NULL; scanf(\"%d\", &amp;data); while (data != -1) { PushBack(data, &amp;tail); scanf(\"%d\", &amp;data); } TmpCell = head; head = head-&gt;next; free(TmpCell); return head;}struct ListNode *getodd(struct ListNode **L){ struct ListNode *head, *p, *oddhead, *oddtail, *TmpCell; p = head = malloc(sizeof(struct ListNode)); head-&gt;next = NULL; oddhead = oddtail = malloc(sizeof(struct ListNode)); oddhead-&gt;next = NULL; p-&gt;next = *L; while (p-&gt;next != NULL) { if (p-&gt;next-&gt;data % 2 != 0) { PushBack(p-&gt;next-&gt;data, &amp;oddtail); TmpCell = p-&gt;next; p-&gt;next = TmpCell-&gt;next; free(TmpCell); } else p = p-&gt;next; } TmpCell = head; head = head-&gt;next; free(TmpCell); *L = head; TmpCell = oddhead; oddhead = oddhead-&gt;next; free(TmpCell); return oddhead;}","link":"/2018/01/12/shryen11-2-6/"},{"title":"实验11-2-5 链表拼接（20 分）","text":"实验11-2-5 链表拼接（20 分）本题要求实现一个合并两个有序链表的简单函数。链表结点定义如下： 1234struct ListNode { int data; struct ListNode *next;}; 函数接口定义：1struct ListNode *mergelists(struct ListNode *list1, struct ListNode *list2); 其中list1和list2是用户传入的两个按data升序链接的链表的头指针；函数mergelists将两个链表合并成一个按data升序链接的链表，并返回结果链表的头指针。 裁判测试程序样例：123456789101112131415161718192021222324252627282930313233#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;struct ListNode { int data; struct ListNode *next;};struct ListNode *createlist(); /*裁判实现，细节不表*/struct ListNode *mergelists(struct ListNode *list1, struct ListNode *list2);void printlist( struct ListNode *head ){ struct ListNode *p = head; while (p) { printf(\"%d \", p-&gt;data); p = p-&gt;next; } printf(\"\\n\");}int main(){ struct ListNode *list1, *list2; list1 = createlist(); list2 = createlist(); list1 = mergelists(list1, list2); printlist(list1); return 0;}/* 你的代码将被嵌在这里 */ 输入样例：121 3 5 7 -12 4 6 -1 输出样例：11 2 3 4 5 6 7 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;struct ListNode { int data; struct ListNode *next;};struct ListNode *createlist(); /*裁判实现，细节不表*/struct ListNode *mergelists(struct ListNode *list1, struct ListNode *list2);void printlist( struct ListNode *head ){ struct ListNode *p = head; while (p) { printf(\"%d \", p-&gt;data); p = p-&gt;next; } printf(\"\\n\");}int main(){ struct ListNode *list1, *list2; list1 = createlist(); list2 = createlist(); list1 = mergelists(list1, list2); printlist(list1); return 0;}struct ListNode *createlist(){ struct ListNode *p,*h,*q; p=q=(struct ListNode*)malloc(sizeof(struct ListNode)); h=(struct ListNode*)malloc(sizeof(struct ListNode)); int data; //存放数据 h=p; //h为头节点 scanf(\"%d\",&amp;data); while(data!=-1) { p-&gt;data=data; //保存数据 q-&gt;next=p; //p指向下一个节点 q=p; p=(struct ListNode*)malloc(sizeof(struct ListNode)); scanf(\"%d\",&amp;data); } q-&gt;next=NULL; //尾节点Next指向空 free(p); return h;}struct ListNode *mergelists(struct ListNode *list1, struct ListNode *list2){ int num = 0; int temp[100]; struct ListNode *p = list1; while(p != NULL) { temp[num] = p-&gt;data; num++; p = p-&gt;next; } p = list2; while(p != NULL) { temp[num] = p-&gt;data; num++; p = p-&gt;next; } int i,j; for(i = 0; i &lt; num; i++) for(j = i + 1; j &lt; num; j++) { if(temp[i] &gt; temp[j]) { int t; t = temp[i]; temp[i] = temp[j]; temp[j] = t; } } struct ListNode *newlist = NULL; struct ListNode *endlist = NULL; struct ListNode *q; for(i = 0; i &lt; num; i++) { q = (struct ListNode *)malloc(sizeof(struct ListNode)); q-&gt;data = temp[i]; if(newlist == NULL) { newlist = q; newlist-&gt;next = NULL; } if(endlist != NULL) { endlist-&gt;next = q; } endlist = q; endlist-&gt;next = NULL; } return newlist;}","link":"/2018/01/12/shryen11-2-5/"},{"title":"实验11-2-4 删除单链表偶数节点（20 分）","text":"实验11-2-4 删除单链表偶数节点（20 分）本题要求实现两个函数，分别将读入的数据存储为单链表、将链表中偶数值的结点删除。链表结点定义如下： 1234struct ListNode { int data; struct ListNode *next;}; 函数接口定义：12struct ListNode *createlist();struct ListNode *deleteeven( struct ListNode *head ); 函数createlist从标准输入读入一系列正整数，按照读入顺序建立单链表。当读到−1时表示输入结束，函数应返回指向单链表头结点的指针。 函数deleteeven将单链表head中偶数值的结点删除，返回结果链表的头指针。 裁判测试程序样例：1234567891011121314151617181920212223242526272829303132#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;struct ListNode { int data; struct ListNode *next;};struct ListNode *createlist();struct ListNode *deleteeven( struct ListNode *head );void printlist( struct ListNode *head ){ struct ListNode *p = head; while (p) { printf(\"%d \", p-&gt;data); p = p-&gt;next; } printf(\"\\n\");}int main(){ struct ListNode *head; head = createlist(); head = deleteeven(head); printlist(head); return 0;}/* 你的代码将被嵌在这里 */ 输入样例：11 2 2 3 4 5 6 7 -1 输出样例：11 3 5 7 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;struct ListNode { int data; struct ListNode *next;};struct ListNode *createlist();struct ListNode *deleteeven( struct ListNode *head );void printlist( struct ListNode *head ){ struct ListNode *p = head; while (p) { printf(\"%d \", p-&gt;data); p = p-&gt;next; } printf(\"\\n\");}int main(){ struct ListNode *head; head = createlist(); head = deleteeven(head); printlist(head); return 0;}struct ListNode *createlist(){ struct ListNode *p,*h,*q; p=q=(struct ListNode*)malloc(sizeof(struct ListNode)); h=(struct ListNode*)malloc(sizeof(struct ListNode)); int data; //存放数据 h=p; //h为头节点 scanf(\"%d\",&amp;data); while(data!=-1) { p-&gt;data=data; //保存数据 q-&gt;next=p; //p指向下一个节点 q=p; p=(struct ListNode*)malloc(sizeof(struct ListNode)); scanf(\"%d\",&amp;data); } q-&gt;next=NULL; //尾节点Next指向空 free(p); return h;}struct ListNode *deleteeven( struct ListNode *head ){ struct ListNode *p,*q; p=q=(struct ListNode*)malloc(sizeof(struct ListNode)); p=head; q-&gt;next=p; while(p!=NULL) { if(!(p-&gt;data%2)) //能被二整除的为偶数 { if(p==head) //如果p是第一个节点就删除头节点，保留头指向的下一个节点作为头 { head=head-&gt;next; p=head; q-&gt;next=p; continue; } q-&gt;next=p-&gt;next; //直接跳过偶数节点 } else //缺少else会导致重复偶数删除不了 q=p; p=p-&gt;next; } free(p); return head;}","link":"/2018/01/12/shryen11-2-4/"},{"title":"实验11-2-8 单链表结点删除（20 分）","text":"实验11-2-8 单链表结点删除（20 分）本题要求实现两个函数，分别将读入的数据存储为单链表、将链表中所有存储了某给定值的结点删除。链表结点定义如下： 1234struct ListNode { int data; ListNode *next;}; 函数接口定义：12struct ListNode *readlist();struct ListNode *deletem( struct ListNode *L, int m ); 函数readlist从标准输入读入一系列正整数，按照读入顺序建立单链表。当读到−1时表示输入结束，函数应返回指向单链表头结点的指针。 函数deletem将单链表L中所有存储了m的结点删除。返回指向结果链表头结点的指针。 裁判测试程序样例：1234567891011121314151617181920212223242526272829303132#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;struct ListNode { int data; struct ListNode *next;};struct ListNode *readlist();struct ListNode *deletem( struct ListNode *L, int m );void printlist( struct ListNode *L ){ struct ListNode *p = L; while (p) { printf(\"%d \", p-&gt;data); p = p-&gt;next; } printf(\"\\n\");}int main(){ int m; struct ListNode *L = readlist(); scanf(\"%d\", &amp;m); L = deletem(L, m); printlist(L); return 0;}/* 你的代码将被嵌在这里 */ 输入样例：1210 11 10 12 10 -110 输出样例：111 12 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;struct ListNode { int data; struct ListNode *next;};struct ListNode *readlist();struct ListNode *deletem( struct ListNode *L, int m );void printlist( struct ListNode *L ){ struct ListNode *p = L; while (p) { printf(\"%d \", p-&gt;data); p = p-&gt;next; } printf(\"\\n\");}int main(){ int m; struct ListNode *L = readlist(); scanf(\"%d\", &amp;m); L = deletem(L, m); printlist(L); return 0;}void PushBack(int X, struct ListNode **rear){ struct ListNode *TmpCell; TmpCell = malloc(sizeof(struct ListNode)); TmpCell-&gt;data = X; TmpCell-&gt;next = NULL; (*rear)-&gt;next = TmpCell; *rear = TmpCell;}struct ListNode *readlist(){ struct ListNode *TmpCell, *head, *tail; int data; head = tail = malloc(sizeof(struct ListNode)); head-&gt;next = NULL; scanf(\"%d\", &amp;data); while (data != -1) { PushBack(data, &amp;tail); scanf(\"%d\", &amp;data); } TmpCell = head; head = head-&gt;next; free(TmpCell); return head;}struct ListNode *deletem(struct ListNode *L, int m){ struct ListNode *head, *p, *TmpCell; p = head = malloc(sizeof(struct ListNode)); head-&gt;next = NULL; p-&gt;next = L; while (p-&gt;next != NULL) { if (p-&gt;next-&gt;data == m) { TmpCell = p-&gt;next; p-&gt;next = TmpCell-&gt;next; free(TmpCell); } else p = p-&gt;next; } TmpCell = head; head = head-&gt;next; free(TmpCell); return head;}","link":"/2018/01/12/shryen11-2-8/"},{"title":"实验11-2-7 统计专业人数（15 分）","text":"实验11-2-7 统计专业人数（15 分）本题要求实现一个函数，统计学生学号链表中专业为计算机的学生人数。链表结点定义如下： 1234struct ListNode { char code[8]; struct ListNode *next;}; 这里学生的学号共7位数字，其中第2、3位是专业编号。计算机专业的编号为02。 函数接口定义：1int countcs( struct ListNode *head ); 其中head是用户传入的学生学号链表的头指针；函数countcs统计并返回head链表中专业为计算机的学生人数。 裁判测试程序样例：1234567891011121314151617181920212223#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;struct ListNode { char code[8]; struct ListNode *next;};struct ListNode *createlist(); /*裁判实现，细节不表*/int countcs( struct ListNode *head );int main(){ struct ListNode *head; head = createlist(); printf(\"%d\\n\", countcs(head)); return 0;}/* 你的代码将被嵌在这里 */ 输入样例：1234567102120220223108102134103091231102034021205# 输出样例：13 1234567891011int countcs(struct ListNode *head){ int i=0; while(head!=NULL) { if(head-&gt;code[1]=='0' &amp;&amp; head-&gt;code[2]=='2') i++; head=head-&gt;next; } return i;}","link":"/2018/01/12/shryen11-2-7/"},{"title":"实验2-1-2 温度转换（5 分）","text":"实验2-1-2 温度转换（5 分）本题要求编写程序，计算华氏温度150°F对应的摄氏温度。计算公式：$C=5\\times(F−32)\\div9$，式中：C表示摄氏温度，F表示华氏温度，输出数据要求为整型。 输入格式:本题目没有输入。 输出格式:按照下列格式输出 1fahr = 150, celsius = 计算所得摄氏温度的整数值 123456789#include&lt;stdio.h&gt; int main(void) { int celsius, fahr; fahr=150; celsius=5 * ( fahr - 32 ) / 9; printf(\"fahr = 150, celsius = %d\\n\", celsius); return 0; }","link":"/2017/10/19/shryen2-1-2/"},{"title":"实验2-1-4 计算平均分（5 分）","text":"实验2-1-4 计算平均分（5 分）已知某位学生的数学、英语和计算机课程的成绩分别是87分、72分和93分，求该生3门课程的平均成绩（结果按整型输出）。 输入格式：本题无输入 12 输出格式：按照下列格式输出结果： 1math = 87, eng = 72, comp = 93, average = 计算所得的平均成绩 123456789#include&lt;stdio.h&gt; int main(void) { int math,eng,comp,average; math=87; eng=72; comp=93; average=(math+eng+comp)/3; printf(\"math = 87, eng = 72, comp = 93, average = %d\\n\",average); return 0; }","link":"/2017/10/19/shryen2-1-4/"},{"title":"实验2-1-5 将x的平方赋值给y（5 分）","text":"实验2-1-5 将x的平方赋值给y（5 分）假设x的值为3，计算x的平方并赋值给y，分别以“$y = x \\times x$”和“$x \\times x = y$”的形式输出x和y的值。 输入格式：本题无输入 输出格式：按照下列格式输出代入x=3的结果： 12y = x * xx * x = y 12345678#include&lt;stdio.h&gt; int main(void) { int x,y; x=3; y=x*x; printf(\"%d = %d * %d\\n\",y,x,x); printf(\"%d * %d = %d\\n\",x,x,y); return 0; }","link":"/2017/10/19/shryen2-1-5/"},{"title":"实验2-1-3 计算物体自由下落的距离（5 分）","text":"实验2-1-3 计算物体自由下落的距离（5 分）一个物体从100米的高空自由落下。编写程序，求它在前3秒内下落的垂直距离。设重力加速度为10米/$秒^2$。 输入格式:本题目没有输入。 输出格式:按照下列格式输出 1height = 垂直距离值 结果保留2位小数。 12345678#include&lt;stdio.h&gt;int main(void){ float height; height = 5 * 3 * 3 ; printf(\"height = %.2f\", height); return 0;}","link":"/2017/10/19/shryen2-1-3/"},{"title":"实验2-1-6 计算华氏温度（5 分）","text":"实验2-1-6 计算华氏温度（5 分）本题要求编写程序，计算摄氏温度26°C 对应的华氏温度。计算公式：$F=9\\times C\\div5+32$，式中：C表示摄氏温度，F表示华氏温度，输出数据要求为整型。 输入格式:本题目没有输入。 输出格式:按照下列格式输出 1celsius = 26, fahr = 对应的华氏温度整数值 12345678#include&lt;stdio.h&gt; int main(void) { int celsius, fahr; celsius=26; fahr=9*celsius/5+32; printf(\"celsius = 26, fahr = %d\\n\", fahr); return 0; }","link":"/2017/10/19/shryen2-1-6/"},{"title":"实验2-2-1 计算分段函数[1]（10 分）","text":"实验2-2-1 计算分段函数[1]（10 分）本题目要求计算下列分段函数f(x)的值： $$y=f(x)=\\begin{cases}\\frac{1}{x}, &amp; x \\neq 0 \\\\\\\\0, &amp; x = 0\\end{cases}$$输入格式: 输入在一行中给出实数x。 输出格式:在一行中按“f(x) = result”的格式输出，其中x与result都保留一位小数。 输入样例1:110 输出样例1:1f(10.0) = 0.1 输入样例2:10 输出样例2:1f(0.0) = 0.0 12345678910111213#include&lt;stdio.h&gt; int main(void) { float x,y; scanf(\"%f\",&amp;x); if(x != 0){ y=1 / x; }else{ y=0; } printf(\"f(%.1f) = %.1f\",x,y); return 0; }","link":"/2017/10/19/shryen2-2-1/"},{"title":"实验2-1-7 整数152的各位数字（10 分）","text":"实验2-1-7 整数152的各位数字（10 分）本题要求编写程序，输出整数152的个位数字、十位数字和百位数字的值。 输入格式：本题无输入。 输出格式：按照以下格式输出： 1152 = 个位数字 + 十位数字*10 + 百位数字*100 12345678910#include&lt;stdio.h&gt; int main(void) { int c=152; int gewei,shiwei,baiwei; gewei=c%10; shiwei=c/10%10; baiwei=c/100%10; printf(\"152 = %d + %d*10 + %d*100\",gewei,shiwei,baiwei); return 0; }","link":"/2017/10/19/shryen2-1-7/"},{"title":"实验11-2-9 链表逆置（20 分）","text":"实验11-2-9 链表逆置（20 分）本题要求实现一个函数，将给定单向链表逆置，即表头置为表尾，表尾置为表头。链表结点定义如下： 1234struct ListNode { int data; struct ListNode *next;}; 函数接口定义：1struct ListNode *reverse( struct ListNode *head ); 其中head是用户传入的链表的头指针；函数reverse将链表head逆置，并返回结果链表的头指针。 裁判测试程序样例：1234567891011121314151617181920212223242526272829303132#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;struct ListNode { int data; struct ListNode *next;};struct ListNode *createlist(); /*裁判实现，细节不表*/struct ListNode *reverse( struct ListNode *head );void printlist( struct ListNode *head ){ struct ListNode *p = head; while (p) { printf(\"%d \", p-&gt;data); p = p-&gt;next; } printf(\"\\n\");}int main(){ struct ListNode *head; head = createlist(); head = reverse(head); printlist(head); return 0;}/* 你的代码将被嵌在这里 */ 输入样例：11 2 3 4 5 6 -1 输出样例：16 5 4 3 2 1 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;struct ListNode { int data; struct ListNode *next;};struct ListNode *createlist(); /*裁判实现，细节不表*/struct ListNode *reverse( struct ListNode *head );void printlist( struct ListNode *head ){ struct ListNode *p = head; while (p) { printf(\"%d \", p-&gt;data); p = p-&gt;next; } printf(\"\\n\");}int main(){ struct ListNode *head; head = createlist(); head = reverse(head); printlist(head); return 0;}struct ListNode *createlist(){ struct ListNode *p,*h,*q; p=q=(struct ListNode*)malloc(sizeof(struct ListNode)); h=(struct ListNode*)malloc(sizeof(struct ListNode)); int data; //存放数据 h=p; //h为头节点 scanf(\"%d\",&amp;data); while(data!=-1) { p-&gt;data=data; //保存数据 q-&gt;next=p; //p指向下一个节点 q=p; p=(struct ListNode*)malloc(sizeof(struct ListNode)); scanf(\"%d\",&amp;data); } q-&gt;next=NULL; //尾节点Next指向空 free(p); return h;} struct ListNode *reverse( struct ListNode *head ){ struct ListNode *p,*q=NULL,*r=NULL; if(head==NULL) { return NULL; } if(head-&gt;next==NULL) { return head; } p=head; while(p!=NULL) { q=p-&gt;next; p-&gt;next=r; r=p; p=q; } return r;} TmpCell = head; head = head-&gt;next; free(TmpCell); return head;}","link":"/2018/01/12/shryen11-2-9/"},{"title":"实验2-1-1 计算摄氏温度（5 分）","text":"实验2-1-1 计算摄氏温度（5 分）$C=5\\times(F−32)\\div9$，式中：C表示摄氏温度，F表示华氏温度，输出数据要求为整型。 输入格式:本题目没有输入。 输出格式:按照下列格式输出 1fahr = 100, celsius = 计算所得摄氏温度的整数值 123456789#include&lt;stdio.h&gt; int main(void) { int celsius, fahr; fahr=100; celsius=5*(fahr-32)/9; printf(\"fahr = 100, celsius = %d\\n\", celsius); return 0; }","link":"/2017/10/19/shryen2-1-1/"},{"title":"实验2-2-3 计算存款利息（10 分）","text":"实验2-2-3 计算存款利息（10 分）本题目要求计算存款利息，计算公式为$interest=money\\times(1+rate)^{year}−money$，其中interest为存款到期时的利息（税前），money是存款金额，year是存期，rate是年利率。 输入格式：输入在一行中顺序给出三个正实数money、year和rate，以空格分隔。 输出格式：在一行中按“interest = 利息”的格式输出，其中利息保留两位小数。 输入样例：11000 3 0.025 输出样例：1interest = 76.89 12345678910#include&lt;stdio.h&gt;#include&lt;math.h&gt;int main(void){ float interest,year,rate,money; scanf(\"%f %f %f\",&amp;money,&amp;year,&amp;rate); interest = money * pow(1 + rate,year) - money; printf(\"interest = %.2f\",interest); return 0;}","link":"/2017/10/19/shryen2-2-3/"},{"title":"实验2-2-5 求整数均值（10 分）","text":"实验2-2-5 求整数均值（10 分）本题要求编写程序，计算4个整数的和与平均值。题目保证输入与输出均在整型范围内。 输入格式:输入在一行中给出4个整数，其间以空格分隔。 输出格式:在一行中按照格式“Sum = 和; Average = 平均值”顺序输出和与平均值，其中平均值精确到小数点后一位。 输入样例:11 2 3 4 输出样例:1Sum = 10; Average = 2.5 1234567891011#include&lt;stdio.h&gt; int main(void) { int a,b,c,d,S; float A; scanf(\"%d%d%d%d\",&amp;a,&amp;b,&amp;c,&amp;d); S=(a+b+c+d); A=(a+b+c+d)/4.0; printf(\"Sum = %d; Average = %.1f\",S,A); return 0; }","link":"/2017/10/20/shryen2-2-5/"},{"title":"实验2-2-2 计算摄氏温度（10 分）","text":"实验2-2-2 计算摄氏温度（10 分）给定一个华氏温度F，本题要求编写程序，计算对应的摄氏温度C。计算公式：$C=5\\times(F−32)\\div9$。题目保证输入与输出均在整型范围内。 输入格式:输入在一行中给出一个华氏温度。 输出格式:在一行中按照格式“Celsius = C”输出对应的摄氏温度C的整数值。 输入样例:1150 输出样例:1Celsius = 65 123456789#include&lt;stdio.h&gt; int main(void) { int celsius, fahr; scanf(\"%d\",&amp;fahr); celsius=5*(fahr-32)/9; printf(\"Celsius = %d\\n\", celsius); return 0; }","link":"/2017/10/19/shryen2-2-2/"},{"title":"实验2-2-4 计算分段函数[2]（10 分）","text":"实验2-2-4 计算分段函数[2]（10 分）本题目要求计算下列分段函数f(x)的值：$$f(x)=\\begin{cases}x^{0.5}, &amp; \\text{$x \\ge 0$时} \\\\\\(x+1)^2+2x+\\frac{1}{x}, &amp; \\text{$x \\lt 0$时} \\end{cases}$$注：可在头文件中包含math.h，并调用sqrt函数求平方根，调用pow函数求幂。 输入格式:输入在一行中给出实数x。 输出格式:在一行中按“f(x) = result”的格式输出，其中x与result都保留两位小数。 输入样例1:110 输出样例1:1f(10.00) = 3.16 输入样例2:1-0.5 输出样例2:1f(-0.50) = -2.75 12345678910111213#include&lt;stdio.h&gt;#include&lt;math.h&gt; int main(void){ double x,re; scanf(\"%lf\",&amp;x); if(x &gt;= 0){ re=pow( x, 0.5 ); }else{ re=pow( x + 1,2 ) + 2 * x + 1.0 / x; } printf(\"f(%.2f) = %.2f\",x,re);}","link":"/2017/10/19/shryen2-2-4/"},{"title":"实验2-2-7 整数四则运算（10 分）","text":"实验2-2-7 整数四则运算（10 分）本题要求编写程序，计算2个正整数的和、差、积、商并输出。题目保证输入和输出全部在整型范围内。 输入格式:输入在一行中给出2个正整数A和B。 输出格式:在4行中按照格式“A 运算符 B = 结果”顺序输出和、差、积、商。 输入样例:13 2 输出样例:12343 + 2 = 53 - 2 = 13 * 2 = 63 / 2 = 1 1234567891011121314#include&lt;stdio.h&gt; main(void) { int x,y,a,b,c,d; scanf(\"%d%d\",&amp;x,&amp;y); a=x+y; b=x-y; c=x*y; d=x/y; printf(\"%d + %d = %d\\n\",x,y,a); printf(\"%d - %d = %d\\n\",x,y,b); printf(\"%d * %d = %d\\n\",x,y,c); printf(\"%d / %d = %d\\n\",x,y,d); return 0;}","link":"/2017/10/22/shryen2-2-7/"},{"title":"实验2-2-6 计算分段函数[3]（10 分）","text":"实验2-2-6 计算分段函数[3]（10 分）本题目要求计算下列分段函数f(x)的值：$$y=f(x)=\\begin{cases}x, &amp; x \\neq 10 \\\\\\\\\\frac{1}{x}, &amp; x = 10\\end{cases}$$ 输入格式：输入在一行中给出实数x。 输出格式：在一行中按“f(x) = result”的格式输出，其中x与result都保留一位小数。 输入样例1：110 输出样例1：1f(10.0) = 0.1 输入样例2：1234 输出样例2：1f(234.0) = 234.0 123456789101112#include&lt;stdio.h&gt; int main(void) { float x,y; scanf(\"%f\",&amp;x); if(x!=10){ y=x; }else{ y=1/x; } printf(\"f(%.1f) = %.1f\",x,y); return 0; }","link":"/2017/10/20/shryen2-2-6/"},{"title":"实验2-2-8 阶梯电价（15 分）","text":"实验2-2-8 阶梯电价（15 分）为了提倡居民节约用电，某省电力公司执行“阶梯电价”，安装一户一表的居民用户电价分为两个“阶梯”：月用电量50千瓦时（含50千瓦时）以内的，电价为0.53元/千瓦时；超过50千瓦时的，超出部分的用电量，电价上调0.05元/千瓦时。请编写程序计算电费。 输入格式:输入在一行中给出某用户的月用电量（单位：千瓦时）。 输出格式:在一行中输出该用户应支付的电费（元），结果保留两位小数，格式如：“cost = 应付电费值”；若用电量小于0，则输出”Invalid Value!”。 输入样例1:110 输出样例1:1cost = 5.30 输入样例2:1100 输出样例2:1cost = 55.50 12345678910111213141516#include&lt;stdio.h&gt; int main(void) { float x,c; scanf(\"%f\",&amp;x); if(x&gt;=0){ if(x&lt;=50){ c=0.53*x; }else{ c=0.53*50+(x-50)*0.58; printf(\"cost = %.2f\",c); } }else{ printf(\"Invalid Value!\"); } return 0; }","link":"/2017/10/22/shryen2-2-8/"},{"title":"实验2-2-9 计算火车运行时间（15 分）","text":"实验2-2-9 计算火车运行时间（15 分）本题要求根据火车的出发时间和达到时间，编写程序计算整个旅途所用的时间。 输入格式：输入在一行中给出2个4位正整数，其间以空格分隔，分别表示火车的出发时间和到达时间。每个时间的格式为2位小时数（00-23）和2位分钟数（00-59），假设出发和到达在同一天内。 输出格式：在一行输出该旅途所用的时间，格式为“hh:mm”，其中hh为2位小时数、mm为2位分钟数。 输入样例：11201 1530 输出样例：103:29 123456789101112#include&lt;stdio.h&gt; int main(void){ int start,arrive,s,a,m,hh,mm; scanf(\"%d%d\",&amp;start,&amp;arrive); s=start/100*60+start%100; a=arrive/100*60+arrive%100; m=a-s; hh=m/60; mm=m%60; printf(\"%02d:%02d\",hh,mm); return 0; }","link":"/2017/10/22/shryen2-2-9/"},{"title":"实验2-3-1 求1到100的和（10 分）","text":"实验2-3-1 求1到100的和（10 分）本题要求编写程序，计算表达式 $1 + 2 + 3 + \\cdots + 100$ 的值。 输入格式：本题无输入。 输出格式：按照以下格式输出： 1sum = 累加和 12345678910#include&lt;stdio.h&gt; int main(void) { int i,s=0; for(i=1;i&lt;=100;i++) { s=s+i; } printf(\"sum = %d\",s); return 0; }","link":"/2017/10/22/shryen2-3-1/"},{"title":"实验2-3-2 求N分之一序列前N项和（15 分）","text":"实验2-3-2 求N分之一序列前N项和（15 分）本题要求编写程序，计算序列$ 1 + \\frac{1}{2} + \\frac{1}{3} + \\cdots$ 的前N项之和。 输入格式:输入在一行中给出一个正整数N。 输出格式:在一行中按照“sum = S”的格式输出部分和的值S，精确到小数点后6位。题目保证计算结果不超过双精度范围。 输入样例:16 输出样例:1sum = 2.450000 123456789101112#include&lt;stdio.h&gt; int main(void) { int N,i; double s=0,item; scanf(\"%d\",&amp;N); for(i=1;i&lt;=N;i++) { item=1.0/i; s=s+item; } printf(\"sum = %.6lf\",s); return 0; }","link":"/2017/10/22/shryen2-3-2/"},{"title":"实验2-3-3 求奇数分之一序列前N项和（15 分）","text":"实验2-3-3 求奇数分之一序列前N项和（15 分）本题要求编写程序，计算序列 $1 +\\frac{1}{3} + \\frac{1}{5} + \\cdots$ 的前N项之和。 输入格式:输入在一行中给出一个正整数N。 输出格式:在一行中按照“sum = S”的格式输出部分和的值S，精确到小数点后6位。题目保证计算结果不超过双精度范围。 输入样例:123 输出样例:1sum = 2.549541 1234567891011#include&lt;stdio.h&gt; int main(void) { int N,i; double s=0,item; scanf(\"%d\",&amp;N); for(i=1;i&lt;=N;i++) { item=1.0/(2*i-1); s=s+item; } printf(\"sum = %.6lf\",s); return 0; }","link":"/2017/10/23/shryen2-3-3/"},{"title":"实验2-3-4 求简单交错序列前N项和（15 分）","text":"实验2-3-4 求简单交错序列前N项和（15 分）本题要求编写程序,计算序列 $1 - \\frac{1}{4} +\\frac{1}{7} - \\frac{1}{10} + \\cdots$ 的前N项之和。 输入格式:输入在一行中给出一个正整数N。 输出格式:在一行中按照“sum = S”的格式输出部分和的值S，精确到小数点后三位。题目保证计算结果不超过双精度范围。 输入样例:110 输出样例:1sum = 0.819 1234567891011121314#include&lt;stdio.h&gt; int main(void) { int N,i,flag=1,fm=1; double s=0,item; scanf(\"%d\",&amp;N); for(i=1;i&lt;=N;i++) { item=flag*1.0/fm; s=s+item; flag=-flag; fm=fm+3; } printf(\"sum = %.3lf\",s); return 0; }","link":"/2017/10/23/shryen2-3-4/"},{"title":"实验2-3-5 输出华氏-摄氏温度转换表（15 分）","text":"实验2-3-5 输出华氏-摄氏温度转换表（15 分）输入2个正整数$lower$和$upper（lower\\leq upper\\leq 100）$，请输出一张取值范围为$[lower，upper]$、且每次增加2华氏度的华氏-摄氏温度转换表。 温度转换的计算公式：$C=5\\times(F−32)\\div9$，其中：C表示摄氏温度，F表示华氏温度。 输入格式:在一行中输入2个整数，分别表示$lower$和$upper$的值，中间用空格分开。 输出格式:第一行输出：”fahr celsius” 接着每行输出一个华氏温度fahr（整型）与一个摄氏温度celsius（占据6个字符宽度，靠右对齐，保留1位小数）。 若输入的范围不合法，则输出”Invalid.”。 输入样例1:132 35 输出样例1:123fahr celsius32 0.034 1.1 输入样例2:140 30 输出样例2:1Invalid. 123456789101112131415#include&lt;stdio.h&gt; int main(void) { int fahr,lower,upper; double celsius; scanf(\"%d%d\",&amp;lower,&amp;upper); if(lower&lt;=upper &amp;&amp; upper&lt;=100){ printf(\"fahr celsius\\n\"); for (fahr = lower;fahr&lt;= upper;fahr=fahr+2){ celsius = (5.0/9.0)*(fahr-32); printf(\"%d%6.1f\\n\" ,fahr,celsius); } }else printf(\"Invalid.\\n\"); return 0; }","link":"/2017/10/23/shryen2-3-5/"},{"title":"实验2-3-7 求平方与倒数序列的部分和（15 分）","text":"实验2-3-7 求平方与倒数序列的部分和（15 分）本题要求对两个正整数m和n（m≤n）编写程序，计算序列和$m^2+\\frac{1}{m} +(m+1)^2+\\frac{1}{(m+1)} +⋯+n^2+\\frac{1}{n} $。 输入格式:输入在一行中给出两个正整数$m$和$n（m\\leq n）$，其间以空格分开。 输出格式:在一行中按照“sum = S”的格式输出部分和的值S，精确到小数点后六位。题目保证计算结果不超过双精度范围。 输入样例:15 10 输出样例:1sum = 355.845635 123456789101112131415#include&lt;stdio.h&gt; int main(void) { int N,i,fm,M; double s=0,item; scanf(\"%d%d\",&amp;M,&amp;N); fm=M; for(i=M;i&lt;=N;i++) { item=fm*fm+1.0/fm; s=s+item; fm=fm+1; } printf(\"sum = %.6lf\",s); return 0; }","link":"/2017/10/23/shryen2-3-7/"},{"title":"实验2-3-6 求交错序列前N项和（15 分）","text":"实验2-3-6 求交错序列前N项和（15 分）本题要求编写程序，计算交错序列 $1-\\frac{2}{3} +\\frac{3}{5} -\\frac{4}{7} +\\frac{5}{9} -\\frac{6}{11} +\\cdots$ 的前N项之和。 输入格式:输入在一行中给出一个正整数N。 输出格式:在一行中输出部分和的值，结果保留三位小数。 输入样例:15 输出样例:10.917 1234567891011121314#include&lt;stdio.h&gt; int main(void) { int N,i,fm,flag; double s=0,item; scanf(\"%d\",&amp;N); fm=1; flag=1; for(i=1;i&lt;=N;i++) { item=flag*i*1.0/fm; s=s+item; flag=-flag; fm=fm+2; } printf(\"%.3lf\",s); return 0; }","link":"/2017/10/23/shryen2-3-6/"},{"title":"实验2-4-1 统计各位数字之和是5的数（20 分）","text":"实验2-4-1 统计各位数字之和是5的数（20 分）本题要求实现两个函数：一个函数判断给定正整数的各位数字之和是否等于5；另一个函数统计给定区间内有多少个满足上述要求的整数，并计算这些整数的和。 函数接口定义：12int is( int number );void count_sum( int a, int b ); 函数is判断number的各位数字之和是否等于5，是则返回1，否则返回0。 函数count_sum利用函数is统计给定区间[a, b]内有多少个满足上述要求（即令is返回1）的整数，并计算这些整数的和。最后按照格式 1count = 满足条件的整数个数, sum = 这些整数的和 进行输出。题目保证0&lt;a≤b≤10000。 裁判测试程序样例：123456789101112131415161718#include &lt;stdio.h&gt;int is( int number );void count_sum( int a, int b );int main(){ int a, b; scanf(\"%d %d\", &amp;a, &amp;b); if (is(a)) printf(\"%d is counted.\\n\", a); if (is(b)) printf(\"%d is counted.\\n\", b); count_sum(a, b); return 0;}/* 你的代码将被嵌在这里 */ 输入样例：1104 999 输出样例：12104 is counted.count = 15, sum = 3720 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;stdio.h&gt;int is( int number );void count_sum( int a, int b ); int main() { int a, b; scanf(\"%d %d\", &amp;a, &amp;b); if (is(a)) printf(\"%d is counted.\\n\", a); if (is(b)) printf(\"%d is counted.\\n\", b); count_sum(a, b); return 0; } int is(int number) { //1526 int c,d; int sum=0; while(number!=0) { c=number%10; sum=sum+c; number=number/10; } if(sum==5) { return 1; } else { return 0; } }//104 999 void count_sum( int a, int b ) { int i; int sum1=0; int count=0; for(i=a; i&lt;=b; i++) { if(is(i)) { count++; sum1=sum1+i; } } printf(\"count = %d, sum = %d\",count,sum1);}","link":"/2017/10/23/shryen2-4-1/"},{"title":"实验2-4-3 求平方根序列前N项和（15 分）","text":"实验2-4-3 求平方根序列前N项和（15 分）本题要求编写程序，计算平方根序列$\\sqrt{1}+\\sqrt{2}+\\sqrt{3}+\\cdots$的前N项之和。可包含头文件math.h，并调用sqrt函数求平方根。 输入格式:输入在一行中给出一个正整数N。 输出格式:在一行中按照“sum = S”的格式输出部分和的值S，精确到小数点后两位。题目保证计算结果不超过双精度范围。 输入样例:110 输出样例:1sum = 22.47 12345678910111213#include&lt;stdio.h&gt; #include&lt;math.h&gt; int main(void) { int N,i; double s=0,a; scanf(\"%d\",&amp;N); for(i=1;i&lt;=N;i++) { a=sqrt(i); s=s+a; } printf(\"sum = %.2f\",s); return 0; }","link":"/2017/10/23/shryen2-4-3/"},{"title":"实验2-4-4 求阶乘序列前N项和（15 分）","text":"实验2-4-4 求阶乘序列前N项和（15 分）本题要求编写程序，计算序列 $1!+2!+3!+\\cdots$ 的前N项之和。 输入格式:输入在一行中给出一个不超过12的正整数N。 输出格式:在一行中输出整数结果。 输入样例:15 输出样例:1153 1234567891011121314151617181920212223#include&lt;stdio.h&gt; double fact(int n); int main(void) { double result,s=0; int n,i; scanf(\"%d\",&amp;n); for(i=1;i&lt;=n;i++){ result=fact(i); s=s+result; } printf(\"%.0f\",s); return 0;}double fact(int n){ double total = 0; if (n == 0){ total = 1; }else{ total = n * fact(n - 1); } return total;}","link":"/2017/10/23/shryen2-4-4/"},{"title":"实验2-4-2 生成3的乘方表（15 分）","text":"实验2-4-2 生成3的乘方表（15 分）输入一个非负整数n，生成一张3的乘方表，输出$3^0$~$3^n$的值。可调用幂函数计算3的乘方。 输入格式:输入在一行中给出一个非负整数n。 输出格式:按照幂的递增顺序输出n+1行，每行格式为“pow(3,i) = 3的i次幂的值”。题目保证输出数据不超过长整型整数的范围。 输入样例:13 输出样例:1234pow(3,0) = 1pow(3,1) = 3pow(3,2) = 9pow(3,3) = 27 12345678910111213#include&lt;stdio.h&gt; #include&lt;math.h&gt; int main(void) { int n,i; double a; scanf(\"%d\",&amp;n); for(i=0;i&lt;=n;i++){ a=pow(3,i); printf(\"pow(3,%d) = %.0f\\n\",i,a); } return 0; }","link":"/2017/10/23/shryen2-4-2/"},{"title":"实验2-4-6 求幂之和（15 分）","text":"实验2-4-6 求幂之和（15 分）本题要求编写程序，计算$sum=2^1+2^2+2^3+⋯+2^n$。可以调用pow函数求幂。 输入格式:输入在一行中给出正整数$n（\\leq 10）$。 输出格式:按照格式“result = 计算结果”输出。 输入样例:15 输出样例:1result = 62 123456789101112#include&lt;stdio.h&gt; #include&lt;math.h&gt; int main(void) { double result,s; int n,i; s=0; scanf(\"%d\",&amp;n); for(i=1;i&lt;=n;i++){ result=pow(2,i); s=s+result; }printf(\"result = %.0f\",s); return 0;","link":"/2017/10/26/shryen2-4-6/"},{"title":"实验2-4-5 简单实现x的n次方（10 分）","text":"实验2-4-5 简单实现x的n次方（10 分）本题要求实现一个计算 $x^n（n\\geq 0）$的函数。 函数接口定义：1double mypow( double x, int n ); 函数mypow应返回x的n次幂的值。题目保证结果在双精度范围内。 裁判测试程序样例：12345678910111213141516#include &lt;stdio.h&gt;double mypow( double x, int n );int main(){ double x; int n; scanf(\"%lf %d\", &amp;x, &amp;n); printf(\"%f\\n\", mypow(x, n)); return 0;}/* 你的代码将被嵌在这里 */ 输入样例：10.24 4 输出样例：10.003318 123456789101112131415#include &lt;stdio.h&gt; #include &lt;math.h&gt; double mypow(double x,int n); int main() { double x; int n; scanf(\"%lf %d\", &amp;x, &amp;n); printf(\"%f\\n\", mypow(x, n)); return 0; }double mypow(double x,int n){ double r; r=pow(x,n); return r;}","link":"/2017/10/23/shryen2-4-5/"},{"title":"实验2-4-7 求组合数（15 分）","text":"实验2-4-7 求组合数（15 分）本题要求编写程序，根据公式$C_n^M=\\frac{n!}{m!(n−m)!} $算出从$n$个不同元素中取出$m$个元素$（m\\leq n）$的组合数。 建议定义和调用函数fact(n)计算n!，其中n的类型是int，函数类型是double。 输入格式:输入在一行中给出两个正整数m和n（m≤n），以空格分隔。 输出格式:按照格式“result = 组合数计算结果”输出。题目保证结果在double类型范围内。 输入样例:12 7 输出样例:1result = 21 1234567891011121314151617181920212223#include&lt;stdio.h&gt;double fact(int n); int main(void){ double result; int m,n,d; double x,y,z,a; scanf(\"%d %d\",&amp;m,&amp;n); d=n-m; x=fact(m); y=fact(n); z=fact(d); result = y/x/z; printf(\"result = %.f\",result); return 0; } double fact (int n){ int i; double a; a=1; for(i=1;i&lt;=n;i++){ a=a*i; } return a;}","link":"/2017/10/26/shryen2-4-7/"},{"title":"实验3-1 求一元二次方程的根（20 分）","text":"实验3-1 求一元二次方程的根（20 分）本题目要求一元二次方程的根，结果保留2位小数。 输入格式:输入在一行中给出3个浮点系数a、b、c，中间用空格分开。 输出格式:根据系数情况，输出不同结果： 1)如果方程有两个不相等的实数根，则每行输出一个根，先大后小； 2)如果方程有两个不相等复数根，则每行按照格式“实部+虚部i”输出一个根，先输出虚部为正的，后输出虚部为负的； 3)如果方程只有一个根，则直接输出此根； 4)如果系数都为0，则输出”Zero Equation”； 5)如果a和b为0，c不为0，则输出”Not An Equation”。 输入样例1:12.1 8.9 3.5 输出样例1:12-0.44-3.80 输入样例2:11 2 3 输出样例2:12-1.00+1.41i-1.00-1.41i 输入样例3:10 2 4 输出样例3:1-2.00 输入样例4:10 0 0 输出样例4:1Zero Equation 输入样例5:10 0 1 输出样例5:1Not An Equation 12345678910111213141516171819202122232425262728293031323334#include&lt;stdio.h&gt; #include&lt;math.h&gt; int main(void){ double a,b,c; double d,del,ans1,ans2; scanf(\"%lf%lf%lf\",&amp;a,&amp;b,&amp;c); d=b*b-4.0*a*c; if(a==b&amp;&amp;a==c&amp;&amp;a==0) printf(\"Zero Equation\\n\"); else if(a==b&amp;&amp;a==0&amp;&amp;c!=0) printf(\"Not An Equation\\n\"); else if(d==0){ ans1=(-b)/(2.0*a); printf(\"%.2f\\n\",ans1); } else if(a==0) printf(\"%.2f\\n\",(-c)/b); else if(d&gt;0){ del=sqrt(d); ans1=(-b+del)/(2.0*a); ans2=(-b-del)/(2.0*a); printf(\"%.2f\\n%.2f\\n\",ans1,ans2); } else if(d&lt;0){ del=sqrt(-d); if(b!=0) ans1=(-b)/(2.0*a); else ans1=0; ans2=del/(2.0*a); printf(\"%.2f+%.2fi\\n%.2f-%.2fi\\n\",ans1,ans2,ans1,ans2); } return 0; }","link":"/2017/10/26/shryen3-1/"},{"title":"实验3-10 高速公路超速处罚（15 分）","text":"实验3-10 高速公路超速处罚（15 分）按照规定，在高速公路上行使的机动车，达到或超出本车道限速的10%则处200元罚款；若达到或超出50%，就要吊销驾驶证。请编写程序根据车速和限速自动判别对该机动车的处理。 输入格式:输入在一行中给出2个正整数，分别对应车速和限速，其间以空格分隔。 输出格式:在一行中输出处理意见：若属于正常行驶，则输出“OK”；若应处罚款，则输出“Exceed x%. Ticket 200”；若应吊销驾驶证，则输出“Exceed x%. License Revoked”。其中x是超速的百分比，精确到整数。 输入样例1:165 60 输出样例1:1OK 输入样例2:1110 100 输出样例2:1Exceed 10%. Ticket 200 输入样例3:1200 120 输出样例3:1Exceed 67%. License Revoked 12345678910111213#include &lt;stdio.h&gt; int main(void) { int m,n; double z; scanf(\"%d%d\",&amp;m,&amp;n); z=(m-n)*100.0/n; if(z&lt;10) printf(\"OK\\n\"); else if(z&lt;50) printf(\"Exceed %.0f%%. Ticket 200\\n\",z); else printf(\"Exceed %.0f%%. License Revoked\\n\",z); return 0;}","link":"/2017/10/27/shryen3-10/"},{"title":"实验3-2 计算符号函数的值（10 分）","text":"实验3-2 计算符号函数的值（10 分）对于任一整数n，符号函数sign(n)的定义如下： $$sign(n)=\\begin{cases}-1, &amp; (n \\lt 10) \\\\\\ 0, &amp; (n=0) \\\\\\ 1,&amp; (n\\gt0) \\end{cases}$$ 请编写程序计算该函数对任一输入整数的值。 输入格式:输入在一行中给出整数n。 输出格式:在一行中按照格式“sign(n) = 函数值”输出该整数n对应的函数值。 输入样例1:110 输出样例1:1sign(10) = 1 输入样例2:10 输出样例2:1sign(0) = 0 输入样例3:1-98 输出样例3:1sign(-98) = -1 12345678910111213#include&lt;stdio.h&gt; int main(void){ int n,p; scanf(\"%d\",&amp;n); if(n&lt;0) p=-1; else if(n==0) p=0; else if(n&gt;0) p=1; printf(\"sign(%d) = %d\",n,p); return 0; }","link":"/2017/10/27/shryen3-2/"},{"title":"实验3-11 计算油费（15 分）","text":"实验3-11 计算油费（15 分）现在90号汽油6.95元/升、93号汽油7.44元/升、97号汽油7.93元/升。为吸引顾客，某自动加油站推出了“自助服务”和“协助服务”两个服务等级，分别可得到5%和3%的折扣。 本题要求编写程序，根据输入顾客的加油量a，汽油品种b（90、93或97）和服务类型c（m - 自助，e - 协助），计算并输出应付款。 输入格式：输入在一行中给出两个整数和一个字符，分别表示顾客的加油量a，汽油品种b（90、93或97）和服务类型c（m - 自助，e - 协助）。 输出格式：在一行中输出应付款额，保留小数点后2位。 输入样例：140 97 m 输出样例：1301.34 1234567891011121314151617181920212223#include&lt;stdio.h&gt;int main(){ float r1,r2,s; int a,b; char c; s=0; scanf(\"%d %d %c\",&amp;a,&amp;b,&amp;c); switch(b) { case 90 : r1=6.95; break;////// case 93 : r1=7.44; break;////// case 97 : r1=7.93; break;////// } switch(c) { case 'm' : r2=0.95; break; case 'e' : r2=0.97; break; } s=r1*r2*a; printf(\"%.2f\",s); return 0;}","link":"/2017/10/27/shryen3-11/"},{"title":"实验3-3 比较大小（10 分）","text":"实验3-3 比较大小（10 分）本题要求将输入的任意3个整数从小到大输出。 输入格式:输入在一行中给出3个整数，其间以空格分隔。 输出格式:在一行中将3个整数从小到大输出，其间以“-&gt;”相连。 输入样例:14 2 8 输出样例:12-&gt;4-&gt;8 1234567891011121314151617#include&lt;stdio.h&gt;int main(void){ int a,b,c,t; scanf(\"%d %d %d\",&amp;a,&amp;b,&amp;c); if(a&lt;b){ t=b;b=a;a=t; }; if(a&lt;c){ t=c;c=a;a=t; }; if(b&lt;c){ t=c;c=b;b=t; }; printf(\"%d-&gt;%d-&gt;%d\",c,b,a); return 0;}","link":"/2017/10/27/shryen3-3/"},{"title":"实验3-4 统计字符（15 分）","text":"实验3-4 统计字符（15 分）本题要求编写程序，输入10个字符，统计其中英文字母、空格或回车、数字字符和其他字符的个数。 输入格式:输入为10个字符。最后一个回车表示输入结束，不算在内。 输出格式:在一行内按照 1letter = 英文字母个数, blank = 空格或回车个数, digit = 数字字符个数, other = 其他字符个数 的格式输出。 输入样例:12aZ &amp;09 Az 输出样例:1letter = 4, blank = 3, digit = 2, other = 1 1234567891011121314151617#include&lt;stdio.h&gt;int main(void){ int i,letter,blank,digit,other; char ch; letter=blank=digit=other=0; for(i=1;i&lt;=10;i++){ scanf(\"%c\",&amp;ch); if(ch&gt;='A'&amp;&amp;ch&lt;='Z'||(ch&gt;='a'&amp;&amp;ch&lt;='z')) letter++; else if(ch==' '||ch=='\\n') blank++; else if(ch&gt;='0'&amp;&amp;ch&lt;='9') digit++; else other++; } printf(\"letter = %d, blank = %d, digit = %d, other = %d\",letter,blank,digit,other); return 0; }","link":"/2017/10/27/shryen3-4/"},{"title":"实验3-7 统计学生成绩（15 分）","text":"实验3-7 统计学生成绩（15 分）本题要求编写程序读入N个学生的百分制成绩，统计五分制成绩的分布。百分制成绩到五分制成绩的转换规则： 大于等于90分为A； 小于90且大于等于80为B； 小于80且大于等于70为C； 小于70且大于等于60为D； 小于60为E。 输入格式:输入在第一行中给出一个正整数N（≤1000），即学生人数；第二行中给出N个学生的百分制成绩，其间以空格分隔。 输出格式:在一行中输出A、B、C、D、E对应的五分制成绩的人数分布，数字间以空格分隔，行末不得有多余空格。 输入样例:12777 54 92 73 60 65 69 输出样例:11 0 2 3 1 123456789101112131415161718192021222324252627#include&lt;stdio.h&gt; int main(){ int n,i,A,B,C,D,N,E; scanf(\"%d\\n\",&amp;n); A=B=C=D=E=0; for(i=1;i&lt;=n;i++){ scanf(\"%d\",&amp;N); if(N&gt;=90){ A++; } else if(N&gt;=80){ B++; } else if(N&gt;=70){ C++; } else if (N&gt;=60){ D++; } else{ E++; } } printf(\"%d %d %d %d %d\",A,B,C,D,E); return 0; } }","link":"/2017/10/27/shryen3-7/"},{"title":"实验3-5 查询水果价格（15 分）","text":"实验3-5 查询水果价格（15 分）给定四种水果，分别是苹果（apple）、梨（pear）、桔子（orange）、葡萄（grape），单价分别对应为3.00元/公斤、2.50元/公斤、4.10元/公斤、10.20元/公斤。 首先在屏幕上显示以下菜单： 12345[1] apple[2] pear[3] orange[4] grape[0] exit 用户可以输入编号1~4查询对应水果的单价。当连续查询次数超过5次时，程序应自动退出查询；不到5次而用户输入0即退出；输入其他编号，显示价格为0。 输入格式:输入在一行中给出用户连续输入的若干个编号。 输出格式:首先在屏幕上显示菜单。然后对应用户的每个输入，在一行中按格式“price = 价格”输出查询结果，其中价格保留两位小数。当用户连续查询次数超过5次、或主动输入0时，程序结束。 输入样例1:13 -1 0 2 输出样例1:1234567[1] apple[2] pear[3] orange[4] grape[0] exitprice = 4.10price = 0.00 输入样例2:11 2 3 3 4 4 5 6 7 8 输出样例2:12345678910[1] apple[2] pear[3] orange[4] grape[0] exitprice = 3.00price = 2.50price = 4.10price = 4.10price = 10.20 1234567891011121314151617181920212223#include&lt;stdio.h&gt; int main(void){ int n,i; double price; printf(\"[1] apple\\n\"); printf(\"[2] pear\\n\"); printf(\"[3] orange\\n\"); printf(\"[4] grape\\n\"); printf(\"[0] exit\\n\"); for(i=1;i&lt;=5;i++){ scanf(\"%d\",&amp;n); if(n==0) break; switch(n){ case 1:price=3.00;break; case 2:price=2.50;break; case 3:price=4.10;break; case 4:price=10.20;break; default:price=0.00;break; } printf(\"price = %.2f\\n\",price); } return 0; }","link":"/2017/10/27/shryen3-5/"},{"title":"实验3-6 计算个人所得税（10 分）","text":"实验3-6 计算个人所得税（10 分）假设个人所得税为：税率×(工资−1600)。请编写程序计算应缴的所得税，其中税率定义为： 当工资不超过1600时，税率为0； 当工资在区间(1600, 2500]时，税率为5%； 当工资在区间(2500, 3500]时，税率为10%； 当工资在区间(3500, 4500]时，税率为15%； 当工资超过4500时，税率为20%。 输入格式:输入在一行中给出非负工资。 输出格式:在一行输出个人所得税，精确到小数点后2位。 输入样例1:11600 输出样例1:10.00 输入样例2:11601 输出样例2:10.05 输入样例3:13000 输出样例3:1140.00 输入样例4:14000 输出样例4:1360.00 输入样例5:15000 输出样例5:1680.00 1234567891011121314151617181920212223242526#include&lt;stdio.h&gt;int main(void){ double a,n,m,o,p,q; scanf(\"%lf\",&amp;n); if(n&lt;=1600){ a=0; printf(\"%.2f\",a); } else if(n&lt;=2500){ m=(n-1600)*0.05; printf(\"%.2f\",m); } else if(n&lt;=3500){ o=(n-1600)*0.1; printf(\"%.2f\",o); } else if(n&lt;=4500){ p=(n-1600)*0.15; printf(\"%.2f\",p); } else{ q=(n-1600)*0.2; printf(\"%.2f\",q); } return 0; }","link":"/2017/10/27/shryen3-6/"},{"title":"实验3-8 输出三角形面积和周长（15 分）","text":"实验3-8 输出三角形面积和周长（15 分）本题要求编写程序，根据输入的三角形的三条边a、b、c，计算并输出面积和周长。注意：在一个三角形中， 任意两边之和大于第三边。三角形面积计算公式：$area=\\sqrt{s(s−a)(s−b)(s−c)}$，其中$s=\\frac{(a+b+c)}{2} $。 输入格式：输入为3个正整数，分别代表三角形的3条边a、b、c。 输出格式：如果输入的边能构成一个三角形，则在一行内，按照 1area = 面积; perimeter = 周长 的格式输出，保留两位小数。否则，输出 1These sides do not correspond to a valid triangle 输入样例1：15 5 3 输出样例1：1area = 7.15; perimeter = 13.00 输入样例2：11 4 1 输出样例2：1These sides do not correspond to a valid triangle 123456789101112131415#include&lt;stdio.h&gt; #include&lt;math.h&gt;int main(void) { double area,perimeter,s,a,b,c; scanf(\"%lf%lf%lf\",&amp;a,&amp;b,&amp;c); if((a+b&gt;c)&amp;&amp;(a+c&gt;b)&amp;&amp;(b+c&gt;a)){ s=(a+b+c)/2; area=sqrt(s*(s-a)*(s-b)*(s-c)); perimeter=a+b+c; printf(\"area=%.2f,perimeter=%.2f\\n\",area,perimeter); }else{ printf(\"These sides do not corrspond to a vaild triangle\\n\"); } return 0; }","link":"/2017/10/27/shryen3-8/"},{"title":"实验4-1-1 最大公约数和最小公倍数（15 分）","text":"实验4-1-1 最大公约数和最小公倍数（15 分）本题要求两个给定正整数的最大公约数和最小公倍数。 输入格式:输入在一行中给出两个正整数$M$和$N（\\leq 1000）$。 输出格式:在一行中顺序输出$M$和$N$的最大公约数和最小公倍数，两数字间以1空格分隔。 输入样例:1511 292 输出样例:173 2044 12345678910111213#include &lt;stdio.h&gt;#include&lt;math.h&gt; int main() { int m,n,gb,gy; scanf(\"%d%d\",&amp;m,&amp;n); gb=m; while(gb%n!=0){ gb=gb+m; } gy=(m*n)/gb; printf(\"%d %d\",gy,gb); return 0; }","link":"/2017/10/29/shryen4-1-1/"},{"title":"实验3-9 三天打鱼两天晒网（15 分）","text":"实验3-9 三天打鱼两天晒网（15 分）中国有句俗语叫“三天打鱼两天晒网”。假设某人从某天起，开始“三天打鱼两天晒网”，问这个人在以后的第N天中是“打鱼”还是“晒网”？ 输入格式：输入在一行中给出一个不超过1000的正整数N。 输出格式：在一行中输出此人在第N天中是“Fishing”（即“打鱼”）还是“Drying”（即“晒网”），并且输出“in day N”。 输入样例1：1103 输出样例1：1Fishing in day 103 输入样例2：134 输出样例2：1Drying in day 34 12345678910#include&lt;stdio.h&gt; int main(void) { int x; scanf(\"%d\",&amp;x); if(x%5==0||(x+1)%5==0) printf(\"Drying in day %d\",x); else printf(\"Fishing in day %d\",x); return 0; }","link":"/2017/10/27/shryen3-9/"},{"title":"实验4-1-10 兔子繁衍问题（15 分）","text":"实验4-1-10 兔子繁衍问题（15 分）一对兔子，从出生后第3个月起每个月都生一对兔子。小兔子长到第3个月后每个月又生一对兔子。假如兔子都不死，请问第1个月出生的一对兔子，至少需要繁衍到第几个月时兔子总数才可以达到N对？ 输入格式:输入在一行中给出一个不超过10000的正整数N。 输出格式:在一行中输出兔子总数达到N最少需要的月数。 输入样例:130 输出样例:19 123456789101112131415161718192021222324#include&lt;stdio.h&gt;int main(void){ int N; int month=1; int sum=1; int now=0,pre=0; scanf(\"%d\",&amp;N); if(N==sum){ printf(\"%d\\n\",month); }else{ month++; now=pre+sum; while(now&lt;N){ month++; pre=sum; sum=now; now=pre+sum; } printf(\"%d\\n\",month); } return 0;}","link":"/2017/11/01/shryen4-1-10/"},{"title":"实验4-1-11 高空坠球（20 分）","text":"实验4-1-11 高空坠球（20 分）皮球从某给定高度自由落下，触地后反弹到原高度的一半，再落下，再反弹，……，如此反复。问皮球在第n次落地时，在空中一共经过多少距离？第n次反弹的高度是多少？ 输入格式:输入在一行中给出两个非负整数，分别是皮球的初始高度和n，均在长整型范围内。 输出格式:在一行中顺序输出皮球第n次落地时在空中经过的距离、以及第n次反弹的高度，其间以一个空格分隔，保留一位小数。题目保证计算结果不超过双精度范围。 输入样例:133 5 输出样例:194.9 1.0 12345678910111213141516171819#include&lt;stdio.h&gt; int main() { int m,n,i; double x,y,z; scanf(\"%d%d\",&amp;m,&amp;n); y=0,z=m;i=1; while(i&lt;=n){ x=0.5*z; y=y+x+z; z=x; i++; } y=y-z; if(n==0) printf(\"0.0 0.0\"); else printf(\"%.1f %.1f\",y,z); return 0; }","link":"/2017/11/01/shryen4-1-11/"},{"title":"实验4-1-12 黑洞数（20 分）","text":"实验4-1-12 黑洞数（20 分）黑洞数也称为陷阱数，又称“Kaprekar问题”，是一类具有奇特转换特性的数。 任何一个各位数字不全相同的三位数，经有限次“重排求差”操作，总会得到495。最后所得的495即为三位黑洞数。所谓“重排求差”操作即组成该数的数字重排后的最大数减去重排后的最小数。（6174为四位黑洞数。） 例如，对三位数207： 第1次重排求差得：$720-27＝693$； 第2次重排求差得：$963-369＝594$； 第3次重排求差得：$954-459＝495$； 以后会停留在495这一黑洞数。如果三位数的3个数字全相同，一次转换后即为0。 任意输入一个三位数，编程给出重排求差的过程。 输入格式：输入在一行中给出一个三位数。 输出格式：按照以下格式输出重排求差的过程： 1序号: 数字重排后的最大数 - 重排后的最小数 = 差值 序号从1开始，直到495出现在等号右边为止。 输入样例：1123 输出样例：123451: 321 - 123 = 1982: 981 - 189 = 7923: 972 - 279 = 6934: 963 - 369 = 5945: 954 - 459 = 495 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;stdio.h&gt;int main(void){ int number,x,y,a,b,c,t,i,max,min,mid; scanf(\"%d\",&amp;number); i=1; while(number!=495){ a=number/100; b=number%100/10; c=number%10; mid=a+b+c; max=a&gt;b?a:b; max=max&gt;c?max:c; min=a&gt;b?b:a; min=min&gt;c?c:min; mid=mid-min-max; x=max*100+mid*10+min; y=min*100+mid*10+max; /*---------*/ number=x-y; printf(\"%d: %d - %d = %d\\n\",i,x,y,number); i++; }return 0;}","link":"/2017/11/01/shryen4-1-12/"},{"title":"实验4-1-2 求奇数和（15 分）","text":"实验4-1-2 求奇数和（15 分）本题要求计算给定的一系列正整数中奇数的和。 输入格式:输入在一行中给出一系列正整数，其间以空格分隔。当读到零或负整数时，表示输入结束，该数字不要处理。 输出格式:在一行中输出正整数序列中奇数的和。 输入样例:18 7 4 3 70 5 6 101 -1 输出样例:1116 123456789101112#include &lt;stdio.h&gt; int main(void) { int n,z; z=0; scanf(\"%d\",&amp;n); while(n&gt;0) { if(n%2!=0) z=z+n; scanf(\"%d\",&amp;n); } printf(\"%d\",z);return 0; }","link":"/2017/10/29/shryen4-1-2/"},{"title":"实验4-1-3 找出最小值（20 分）","text":"实验4-1-3 找出最小值（20 分）本题要求编写程序，找出给定一系列整数中的最小值。 输入格式：输入在一行中首先给出一个正整数n，之后是n个整数，其间以空格分隔。 输出格式：在一行中按照“min = 最小值”的格式输出n个整数中的最小值。 输入样例：14 -2 -123 100 0 输出样例：1min = -123 12345678910111213#include &lt;stdio.h&gt; int main(void ) { int i,a,min,n; scanf(\"%d\",&amp;n); min=a; for(i=1;i&lt;=n;i++){ scanf(\"%d\",&amp;a); if(min&gt;a) min=a; } printf(\"min = %d\\n\",min); return 0; }","link":"/2017/10/29/shryen4-1-3/"},{"title":"实验4-1-5 韩信点兵（10 分）","text":"实验4-1-5 韩信点兵（10 分）在中国数学史上，广泛流传着一个“韩信点兵”的故事：韩信是汉高祖刘邦手下的大将，他英勇善战，智谋超群，为汉朝建立了卓越的功劳。据说韩信的数学水平也非常高超，他在点兵的时候，为了知道有多少兵，同时又能保住军事机密，便让士兵排队报数： 按从1至5报数，记下最末一个士兵报的数为1； 再按从1至6报数，记下最末一个士兵报的数为5； 再按从1至7报数，记下最末一个士兵报的数为4； 最后按从1至11报数，最末一个士兵报的数为10； 请编写程序计算韩信至少有多少兵。 输入格式：本题无输入 输出格式：输出韩信至少拥有的士兵人数。 12345678#include&lt;stdio.h&gt; int main() { int i=0; while(!(i%5==1&amp;&amp;i%6==5&amp;&amp;i%7==4&amp;&amp;i%11==10)) i++; printf(\"%d\",i); return 0; }","link":"/2017/11/01/shryen4-1-5/"},{"title":"实验4-1-4 求整数的位数及各位数字之和（15 分）","text":"实验4-1-4 求整数的位数及各位数字之和（15 分）对于给定的正整数N，求它的位数及其各位数字之和。 输入格式：输入在一行中给出一个不超过109的正整数N。 输出格式：在一行中输出N的位数及其各位数字之和，中间用一个空格隔开。 输入样例：1321 输出样例：13 6 123456789101112131415#include&lt;stdio.h&gt; int main(void) { int count=0,number,i; int sum=0; scanf(\"%d\",&amp;number); do { i=number%10; number=number/10; sum=sum+i; count++; } while(number!=0); printf(\"%d %d\\n\",count,sum); return 0; }","link":"/2017/10/29/shryen4-1-4/"},{"title":"实验4-1-6 求分数序列前N项和（15 分）","text":"实验4-1-6 求分数序列前N项和（15 分）本题要求编写程序，计算序列 $\\frac{2}{1}+\\frac{3}{2}+\\frac{5}{3}+\\frac{8}{5}+…$ 的前N项之和。注意该序列从第2项起，每一项的分子是前一项分子与分母的和，分母是前一项的分子。 输入格式:输入在一行中给出一个正整数N。 输出格式:在一行中输出部分和的值，精确到小数点后两位。题目保证计算结果不超过双精度范围。 输入样例:120 输出样例:132.66 12345678910111213141516#include&lt;stdio.h&gt; int main() { double n,z,m,i,t; double item,sum; sum=0;m=1;z=2; scanf(\"%lf\",&amp;n); for(i=1;i&lt;=n;i++){ item=1.0*z/m; sum=sum+item; t=z; z=z+m; m=t; } printf(\"%.2f\",sum); return 0; }","link":"/2017/11/01/shryen4-1-6/"},{"title":"实验4-1-9 猜数字游戏（15 分）","text":"实验4-1-9 猜数字游戏（15 分）猜数字游戏是令游戏机随机产生一个100以内的正整数，用户输入一个数对其进行猜测，需要你编写程序自动对其与随机产生的被猜数进行比较，并提示大了（“Too big”），还是小了（“Too small”），相等表示猜到了。如果猜到，则结束程序。程序还要求统计猜的次数，如果1次猜出该数，提示“Bingo!”；如果3次以内猜到该数，则提示“Lucky You!”；如果超过3次但是在N（&gt;3）次以内（包括第N次）猜到该数，则提示“Good Guess!”；如果超过N次都没有猜到，则提示“Game Over”，并结束程序。如果在到达N次之前，用户输入了一个负数，也输出“Game Over”，并结束程序。 输入格式:输入第一行中给出两个不超过100的正整数，分别是游戏机产生的随机数、以及猜测的最大次数N。最后每行给出一个用户的输入，直到出现负数为止。 输出格式:在一行中输出每次猜测相应的结果，直到输出猜对的结果或“Game Over”则结束。 输入样例:123456758 47050565860-2 输出样例:1234Too bigToo smallToo smallGood Guess! 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;stdio.h&gt;int main() { int key, n; scanf(\"%d %d\",&amp;key,&amp;n); int i; int m; int flag = 0; for (i = 1;i &lt;= n;i ++) { scanf(\"%d\",&amp;m); if (m &lt; 0) break; if (m &gt; key) printf(\"Too big\\n\"); if (m &lt; key) printf(\"Too small\\n\"); if (m == key) { if (i == 1) { flag = 1; printf(\"Bingo!\\n\"); break; } if (i == 2 || i == 3) { flag = 1; printf(\"Lucky You!\\n\"); break; } if (i &gt; 3) { flag = 1; printf(\"Good Guess!\\n\"); break; } } } if (flag == 0) printf(\"Game Over\\n\"); return 0;}","link":"/2017/11/01/shryen4-1-9/"},{"title":"实验4-1-7 特殊a串数列求和（20 分）","text":"实验4-1-7 特殊a串数列求和（20 分）给定两个均不超过9的正整数a和n，要求编写程序求$a+aa+aaa++ \\cdots+aa\\cdots a$（n个a）之和。 输入格式：输入在一行中给出不超过9的正整数a和n。 输出格式：在一行中按照“s = 对应的和”的格式输出。 输入样例：12 3 输出样例：1s = 246 123456789101112#include&lt;stdio.h&gt; int main() { int a,n,sum,i,t; t=sum=0; scanf(\"%d%d\",&amp;a,&amp;n); for(i=1;i&lt;=n;i++){ t=t*10+a; sum+=t; } printf(\"s = %d\",sum); return 0; }","link":"/2017/11/01/shryen4-1-7/"},{"title":"实验4-2-2 求e的近似值（15 分）","text":"实验4-2-2 求e的近似值（15 分）自然常数e可以用级数$1+\\frac{1}{1!}/+\\frac{1}{2!}+⋯+\\frac{1}{n!}$来近似计算。本题要求对给定的非负整数n，求该级数的前n项和。 输入格式:输入第一行中给出非负整数$n（\\leq 1000）$。 输出格式:在一行中输出部分和的值，保留小数点后八位。 输入样例:110 输出样例:12.71828180 12345678910111213141516171819202122#include&lt;stdio.h&gt; double fact(int n); int main(){ double count=1; int i; int n; scanf(\"%d\",&amp;n); for(i=1;i&lt;=n;i++) { count=count+1.0/fact(i); } printf(\"%.8f\\n\",count); return 0; } double fact(int n) { int i; double sum=1; for(i=1;i&lt;=n;i++) { sum=sum*i; } return sum; }","link":"/2017/11/02/shryen4-2-2/"},{"title":"实验4-2-3 验证“哥德巴赫猜想”（20 分）","text":"实验4-2-3 验证“哥德巴赫猜想”（20 分）数学领域著名的“哥德巴赫猜想”的大致意思是：任何一个大于2的偶数总能表示为两个素数之和。比如：$24=5+19$，其中5和19都是素数。本实验的任务是设计一个程序，验证20亿以内的偶数都可以分解成两个素数之和。 输入格式：输入在一行中给出一个(2, 2 000 000 000]范围内的偶数N。 输出格式：在一行中按照格式“N = p + q”输出N的素数分解，其中p ≤ q均为素数。又因为这样的分解不唯一（例如24还可以分解为7+17），要求必须输出所有解中p最小的解。 输入样例：124 输出样例：124 = 5 + 19 12345678910111213141516171819202122232425#include&lt;stdio.h&gt; #include&lt;math.h&gt; int main() { int n, m, i, p, q; scanf(\"%d\", &amp;n); for(i=2;i&lt;=n/2;i++){ for(m=2;m&lt;=sqrt(i);m++) { if(i%m==0) break; } if(m&gt;sqrt(i)) { q=n-i; for(m=2;m&lt;=sqrt(q);m++) { if(q%m==0) break; } if(m&gt;sqrt(q)) { p=i; printf(\"%d = %d + %d\", n, p, q); break; } } } return 0; }","link":"/2017/11/02/shryen4-2-3/"},{"title":"实验4-2-5 水仙花数（20 分）","text":"实验4-2-5 水仙花数（20 分）水仙花数是指一个$N$位正整数$（N \\geq 3）$，它的每个位上的数字的N次幂之和等于它本身。例如：$153=13+53+33$。 本题要求编写程序,计算所有N位水仙花数。 输入格式:输入在一行中给出一个正整数$N（3\\leq N\\leq 7）$。 输出格式:按递增顺序输出所有N位水仙花数，每个数字占一行。 输入样例:13 输出样例:1234153370371407 1234567891011121314151617181920212223242526#include&lt;stdio.h&gt; #include&lt;math.h&gt;int main(void) { int n, a, i, m, k, j; scanf(\"%d\", &amp;n); if(n==7){ printf(\"1741725\\n\"); printf(\"4210818\\n\"); printf(\"9800817\\n\"); printf(\"9926315\\n\"); }else{ for(i=pow(10,n-1); i&lt;pow(10,n);i++){ m=i; a=0; for(k=1;k&lt;=n;k++){ j=m%10; m=m/10; a=a+pow(j,n); } if(a==i){ printf(\"%d\\n\", a); } } } return 0; }","link":"/2017/11/02/shryen4-2-5/"},{"title":"实验4-1-8 求给定精度的简单交错序列部分和（15 分）","text":"实验4-1-8 求给定精度的简单交错序列部分和（15 分）本题要求编写程序，计算序列部分和$1 - \\frac{1}{4 }+ \\frac{1}{7} - \\frac{1}{10} +\\cdots$ 直到最后一项的绝对值不大于给定精度eps。 输入格式:输入在一行中给出一个正实数eps。 输出格式:在一行中按照“sum = S”的格式输出部分和的值S，精确到小数点后六位。题目保证计算结果不超过双精度范围。 输入样例1:14E-2 输出样例1:1sum = 0.854457 输入样例2:10.02 输出样例2:1sum = 0.826310 12345678910111213141516#include&lt;stdio.h&gt; #include&lt;math.h&gt; int main(void){ int fz=1,fm=1,flag=1; double eps,item,sum=0; scanf(\"%lf\",&amp;eps); item=eps+1; while(fabs(item)&gt;eps){ item=flag*1.0/fm; sum=sum+item; fm=fm+3; flag=-flag; } printf(\"sum = %.6f\",sum); return 0; }","link":"/2017/11/01/shryen4-1-8/"},{"title":"实验4-2-4 换硬币（20 分）","text":"实验4-2-4 换硬币（20 分）将一笔零钱换成5分、2分和1分的硬币，要求每种硬币至少有一枚，有几种不同的换法？ 输入格式:输入在一行中给出待换的零钱数额$x\\in(8,100)$。 输出格式:要求按5分、2分和1分硬币的数量依次从大到小的顺序，输出各种换法。每行输出一种换法，格式为：“fen5:5分硬币数量, fen2:2分硬币数量, fen1:1分硬币数量, total:硬币总数量”。最后一行输出“count = 换法个数”。 输入样例:113 输出样例:12345fen5:2, fen2:1, fen1:1, total:4fen5:1, fen2:3, fen1:2, total:6fen5:1, fen2:2, fen1:4, total:7fen5:1, fen2:1, fen1:6, total:8count = 4 1234567891011121314151617#include&lt;stdio.h&gt; int main(){ int x,i,j,k,a,b,c,count=0; scanf(\"%d\",&amp;x); for(i=x/5;i&gt;=1;i--){ for(j=x/2;j&gt;=1;j--){ for(k=x;k&gt;=1;k--){ if(5*i+2*j+k==x){ printf(\"fen5:%d, fen2:%d, fen1:%d, total:%d\\n\",i,j,k,i+j+k); count++; } } } } printf(\"count = %d\",count); return 0;}","link":"/2017/11/02/shryen4-2-4/"},{"title":"实验4-2-6 输出三角形字符阵列（15 分）","text":"实验4-2-6 输出三角形字符阵列（15 分）本题要求编写程序，输出n行由大写字母A开始构成的三角形字符阵列。 输入格式：输入在一行中给出一个正整数$n（1\\leq n \\lt7）$。 输出格式：输出n行由大写字母A开始构成的三角形字符阵列。格式见输出样例，其中每个字母后面都有一个空格。 输入样例：14 输出样例：1234A B C D E F G H I J 12345678910111213141516#include&lt;stdio.h&gt; int main() { int n ,m,i ,j; char ch; scanf(\"%d\",&amp;n); m=n; ch='A'; for(i=1;i&lt;=n;i++) { for(j=i;j&lt;=m;j++) { printf(\"%c \",ch); ch++; } printf(\"\\n\"); } return 0; }","link":"/2017/11/06/shryen4-2-6/"},{"title":"实验4-2-7 找完数（20 分）","text":"实验4-2-7 找完数（20 分）所谓完数就是该数恰好等于除自身外的因子之和。例如：$6=1+2+3$，其中1、2、3为6的因子。本题要求编写程序，找出任意两正整数m和n之间的所有完数。 输入格式：输入在一行中给出2个正整数$m$和$n（1 \\lt m \\leq n \\leq 10000）$，中间以空格分隔。 输出格式：逐行输出给定范围内每个完数的因子累加形式的分解式，每个完数占一行，格式为“完数 = 因子1 + 因子2 + … + 因子k”，其中完数和因子均按递增顺序给出。若区间内没有完数，则输出“None”。 输入样例：12 30 输出样例：126 = 1 + 2 + 328 = 1 + 2 + 4 + 7 + 14 12345678910111213141516171819202122232425262728293031323334#include&lt;stdio.h&gt; #include&lt;math.h&gt;int main() { int f,i,j,m,n,s; scanf(\"%d%d\",&amp;m,&amp;n); f=0; if(m==1) { printf(\"1 = 1\\n\"); m++, f=1; } for(i=m;i&lt;=n;i++) { s=0; for(j=1;j&lt;=i/2;j++){ if(i%j==0) { s=s+j; } } if(i==s){ f=1; printf(\"%d = 1\",i); for(j=2;j&lt;=i/2;j++){ if(i%j==0) { printf(\" + %d\",j); } } printf(\"\\n\"); } } if(f==0){ printf(\"None\\n\"); } return 0; }","link":"/2017/11/06/shryen4-2-7/"},{"title":"实验4-2-9 梅森数（20 分）","text":"实验4-2-9 梅森数（20 分）形如2n−1的素数称为梅森数（Mersenne Number）。例如$2^2−1=3 2^3−1=7$都是梅森数。1722年，双目失明的瑞士数学大师欧拉证明了$2^{31}−1=2147483647$是一个素数，堪称当时世界上“已知最大素数”的一个记录。 本题要求编写程序，对任一正整数n（n&lt;20），输出所有不超过2n−1的梅森数。 输入格式：输入在一行中给出正整数n（n&lt;20）。 输出格式：按从小到大的顺序输出所有不超过2n−1的梅森数，每行一个。如果完全没有，则输出“None”。 输入样例：16 输出样例：1233731 12345678910111213141516171819202122232425262728293031323334#include&lt;math.h&gt;#include&lt;stdio.h&gt;int prime (int n){ int i; long k; k=sqrt(n)+1; for(i=2;i&lt;=k;i++){ if(n%i==0){ return 0; } } return 1;}int main(void) { long mp,n=0,i; scanf(\"%ld\",&amp;n); if(n&lt;20){ for(i = 2;i&lt;n;i++){ mp=pow(2,i)-1; if(prime(mp)){ printf(\"%d\",mp); printf(\"\\n\"); } } }else{ printf(\"n不能超過20\"); } return 0; }","link":"/2017/11/06/shryen4-2-9/"},{"title":"实验5-1 使用函数计算两个复数之积（10 分）","text":"实验5-1 使用函数计算两个复数之积（10 分）若两个复数分别为：$c_1=x_1+{y_1}i$和$c_2=x_2+{y^2}i$，则它们的乘积为 $c_1×c_2=(x_1\\times{x_2}−y_1\\times{y_2})+(x_1\\times{y_2}+x_2\\times{y1})i$。 本题要求实现一个函数计算两个复数之积。 函数接口定义：12double result_real, result_imag;void complex_prod( double x1, double y1, double x2, double y2 ); 其中用户传入的参数为两个复数x1+y1i和x2+y2i；函数complex_prod应将计算结果的实部存放在全局变量result_real中、虚部存放在全局变量result_imag中。 裁判测试程序样例：123456789101112131415161718#include&lt;stdio.h&gt; double result_real, result_imag;void complex_prod( double x1, double y1, double x2, double y2 );int main(void) { double imag1, imag2, real1, real2; scanf(\"%lf %lf\", &amp;real1, &amp;imag1); scanf(\"%lf %lf\", &amp;real2, &amp;imag2); complex_prod(real1, imag1, real2, imag2); printf(\"product of complex is (%f)+(%f)i\\n\", result_real, result_imag); return 0;}/* 你的代码将被嵌在这里 */ 输入样例：121 2-2 -3 输出样例：1product of complex is (4.000000)+(-7.000000)i 123456789101112131415161718192021#include &lt;stdio.h&gt;double result_real,result_imag;void complex_prod(double real1,double imag1,double real2,double imag2);int main(void){ double imag1,imag2,real1,real2; printf(\"Enter 1st complex number(real and imaginary):\"); scanf(\"%lf%lf\",&amp;real1,&amp;imag1); printf(\"Enter 2nd complex number(real and imaginary):\"); scanf(\"%lf%lf\",&amp;real2,&amp;imag2); complex_prod(real1,imag1,real2,imag2); printf(\"product of complex is %f+%fi\\n\",result_real,result_imag); return 0;}void complex_prod(double x1,double y1,double x2,double y2){ result_real=x1*x2-y1*y2; result_imag=x1*y2+x2*y1;}","link":"/2017/11/28/shryen5-1/"},{"title":"实验4-2-8 输出整数各位数字（15 分）","text":"实验4-2-8 输出整数各位数字（15 分）本题要求编写程序，对输入的一个整数，从高位开始逐位分割并输出它的各位数字。 输入格式：输入在一行中给出一个长整型范围内的非负整数。 输出格式：从高位开始逐位输出该整数的各位数字，每个数字后面有一个空格。 输入样例：1123456 输出样例：11 2 3 4 5 6 1234567891011121314151617181920212223242526#include&lt;stdio.h&gt; int main(void) { long int b,x,t,t1; scanf(\"%ld\",&amp;x); if(x&lt;0) return 0; else if(x==0) printf(\"%d \",x); else if(x&gt;0) { t=x%10; t1=t; while(x&gt;0) { x=x/10; b=x%10; t=t*10+b; } t=t/10; while(t&gt;0) { printf(\"%d \",t%10); t=t/10; } if(t1==0) printf(\"0 \"); } return 0; }","link":"/2017/11/06/shryen4-2-8/"},{"title":"实验5-10 使用函数求余弦函数的近似值（15 分）","text":"实验5-10 使用函数求余弦函数的近似值（15 分）本题要求实现一个函数，用下列公式求cos(x)的近似值，精确到最后一项的绝对值小于e： $\\cos(x)=\\frac{x^0}{0!}−\\frac{x^2}{2!}+\\frac{x^4}{4!}−\\frac{x6}{6!}+\\cdots$ 函数接口定义：1double funcos( double e, double x ); 其中用户传入的参数为误差上限e和自变量x；函数funcos应返回用给定公式计算出来、并且满足误差要求的cos(x)的近似值。输入输出均在双精度范围内。 裁判测试程序样例：12345678910111213141516#include &lt;stdio.h&gt;#include &lt;math.h&gt;double funcos( double e, double x );int main(){ double e, x; scanf(\"%lf %lf\", &amp;e, &amp;x); printf(\"cos(%.2f) = %.6f\\n\", x, funcos(e, x)); return 0;}/* 你的代码将被嵌在这里 */ 输入样例：10.01 -3.14 输出样例：1cos(-3.14) = -0.999899 1234567891011121314151617181920212223242526272829#include &lt;stdio.h&gt;#include &lt;math.h&gt;double funcos( double e, double x );int main(){ double e, x; scanf(\"%lf %lf\", &amp;e, &amp;x); printf(\"cos(%.2f) = %.6f\\n\", x, funcos(e, x)); return 0;}double funcos( double e, double x ){ double i=0,m=0,k=1,n=1; double sum=0,d; do{ d=pow(x,i)/n; sum=sum+k*d; k=-k; i+=2; m=m+2; n=n*m*(m-1); } while(fabs(d)&gt;e); return sum; }","link":"/2017/11/28/shryen5-10/"},{"title":"实验5-11 使用函数求最大公约数（10 分）","text":"实验5-11 使用函数求最大公约数（10 分）本题要求实现一个计算两个数的最大公约数的简单函数。 函数接口定义：1int gcd( int x, int y ); 其中x和y是两个正整数，函数gcd应返回这两个数的最大公约数。 裁判测试程序样例：123456789101112131415#include &lt;stdio.h&gt;int gcd( int x, int y );int main(){ int x, y; scanf(\"%d %d\", &amp;x, &amp;y); printf(\"%d\\n\", gcd(x, y)); return 0;}/* 你的代码将被嵌在这里 */ 输入样例：132 72 输出样例：18 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;stdio.h&gt;int gcd( int x, int y );int main(){ int x, y; scanf(\"%d %d\", &amp;x, &amp;y); printf(\"%d\\n\", gcd(x, y)); return 0;}int gcd(int x,int y) { int r,t; if(x&lt;y) { t=x; x=y; y=t; } while ((r=x%y)!=0) { x=y; y=r; } return y; }/* 或者 */int gcd( int x, int y ){ int i; for(i=x;i&gt;=1;i--){ if(x%i==0&amp;&amp;y%i==0) break; } return i;}/* 或者 */int gcd(int x,int y) { int r; while (y) { r=x%y; x=y; y=r; } return x; }","link":"/2017/11/28/shryen5-11/"},{"title":"实验5-2 符号函数（10 分）","text":"实验5-2 符号函数（10 分）本题要求实现符号函数sign(x)。 函数接口定义：1int sign( int x ); 其中x是用户传入的整型参数。符号函数的定义为：若x大于0，sign(x) = 1；若x等于0，sign(x) = 0；否则，sign(x) = −1。 裁判测试程序样例：123456789101112131415#include &lt;stdio.h&gt;int sign( int x );int main(){ int x; scanf(\"%d\", &amp;x); printf(\"sign(%d) = %d\\n\", x, sign(x)); return 0;}/* 你的代码将被嵌在这里 */ 输入样例：110 输出样例：1sign(10) = 1 123456789101112131415161718192021222324#include &lt;stdio.h&gt;int sign( int x );int main(){ int x; scanf(\"%d\", &amp;x); printf(\"sign(%d) = %d\\n\", x, sign(x)); return 0;}int sign( int x ){ int f; if(x&gt;0){ f=1; } else if(x==0){ f=0; }else f=-1; return f; }","link":"/2017/11/28/shryen5-2/"},{"title":"实验5-3 使用函数求奇数和（15 分）","text":"实验5-3 使用函数求奇数和（15 分）本题要求实现一个函数，计算N个整数中所有奇数的和，同时实现一个判断奇偶性的函数。 函数接口定义：12int even( int n );int OddSum( int List[], int N ); 其中函数even将根据用户传入的参数n的奇偶性返回相应值：当n为偶数时返回1，否则返回0。函数OddSum负责计算并返回传入的N个整数List[]中所有奇数的和。 裁判测试程序样例：123456789101112131415161718192021222324#include &lt;stdio.h&gt;#define MAXN 10int even( int n );int OddSum( int List[], int N );int main(){ int List[MAXN], N, i; scanf(\"%d\", &amp;N); printf(\"Sum of ( \"); for ( i=0; i&lt;N; i++ ) { scanf(\"%d\", &amp;List[i]); if ( even(List[i])==0 ) printf(\"%d \", List[i]); } printf(\") = %d\\n\", OddSum(List, N)); return 0;}/* 你的代码将被嵌在这里 */ 输入样例：1262 -3 7 88 0 15 输出样例：1Sum of ( -3 7 15 ) = 19 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;stdio.h&gt;#define MAXN 10int even( int n );int OddSum( int List[], int N );int main(){ int List[MAXN], N, i; scanf(\"%d\", &amp;N); printf(\"Sum of ( \"); for ( i=0; i&lt;N; i++ ) { scanf(\"%d\", &amp;List[i]); if ( even(List[i])==0 ) printf(\"%d \", List[i]); } printf(\") = %d\\n\", OddSum(List, N)); return 0;}int even( int n ) { if(n%2==0) { return 1; }else { return 0; } } int OddSum( int List[], int N ) { int i,sum=0; for(i=0;i&lt;N;i++) { if(List[i]%2!=0) { sum=sum+List[i]; } } return sum; }","link":"/2017/11/28/shryen5-3/"},{"title":"实验5-6 使用函数判断完全平方数（10 分）","text":"实验5-6 使用函数判断完全平方数（10 分）本题要求实现一个判断整数是否为完全平方数的简单函数。 函数接口定义：1int IsSquare( int n ); 其中n是用户传入的参数，在长整型范围内。如果n是完全平方数，则函数IsSquare必须返回1，否则返回0。 裁判测试程序样例：1234567891011121314151617#include &lt;stdio.h&gt;#include &lt;math.h&gt;int IsSquare( int n );int main(){ int n; scanf(\"%d\", &amp;n); if ( IsSquare(n) ) printf(\"YES\\n\"); else printf(\"NO\\n\"); return 0;}/* 你的代码将被嵌在这里 */ 输入样例1：110 输出样例1：1NO 输入样例2：1100 输出样例2：1YES 1234567891011121314151617181920212223#include &lt;stdio.h&gt;#include &lt;math.h&gt;int IsSquare( int n );int main(){ int n; scanf(\"%d\", &amp;n); if ( IsSquare(n) ) printf(\"YES\\n\"); else printf(\"NO\\n\"); return 0;}int IsSquare( int n ) { int k; k=sqrt(n); if(k*k==n) return 1; else return 0; }","link":"/2017/11/28/shryen5-6/"},{"title":"实验5-5 使用函数求素数和（20 分）","text":"实验5-5 使用函数求素数和（20 分）本题要求实现一个判断素数的简单函数、以及利用该函数计算给定区间内素数和的函数。 素数就是只能被1和自身整除的正整数。注意：1不是素数，2是素数。 函数接口定义：12int prime( int p );int PrimeSum( int m, int n ); 其中函数prime当用户传入参数p为素数时返回1，否则返回0；函数PrimeSum返回区间[m, n]内所有素数的和。题目保证用户传入的参数m≤n。 裁判测试程序样例：12345678910111213141516171819202122#include &lt;stdio.h&gt;#include &lt;math.h&gt;int prime( int p );int PrimeSum( int m, int n );int main(){ int m, n, p; scanf(\"%d %d\", &amp;m, &amp;n); printf(\"Sum of ( \"); for( p=m; p&lt;=n; p++ ) { if( prime(p) != 0 ) printf(\"%d \", p); } printf(\") = %d\\n\", PrimeSum(m, n)); return 0;}/* 你的代码将被嵌在这里 */ 输入样例：1-1 10 输出样例：1Sum of ( 2 3 5 7 ) = 17 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;stdio.h&gt;#include &lt;math.h&gt;int prime( int p );int PrimeSum( int m, int n );int main(){ int m, n, p; scanf(\"%d %d\", &amp;m, &amp;n); printf(\"Sum of ( \"); for( p=m; p&lt;=n; p++ ) { if( prime(p) != 0 ) printf(\"%d \", p); } printf(\") = %d\\n\", PrimeSum(m, n)); return 0;}int prime( int p ) { int i; int k; if(p&gt;=2) { k=sqrt(p); for(i=2;i&lt;=k;i++) { if(p%i==0) break;} if(i&gt;k) return 1; else return 0; }else return 0; } int PrimeSum( int m, int n ) { int i,z,sum=0; int k; for(z=m;z&lt;=n;z++) if(prime(z)==1) sum=sum+z; return sum;}","link":"/2017/11/28/shryen5-5/"},{"title":"实验5-4 使用函数计算两点间的距离（10 分）","text":"实验5-4 使用函数计算两点间的距离（10 分）本题要求实现一个函数，对给定平面任意两点坐标$(x_1,y_1)$和$(x_2,y_2)$，求这两点之间的距离。 函数接口定义：1double dist( double x1, double y1, double x2, double y2 ); 其中用户传入的参数为平面上两个点的坐标(x1, y1)和(x2, y2)，函数dist应返回两点间的距离。 裁判测试程序样例：12345678910111213141516#include &lt;stdio.h&gt;#include &lt;math.h&gt;double dist( double x1, double y1, double x2, double y2 );int main(){ double x1, y1, x2, y2; scanf(\"%lf %lf %lf %lf\", &amp;x1, &amp;y1, &amp;x2, &amp;y2); printf(\"dist = %.2f\\n\", dist(x1, y1, x2, y2)); return 0;}/* 你的代码将被嵌在这里 */ 输入样例：110 10 200 100 输出样例：1dist = 210.24 1234567891011121314151617181920#include &lt;stdio.h&gt;#include &lt;math.h&gt;double dist( double x1, double y1, double x2, double y2 );int main(){ double x1, y1, x2, y2; scanf(\"%lf %lf %lf %lf\", &amp;x1, &amp;y1, &amp;x2, &amp;y2); printf(\"dist = %.2f\\n\", dist(x1, y1, x2, y2)); return 0;}double dist( double x1, double y1, double x2, double y2 ){ double f; f=sqrt(pow(x2-x1,2)+pow(y2-y1,2)); return f; }","link":"/2017/11/28/shryen5-4/"},{"title":"实验5-7 使用函数求1到10的阶乘和（10 分）","text":"实验5-7 使用函数求1到10的阶乘和（10 分）本题要求实现一个计算非负整数阶乘的简单函数，使得可以利用该函数，计算$1!+2!+\\cdots+10!$的值。 函数接口定义：1double fact( int n ); 其中n是用户传入的参数，其值不超过10。如果n是非负整数，则该函数必须返回n的阶乘。 裁判测试程序样例：123456789101112131415161718#include &lt;stdio.h&gt;double fact( int n );int main(void){ int i; double sum; sum = 0; for(i = 1; i &lt;= 10; i++) sum = sum + fact(i); printf(\"1!+2!+...+10! = %f\\n\", sum); return 0;}/* 你的代码将被嵌在这里 */ 输入样例：本题没有输入。 输出样例：11!+2!+...+10! = 4037913.000000 12345678910111213141516171819202122232425#include &lt;stdio.h&gt;double fact( int n );int main(void){ int i; double sum; sum = 0; for(i = 1; i &lt;= 10; i++) sum = sum + fact(i); printf(\"1!+2!+...+10! = %f\\n\", sum); return 0;}double fact( int n ) { int sum=1,i; if(n&gt;0) { for(i=1;i&lt;=n;i++) sum=sum*i; return sum; } }","link":"/2017/11/28/shryen5-7/"},{"title":"实验5-8 使用函数统计指定数字的个数（15 分）","text":"实验5-8 使用函数统计指定数字的个数（15 分）本题要求实现一个统计整数中指定数字的个数的简单函数。 函数接口定义：1int CountDigit( int number, int digit ); 其中number是不超过长整型的整数，digit为[0, 9]区间内的整数。函数CountDigit应返回number中digit出现的次数。 裁判测试程序样例：123456789101112131415#include &lt;stdio.h&gt;int CountDigit( int number, int digit );int main(){ int number, digit; scanf(\"%d %d\", &amp;number, &amp;digit); printf(\"Number of digit %d in %d: %d\\n\", digit, number, CountDigit(number, digit)); return 0;}/* 你的代码将被嵌在这里 */ 输入样例：1-21252 2 输出样例：1Number of digit 2 in -21252: 3 123456789101112131415161718192021222324252627282930#include &lt;stdio.h&gt;int CountDigit( int number, int digit );int main(){ int number, digit; scanf(\"%d %d\", &amp;number, &amp;digit); printf(\"Number of digit %d in %d: %d\\n\", digit, number, CountDigit(number, digit)); return 0;}int CountDigit( int number, int digit ) { int z, i= 0; if (number &lt; 0) number = -number; if (number == 0 &amp;&amp; digit == 0) i ++; else do{ z = number % 10; number=number/10; if (z==digit){ i ++; } } while(number!=0); return i; }","link":"/2017/11/28/shryen5-8/"},{"title":"实验5-9 使用函数输出水仙花数（20 分）","text":"实验5-9 使用函数输出水仙花数（20 分）水仙花数是指一个$N$位正整数$（N≥3）$，它的每个位上的数字的N次幂之和等于它本身。例如：$153=13+53+33$。 本题要求编写两个函数，一个判断给定整数是否水仙花数，另一个按从小到大的顺序打印出给定区间(m,n)内所有的水仙花数。 函数接口定义：12int narcissistic( int number );void PrintN( int m, int n ); 函数narcissistic判断number是否为水仙花数，是则返回1，否则返回0。 函数PrintN则打印开区间(m, n)内所有的水仙花数，每个数字占一行。题目保证100≤m≤n≤10000。 裁判测试程序样例：123456789101112131415161718#include &lt;stdio.h&gt;int narcissistic( int number );void PrintN( int m, int n );int main(){ int m, n; scanf(\"%d %d\", &amp;m, &amp;n); if ( narcissistic(m) ) printf(\"%d is a narcissistic number\\n\", m); PrintN(m, n); if ( narcissistic(n) ) printf(\"%d is a narcissistic number\\n\", n); return 0;}/* 你的代码将被嵌在这里 */ 输入样例：1153 400 输出样例：123153 is a narcissistic number370371 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;stdio.h&gt;#include&lt;math.h&gt;int narcissistic( int number );void PrintN( int m, int n );int main(){ int m, n; scanf(\"%d %d\", &amp;m, &amp;n); if ( narcissistic(m) ) printf(\"%d is a narcissistic number\\n\", m); PrintN(m, n); if ( narcissistic(n) ) printf(\"%d is a narcissistic number\\n\", n); return 0;}int narcissistic( int number ) { int i=0,k,sum=0,s; int a[999]; s=number; do { i++; a[i]=number%10; number=number/10; } while(number!=0); k=i; do { sum=sum+pow(a[i],k); i--; } while(i&gt;0); if(sum==s) return 1; else return 0; } void PrintN( int m, int n ) { int i,k,z; for(i=m+1;i&lt;n;i++) if(narcissistic(i)==1) printf(\"%d\\n\",i); }","link":"/2017/11/28/shryen5-9/"},{"title":"实验6-1 近似求PI（15 分）","text":"实验6-1 近似求PI（15 分）本题要求编写程序，根据下式求π的近似值，直到最后一项小于给定精度eps。 $\\frac{π}{2} =1+\\frac{1!}{3} +\\frac{2!}{3\\times5} + \\frac{3!}{3\\times5\\times7} +⋯+\\frac{i!}{3\\times5×⋯×(2\\times i+1)} \\times⋯$ 输入格式：输入在一行中给出精度eps，可以使用以下语句来读输入： 1scanf(&quot;%le&quot;, &amp;eps); 输出格式：在一行内，按照以下格式输出π的近似值（保留小数点后5位）： 1PI = 近似值 输入样例：11E-5 输出样例：1PI = 3.14158 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;stdio.h&gt;int main(){double eps,pi,fenzi,fenmu,sum,temp1,sum1,temp2;fenzi=1;temp1=1;temp2=3;fenmu=3;sum=1;sum1=1;scanf(\"%le\", &amp;eps);while(sum1&gt;eps){sum1=fenzi/fenmu;sum=sum+sum1;temp1++;temp2=temp2+2;fenzi=fenzi*temp1;fenmu=fenmu*temp2;}pi=sum*2;printf(\"%.5lf\",pi);return 0;}","link":"/2017/11/28/shryen6-1/"},{"title":"实验6-5 使用函数输出指定范围内的Fibonacci数（20 分）","text":"实验6-5 使用函数输出指定范围内的Fibonacci数（20 分）本题要求实现一个计算Fibonacci数的简单函数，并利用其实现另一个函数，输出两正整数$m \\text{和} n（0 \\lt m \\leq n\\leq 10000）$之间的所有Fibonacci数。所谓Fibonacci数列就是满足任一项数字是前两项的和（最开始两项均定义为1）的数列。 函数接口定义：12int fib( int n );void PrintFN( int m, int n ); 其中函数fib须返回第n项Fibonacci数；函数PrintFN要在一行中输出给定范围[m, n]内的所有Fibonacci数，相邻数字间有一个空格，行末不得有多余空格。如果给定区间内没有Fibonacci数，则输出一行“No Fibonacci number”。 裁判测试程序样例：1234567891011121314151617#include &lt;stdio.h&gt;int fib( int n );void PrintFN( int m, int n ); int main(){ int m, n, t; scanf(\"%d %d %d\", &amp;m, &amp;n, &amp;t); printf(\"fib(%d) = %d\\n\", t, fib(t)); PrintFN(m, n); return 0;}/* 你的代码将被嵌在这里 */ 输入样例1：120 100 7 输出样例1：12fib(7) = 1321 34 55 89 输入样例2：12000 2500 8 输出样例2：12fib(8) = 21No Fibonacci number 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;stdio.h&gt;int fib( int n );void PrintFN( int m, int n );int main(){ int m, n, t; scanf(\"%d %d %d\", &amp;m, &amp;n, &amp;t); printf(\"fib(%d) = %d\\n\", t, fib(t)); PrintFN(m, n); return 0;}int fib( int n ){if(n==1||n==2){return 1;}if(n&gt;2){return fib(n-1)+fib(n-2);}}void PrintFN( int m, int n ){int i=0,j,k=1,count=0;for(j=0;j&lt;=21;j++){ i++; if(fib(i)&gt;=m&amp;&amp;fib(i)&lt;=n){ count++; printf(\"%d \",fib(i));} }if(count==0){ printf(\"No Fibonacci number\");}}","link":"/2017/11/30/shryen6-5/"},{"title":"实验6-3 使用函数求特殊a串数列和（20 分）","text":"实验6-3 使用函数求特殊a串数列和（20 分）给定两个均不超过9的正整数$a$和$n$，要求编写函数求$a+aa+aaa++⋯+aa⋯a$（$n$个$a$）之和。 函数接口定义：12int fn( int a, int n );int SumA( int a, int n ); 其中函数fn须返回的是n个a组成的数字；SumA返回要求的和。 裁判测试程序样例：1234567891011121314151617#include &lt;stdio.h&gt;int fn( int a, int n );int SumA( int a, int n ); int main(){ int a, n; scanf(\"%d %d\", &amp;a, &amp;n); printf(\"fn(%d, %d) = %d\\n\", a, n, fn(a,n)); printf(\"s = %d\\n\", SumA(a,n)); return 0;}/* 你的代码将被嵌在这里 */ 输入样例：12 3 输出样例：12fn(2, 3) = 222s = 246 12345678910111213141516171819202122232425262728293031323334#include &lt;stdio.h&gt;#include&lt;math.h&gt;int fn( int a, int n );int SumA( int a, int n );int main(){ int a, n; scanf(\"%d %d\", &amp;a, &amp;n); printf(\"fn(%d, %d) = %d\\n\", a, n, fn(a,n)); printf(\"s = %d\\n\", SumA(a,n)); return 0;}int fn( int a, int n ){int sum=0,i,b=1;for(i=0;i&lt;n;i++){//b=b*10;sum=sum+a*b;b=b*10;}return sum;}int SumA( int a, int n ){int sum1=0,sum2,i;for(i=1;i&lt;n+1;i++){sum2=fn(a,i);sum1=sum1+sum2;}return sum1;}","link":"/2017/11/29/shryen6-3/"},{"title":"实验6-6 使用函数验证哥德巴赫猜想（20 分）","text":"实验6-6 使用函数验证哥德巴赫猜想（20 分）本题要求实现一个判断素数的简单函数，并利用该函数验证哥德巴赫猜想：任何一个不小于6的偶数均可表示为两个奇素数之和。素数就是只能被1和自身整除的正整数。注意：1不是素数，2是素数。 函数接口定义：12int prime( int p );void Goldbach( int n ); 其中函数prime当用户传入参数p为素数时返回1，否则返回0；函数Goldbach按照格式“n=p+q”输出n的素数分解，其中p≤q均为素数。又因为这样的分解不唯一（例如24可以分解为5+19，还可以分解为7+17），要求必须输出所有解中p最小的解。 裁判测试程序样例：1234567891011121314151617181920212223242526#include &lt;stdio.h&gt;#include &lt;math.h&gt;int prime( int p );void Goldbach( int n );int main(){ int m, n, i, cnt; scanf(\"%d %d\", &amp;m, &amp;n); if ( prime(m) != 0 ) printf(\"%d is a prime number\\n\", m); if ( m &lt; 6 ) m = 6; if ( m%2 ) m++; cnt = 0; for( i=m; i&lt;=n; i+=2 ) { Goldbach(i); cnt++; if ( cnt%5 ) printf(\", \"); else printf(\"\\n\"); } return 0;}/* 你的代码将被嵌在这里 */ 输入样例：189 100 输出样例：12389 is a prime number90=7+83, 92=3+89, 94=5+89, 96=7+89, 98=19+79100=3+97, 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;stdio.h&gt;#include &lt;math.h&gt;int prime( int p );void Goldbach( int n );int main() { int m, n, i, cnt; scanf(\"%d %d\", &amp;m, &amp;n); if ( prime(m) != 0 ) printf(\"%d is a prime number\\n\", m); if ( m &lt; 6 ) m = 6; if ( m%2 ) m++; cnt = 0; for( i=m; i&lt;=n; i+=2 ) { Goldbach(i); cnt++; if ( cnt%5 ) printf(\", \"); else printf(\"\\n\"); } return 0;}int prime( int p ) { int i,count=0; for(i=2; i&lt;p; i++) { if(p%i==0) { count++; } } if(count==0&amp;&amp;p!=1) { return 1; } else { return 0; }}void Goldbach( int n ) { int i,k; if(prime(n) == 0) { for(i=2; i&lt;n; i++) { if(prime(i)!=0) { k=n-i; if(prime(k)!=0) { printf(\"%d=%d+%d\",n,i,k); break; } } } }}","link":"/2017/11/30/shryen6-6/"},{"title":"实验6-4 使用函数输出指定范围内的完数（20 分）","text":"实验6-4 使用函数输出指定范围内的完数（20 分）本题要求实现一个计算整数因子和的简单函数，并利用其实现另一个函数，输出两正整数$m\\text{和}n（0\\lt m\\leq n\\leq 10000）$之间的所有完数。所谓完数就是该数恰好等于除自身外的因子之和。例如：$6=1+2+3$，其中1、2、3为6的因子。 函数接口定义：12int factorsum( int number );void PrintPN( int m, int n ); 其中函数factorsum须返回int number的因子和；函数PrintPN要逐行输出给定范围[m, n]内每个完数的因子累加形式的分解式，每个完数占一行，格式为“完数 = 因子1 + 因子2 + … + 因子k”，其中完数和因子均按递增顺序给出。如果给定区间内没有完数，则输出一行“No perfect number”。 裁判测试程序样例：123456789101112131415161718#include &lt;stdio.h&gt;int factorsum( int number );void PrintPN( int m, int n ); int main(){ int i, m, n; scanf(\"%d %d\", &amp;m, &amp;n); if ( factorsum(m) == m ) printf(\"%d is a perfect number\\n\", m); if ( factorsum(n) == n ) printf(\"%d is a perfect number\\n\", n); PrintPN(m, n); return 0;}/* 你的代码将被嵌在这里 */ 输入样例1：11 30 输出样例1：12341 is a perfect number1 = 16 = 1 + 2 + 328 = 1 + 2 + 4 + 7 + 14 输入样例2：17 25 输出样例2：1No perfect number 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;stdio.h&gt;#define N 100int factorsum( int number );void PrintPN( int m, int n ); int main(){ int i, m, n; scanf(\"%d %d\", &amp;m, &amp;n); if ( factorsum(m) == m ) printf(\"%d is a perfect number\\n\", m); if ( factorsum(n) == n ) printf(\"%d is a perfect number\\n\", n); PrintPN(m, n); return 0;}int factorsum( int number ){ int a[N],i,j=0,n=0,sum=0; if(number == 1) return 1; for(i=1;i&lt;number;i++) if(number%i==0){ a[j++]=i; } for(i=0;i&lt;j;i++) sum+=a[i]; if(sum == number) return 1; return 0; } void PrintPN( int m, int n ){ int i,j,k=0,l,a[N]; if(m==1){ printf(\"%d = %d\\n\",m , m); m+=1; } for(i=m;i&lt;=n;i++){ if(factorsum(i)==1){ for(j=1;j&lt;i;j++){ if(i%j==0){ a[k++]=j; } } printf(\"%d = \", i); for(l=0;l&lt;k-1;l++) printf(\"%d + \", a[l]); printf(\"%d\\n\", a[l]); k=0; } } } }","link":"/2017/11/29/shryen6-4/"},{"title":"实验6-2 分类统计字符个数（15 分）","text":"实验6-2 分类统计字符个数（15 分）本题要求实现一个函数，统计给定字符串中英文字母、空格或回车、数字字符和其他字符的个数。 函数接口定义：1void StringCount( char s[] ); 其中 char s[] 是用户传入的字符串。函数StringCount须在一行内按照 1letter = 英文字母个数, blank = 空格或回车个数, digit = 数字字符个数, other = 其他字符个数 的格式输出。 裁判测试程序样例：1234567891011121314151617#include &lt;stdio.h&gt;#define MAXS 15void StringCount( char s[] );void ReadString( char s[] ); /* 由裁判实现，略去不表 */int main(){ char s[MAXS]; ReadString(s); StringCount(s); return 0;}/* Your function will be put here */ 输入样例：12aZ &amp;09 Az 输出样例：1letter = 4, blank = 3, digit = 2, other = 1 123456789101112131415161718192021222324252627282930313233#include &lt;stdio.h&gt;#define MAXS 15void StringCount( char s[] );void ReadString( char s[] ); /* 由裁判实现，略去不表 */int main(){ char s[MAXS]; ReadString(s); StringCount(s); return 0;}void ReadString(char s[]){ gets(s);}void StringCount(char s[]){ int letter=0,blank=0,digit=0,other=0; int i; for(i=0;s[i]!='\\0';i++){ if(s[i]&gt;='A'&amp;&amp;s[i]&lt;='Z'||s[i]&gt;='a'&amp;&amp;s[i]&lt;='z'){ letter++; }else if(s[i]==' '||s[i]=='\\n'){ blank++; }else if(s[i]&gt;='0'&amp;&amp;s[i]&lt;='9'){ digit++; }else other++; } printf(\"letter = %d,blank = %d,digit = %d, other = %d\\n\",letter,blank,digit,other);}","link":"/2017/11/28/shryen6-2/"},{"title":"实验7-1-1 简化的插入排序（15 分）","text":"实验7-1-1 简化的插入排序（15 分）本题要求编写程序，将一个给定的整数插到原本有序的整数序列中，使结果序列仍然有序。 输入格式：输入在第一行先给出非负整数$N（\\lt 10）$；第二行给出N个从小到大排好顺序的整数；第三行给出一个整数X。 输出格式：在一行内输出将X插入后仍然从小到大有序的整数序列，每个数字后面有一个空格。 输入样例：12351 2 4 5 73 输出样例：11 2 3 4 5 7 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;stdio.h&gt;int main(){ int N; scanf(\"%d\",&amp;N); int i; int a[10]; for(i=0;i&lt;N;i++){ scanf(\"%d\",&amp;a[i]); } int x; scanf(\"%d\",&amp;x); int j; for(i=0;i&lt;N;i++){ if(x&gt;a[i]){ continue; } else { j=N-1; while(j&gt;=i){ a[j+1]=a[j]; j--; } a[i]=x; break; } } if(i==N){ a[N]=x; } for(i=0;i&lt;N+1;i++){ printf(\"%d \",a[i]); } putchar('\\n'); return 0;}","link":"/2017/12/01/shryen7-1-1/"},{"title":"实验6-8 简单计算器（20 分）","text":"实验6-8 简单计算器（20 分）模拟简单运算器的工作。假设计算器只能进行加减乘除运算，运算数和结果都是整数，四种运算符的优先级相同，按从左到右的顺序计算。 输入格式:输入在一行中给出一个四则运算算式，没有空格，且至少有一个操作数。遇等号”=”说明输入结束。 输出格式:在一行中输出算式的运算结果，或者如果除法分母为0或有非法运算符，则输出错误信息“ERROR”。 输入样例:11+2*10-10/2= 输出样例:110 123456789101112131415161718192021222324252627282930313233#include&lt;stdio.h&gt;int main(void){int a,b;char ch;scanf(\"%d %c %d\",&amp;a,&amp;ch,&amp;b);if(ch!='+'&amp;&amp;ch!='-'&amp;&amp;ch!='*'&amp;&amp;ch!='/'&amp;&amp;ch!='%')printf(\"ERROR\");else{if(ch=='+') printf(\"%d\",a+b);if(ch=='-') printf(\"%d\",a-b);if(ch=='*') printf(\"%d\",a*b);if(ch=='/') printf(\"%d\",a/b);if(ch=='%') printf(\"%d\",a%b);}return 0;}","link":"/2017/11/30/shryen6-8/"},{"title":"实验6-7 使用函数输出一个整数的逆序数（20 分）","text":"实验6-7 使用函数输出一个整数的逆序数（20 分）本题要求实现一个求整数的逆序数的简单函数。 函数接口定义：1int reverse( int number ); 其中函数reverse须返回用户传入的整型number的逆序数。 裁判测试程序样例：123456789101112131415#include &lt;stdio.h&gt;int reverse( int number );int main(){ int n; scanf(\"%d\", &amp;n); printf(\"%d\\n\", reverse(n)); return 0;}/* 你的代码将被嵌在这里 */ 输入样例：1-12340 输出样例：1-4321 1234567891011121314151617181920212223242526272829303132#include &lt;stdio.h&gt;int reverse( int number );int main(){ int n; scanf(\"%d\", &amp;n); printf(\"%d\\n\", reverse(n)); return 0;}/* -12340 -&gt; -4321 */int reverse( int number ){ int i=1,a,sum=0; if(number&lt;0){ number=-number; i=-1; } while(number){ a = number%10; sum = sum * 10 +a; number/=10; } sum*=i; return sum;}","link":"/2017/11/30/shryen6-7/"},{"title":"实验6-9 统计一行文本的单词个数（15 分）","text":"实验6-9 统计一行文本的单词个数（15 分）本题目要求编写程序统计一行字符中单词的个数。所谓“单词”是指连续不含空格的字符串，各单词之间用空格分隔，空格数可以是多个。 输入格式:输入给出一行字符。 输出格式:在一行中输出单词个数。 输入样例:1Let&apos;s go to room 209. 输出样例:15 1234567891011121314151617181920#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main(){ char a[1000]; gets(a); int m,i,j; m=strlen(a); if(a[0]==' ') j=0; else j=1; for(i=0;i&lt;m-1;i++) { if(a[i]==' ' &amp;&amp; a[i+1]!=' ') j++; } printf(\"%d\\n\",j); return 0; }","link":"/2017/11/30/shryen6-9/"},{"title":"实验7-1-11 求整数序列中出现次数最多的数（15 分）","text":"实验7-1-11 求整数序列中出现次数最多的数（15 分）本题要求统计一个整型序列中出现次数最多的整数及其出现次数。 输入格式：输入在一行中给出序列中整数个数$N（0\\lt N\\le 1000）$，以及$N$个整数。数字间以空格分隔。 输出格式：在一行中输出出现次数最多的整数及其出现次数，数字间以空格分隔。题目保证这样的数字是唯一的。 输入样例：110 3 2 -1 5 3 4 3 0 3 2 输出样例：13 4 12345678910111213141516171819202122#include&lt;stdio.h&gt;int main(void){ int a[1000],b[1000]={0},n,i,j,max,f=1,flag=1; scanf(\"%d\",&amp;n); for(i=0;i&lt;n;i++){ scanf(\"%d\",&amp;a[i]); } for(i=0;i&lt;n;i++){ for(j=0;j&lt;i;j++){ if(a[j]==a[i]){b[j]++;break;f=0;} } if(f) b[i]++; } max=b[0]; for(i=0;i&lt;n;i++){ if(max&lt;b[i]){max=b[i];j=i;flag=0;} } if(flag) j=0; printf(\"%d %d\\n\",a[j],max); return 0;}","link":"/2017/12/11/shryen7-1-11/"},{"title":"实验7-1-10 交换最小值和最大值（15 分）","text":"实验7-1-10 交换最小值和最大值（15 分）本题要求编写程序，先将输入的一系列整数中的最小值与第一个数交换，然后将最大值与最后一个数交换，最后输出交换后的序列。 注意：题目保证最大和最小值都是唯一的。 输入格式：输入在第一行中给出一个正整数N（≤10），第二行给出N个整数，数字间以空格分隔。 输出格式：在一行中顺序输出交换后的序列，每个整数后跟一个空格。 输入样例：1258 2 5 1 4 输出样例：11 2 5 4 8 12345678910111213141516171819202122232425262728293031323334#include &lt;stdio.h&gt; int main(void) { int i,index,n,t; int a[10]; scanf(\"%d\",&amp;n); for(i=0;i&lt;n;i++){ scanf(\"%d\",&amp;a[i]); } index=0; for(i=1;i&lt;n;i++){ if(a[i]&lt;a[index]){ index=i; } } t=a[index]; /*最小值与第一个数交换 */ a[index]=a[0]; a[0]=t; index=0; for(i=1;i&lt;n;i++){ if(a[i]&gt;a[index]){ index=i; } } t=a[index]; /*最大值与最后一个数交换 */ a[index]=a[n-1]; a[n-1]=t; for(i=0;i&lt;n;i++){ printf(\"%d \",a[i]); } printf(\"\\n\"); }","link":"/2017/12/08/shryen7-1-10/"},{"title":"实验7-1-12 组个最小数（20 分）","text":"实验7-1-12 组个最小数（20 分）给定数字0-9各若干个。你可以以任意顺序排列这些数字，但必须全部使用。目标是使得最后得到的数尽可能小（注意0不能做首位）。例如：给定两个0，两个1，三个5，一个8，我们得到的最小的数就是10015558。 现给定数字，请编写程序输出能够组成的最小的数。 输入格式：输入在一行中给出10个非负整数，顺序表示我们拥有数字0、数字1、……数字9的个数。整数间用一个空格分隔。10个数字的总个数不超过50，且至少拥有1个非0的数字。 输出格式：在一行中输出能够组成的最小的数。 输入样例：12 2 0 0 0 3 0 0 1 0 输出样例：110015558 123456789101112131415161718192021222324#include&lt;stdio.h&gt;int main(){ int a[10]={0},i,j; for(i=0;i&lt;10;i++) scanf(\"%d\",&amp;a[i]); for(i=1;i&lt;10;i++)//先输出第一个数 { if(a[i]&gt;0) { printf(\"%d\",i); a[i]--; break; } } for(i=0;i&lt;10;i++)//后面从小到大全部输出完 { for(j=0;j&lt;a[i];j++) { printf(\"%d\",i); } } return 0;}","link":"/2017/12/11/shryen7-1-12/"},{"title":"实验7-1-13 装箱问题（20 分）","text":"实验7-1-13 装箱问题（20 分）假设有N项物品，大小分别为s1、s2、…、si、…、sN，其中si为满足$1\\le si\\le 100$的整数。要把这些物品装入到容量为100的一批箱子（序号1-N）中。装箱方法是：对每项物品, 顺序扫描箱子，把该物品放入足以能够容下它的第一个箱子中。请写一个程序模拟这种装箱过程，并输出每个物品所在的箱子序号，以及放置全部物品所需的箱子数目。 输入格式：输入第一行给出物品个数$N（\\le 1000）$；第二行给出N个正整数$si$（$1\\le si \\le 100$，表示第i项物品的大小）。 输出格式：按照输入顺序输出每个物品的大小及其所在的箱子序号，每个物品占1行，最后一行输出所需的箱子数目。 输入样例：12860 70 80 90 30 40 10 20 输出样例：12345678960 170 280 390 430 140 510 120 25 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;#include &lt;ctype.h&gt;#define TSIZE 45int main(){ int n,i,j,flag,max; int s[1000]; int dun[1000]; int biao[1000]; while(scanf(\"%d\",&amp;n)!=EOF) { for(i=0;i&lt;100;i++) { biao[i]=-1; } for(i=0;i&lt;n;i++) { scanf(\"%d\",&amp;s[i]); dun[i]=s[i]; } biao[0]=0; for(i=1;i&lt;n;i++) { for(j=0;j&lt;i;j++) { flag=0; if(dun[i]+dun[j]&lt;=100) { dun[j]=dun[j]+dun[i]; dun[i]=0; biao[i]=j; flag=1; break; } } if(flag==0) { biao[i]=i; } } max=0; for(i=0;i&lt;n;i++) { if(biao[i]&gt;max) max=biao[i]; } for(i=0;i&lt;n;i++) printf(\"%d %d\\n\",s[i],biao[i]+1); printf(\"%d\\n\",max+1); } return 0;}","link":"/2017/12/11/shryen7-1-13/"},{"title":"实验7-1-2 求最大值及其下标（20 分）","text":"实验7-1-2 求最大值及其下标（20 分）本题要求编写程序，找出给定的$n$个数中的最大值及其对应的最小下标（下标从0开始）。 输入格式:输入在第一行中给出一个正整数$n（1\\lt n \\leq 10）$。第二行输入$n$个整数，用空格分开。 输出格式:在一行中输出最大值及最大值的最小下标，中间用一个空格分开。 输入样例:1262 8 10 1 9 10 输出样例:110 2 12345678910111213141516171819#include &lt;stdio.h&gt; int main( ) { int i, index, n, temp; int a[10]; scanf(\"%d\", &amp;n); for(i = 0; i &lt; n; i++) scanf(\"%d\", &amp;a[i]); index=0; a[index]=a[0]; for(i=1;i&lt;n;i++){ if(a[index]&lt;a[i]){ a[index]=a[i]; index=i; } } printf(\"%d %d\\n\", a[index],index); }","link":"/2017/12/01/shryen7-1-2/"},{"title":"实验7-1-3 将数组中的数逆序存放（20 分）","text":"实验7-1-3 将数组中的数逆序存放（20 分）本题要求编写程序，将给定的$n$个整数存入数组中，将数组中的这$n$个数逆序存放，再按顺序输出数组中的元素。 输入格式:输入在第一行中给出一个正整数$n（1\\le n\\le 10）$。第二行输入$n$个整数，用空格分开。 输出格式:在一行中输出这$n$个整数的处理结果，相邻数字中间用一个空格分开，行末不得有多余空格。 输入样例:12410 8 1 2 输出样例:12 1 8 10 123456789101112131415161718192021222324#include&lt;stdio.h&gt;int main(void){ int i,n,temp; int ri; int a[10]; scanf(\"%d\",&amp;n); for(i=0;i&lt;n;i++) scanf(\"%d\",&amp;a[i]); i=0; for(i=0;i&lt;n/2;i++) { temp=a[i]; a[i]=a[n-1-i]; a[n-1-i]=temp; } for(i=0;i&lt;n;i++) printf(\"%d \",a[i]); putchar('\\n'); }","link":"/2017/12/01/shryen7-1-3/"},{"title":"实验7-1-5 选择法排序（20 分）","text":"实验7-1-5 选择法排序（20 分）本题要求将给定的n个整数从大到小排序后输出。 输入格式：输入第一行给出一个不超过10的正整数n。第二行给出n个整数，其间以空格分隔。 输出格式：在一行中输出从大到小有序的数列，相邻数字间有一个空格，行末不得有多余空格。 输入样例：1245 1 7 6 输出样例：17 6 5 1 123456789101112131415161718192021222324252627282930#include&lt;stdio.h&gt;int main(void){ int i,index,k,n,temp; int a[10]; scanf(\"%d\",&amp;n); for(i=0;i&lt;n;i++) scanf(\"%d\",&amp;a[i]); for(k=0;k&lt;n-1;k++) { index=k; for(i=k+1;i&lt;n;i++) if(a[i]&gt;a[index]){ index=i; } temp=a[index]; a[index]=a[k]; a[k]=temp; } for(i=0;i&lt;n;i++) printf(\"%d \",a[i]); putchar('\\n'); }","link":"/2017/12/01/shryen7-1-5/"},{"title":"实验7-1-4 找出不是两个数组共有的元素（20 分）","text":"实验7-1-4 找出不是两个数组共有的元素（3 分）给定两个整型数组，本题要求找出不是两者共有的元素。 输入格式:输入分别在两行中给出两个整型数组，每行先给出正整数$N（\\le 20）$，随后是$N$个整数，其间以空格分隔。 输出格式:在一行中按照数字给出的顺序输出不是两数组共有的元素，数字间以空格分隔，但行末不得有多余的空格。题目保证至少存在一个这样的数字。同一数字不重复输出。 输入样例:1210 3 -5 2 8 0 3 5 -15 9 10011 6 4 8 2 6 -5 9 0 100 8 1 输出样例:13 5 -15 6 4 1 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;stdio.h&gt;int main(void){ int n,m,a[20],b[20],c[40],i,j,d,k=0,f,e=0,flag1,flag2; scanf(\"%d\",&amp;n); for(i=0;i&lt;n;i++){ scanf(\"%d\",&amp;a[i]); } scanf(\"%d\",&amp;m); for(j=0;j&lt;m;j++){ scanf(\"%d\",&amp;b[j]); } for(i=0;i&lt;n;i++) for(j=0;j&lt;m;j++){ if(a[i]==b[j]){ c[k]=a[i];k++; } } if(k==0){ for(i=0;i&lt;n;i++){ if(e==0){printf(\"%d\",a[i]);e++;} else printf(\" %d\",a[i]); } for(j=0;j&lt;m;j++){ if(e==0){printf(\"%d\",b[j]);e++;} else printf(\" %d\",b[j]); } } for(i=0;i&lt;n;i++){ flag1=1; for(j=0;j&lt;k;j++){ if(a[i]!=c[j]) f=1; else{f=0;break;} } if(f){ for(d=0;d&lt;i;++d){ if(a[d]==a[i]) {flag1=0;break;} } if(flag1){ if(e==0){printf(\"%d\",a[i]);e++;} else printf(\" %d\",a[i]); } } } for(i=0;i&lt;m;i++){ for(j=0;j&lt;k;j++){ flag2=1; if(b[i]!=c[j]) f=1; else{f=0;break;} } if(f){ for(d=0;d&lt;i;++d){ if(b[d]==b[i]){flag2=0;break;} } if(flag2){ if(e==0){printf(\"%d\",b[i]);e++;} else printf(\" %d\",b[i]); } } } return 0;}","link":"/2017/12/01/shryen7-1-4/"},{"title":"实验7-1-6 求一批整数中出现最多的个位数字（20 分）","text":"实验7-1-6 求一批整数中出现最多的个位数字（20 分）给定一批整数，分析每个整数的每一位数字，求出现次数最多的个位数字。例如给定3个整数1234、2345、3456，其中出现最多次数的数字是3和4，均出现了3次。 输入格式：输入在第1行中给出正整数$N（\\le 1000）$，在第二行中给出N个不超过整型范围的非负整数，数字间以空格分隔。 输出格式：在一行中按格式“M: n1 n2 …”输出，其中M是最大次数，n1、n2、……为出现次数最多的个位数字，按从小到大的顺序排列。数字间以空格分隔，但末尾不得有多余空格。 输入样例：1231234 2345 3456 输出样例：13: 3 4 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;stdio.h&gt;int main(){ int num[1000]; //输入正整数N int n; scanf(\"%d\",&amp;n); //输入N个正整数存入数组Num int i; for(i=0;i&lt;n;i++){ scanf(\"%d\",&amp;num[i]); } int count[10]={0};//0-9计数 int a,temp,mask ; for(i=0;i&lt;n;i++){ temp = num[i]; mask = 1; while(temp &gt; 9){ temp /= 10; mask *= 10; } while(mask&gt;0){ a = num[i] / mask; count[a]++; num[i] %= mask; mask /= 10; } } int max[10],nmax=0; int numOfMax=0; //遍历count[]，找出最大值，并且存入max[] max[0] = -1; for(i=0;i&lt;10;i++){ if(count[i] &gt; numOfMax){ nmax = 0; numOfMax = count[i]; max[nmax] = i; } else if(count[i] == numOfMax){ nmax++; max[nmax] = i; } } //输出 printf(\"%d:\",numOfMax); for(i=0;i&lt;=nmax;i++){ printf(\" %d\",max[i]); } return 0;}","link":"/2017/12/07/shryen7-1-6/"},{"title":"实验7-1-9 数字加密（15 分）","text":"实验7-1-9 数字加密（15 分）输入一个四位数，将其加密后输出。方法是将该数每一位上的数字加9，然后除以10取余，做为该位上的新数字，最后将千位和十位上的数字互换，百位和个位上的数字互换，组成加密后的新四位数。例如输入1257，经过加9取余后得到新数字0146，再经过两次换位后得到4601。 输入格式：输入在一行中给出一个四位的整数x，即要求被加密的数。 输出格式：在一行中按照格式“The encrypted number is V”输出加密后得到的新数V。 输入样例：11257 输出样例：1The encrypted number is 4601 123456789101112131415#include &lt;stdio.h&gt; void main( ) { int number, digit1, digit2, digit3, digit4, newnum; scanf(\"%d\", &amp;number); digit1=number/1000; digit2=number%1000/100; digit3=number%1000%100/10; digit4=number%1000%100%10; digit1=(digit1+9)%10; digit2=(digit2+9)%10; digit3=(digit3+9)%10; digit4=(digit4+9)%10; newnum=digit3*1000+digit4*100+digit1*10+digit2; printf(\"The encrypted number is %d\\n\", newnum);}","link":"/2017/12/07/shryen7-1-9/"},{"title":"实验7-1-8 输出数组元素（15 分）","text":"实验7-1-8 输出数组元素（15 分）本题要求编写程序，对顺序读入的$n$个整数，顺次计算后项减前项之差，并按每行三个元素的格式输出结果。 输入格式：输入的第一行给出正整数$n（1\\lt n\\le 10）$。随后一行给出$n$个整数，其间以空格分隔。 输出格式：顺次计算后项减前项之差，并按每行三个元素的格式输出结果。数字间空一格，行末不得有多余空格。 输入样例：12105 1 7 14 6 36 4 28 50 100 输出样例：123-4 6 7-8 30 -3224 22 50 12345678910111213141516#include&lt;stdio.h&gt;void main(){ int a[10], b[10], i,j; scanf(\"%d\",&amp;j); for(i=0;i&lt;j;i++) scanf(\"%d\",&amp;a[i]); for(i=1;i&lt;j;i++) b[i-1]=a[i]-a[i-1]; for(i=0;i&lt;j-1;i++) { printf(\"%3d\",b[i]); if(i%3==0) printf(\"\\n\"); } }}","link":"/2017/12/07/shryen7-1-8/"},{"title":"实验7-1-7 查找整数（10 分）","text":"实验7-1-7 查找整数（10 分）本题要求从输入的$N$个整数中查找给定的X。如果找到，输出X的位置（从0开始数）；如果没有找到，输出“Not Found”。 输入格式：输入在第一行中给出两个正整数$N（\\le 20）$和X，第二行给出N个整数。数字均不超过长整型，其间以空格分隔。 输出格式：在一行中输出X的位置，或者“Not Found”。 输入样例1：125 73 5 7 1 9 输出样例1：12 输入样例2：125 73 5 8 1 9 输出样例2：1Not Found 123456789101112131415161718#include&lt;stdio.h&gt;int main(){ int n,x,i,flag=1; scanf(\"%d %d\",&amp;n,&amp;x); long int str[25]; for(i=0;i&lt;n;i++){ scanf(\"%ld\",&amp;str[i]); } for(i=0;i&lt;n;i++){ if(str[i]==x){ printf(\"%d\",i); flag=0; } } if(flag) printf(\"Not Found\"); return 0;}","link":"/2017/12/07/shryen7-1-7/"},{"title":"实验7-2-1 求矩阵各行元素之和（15 分）","text":"实验7-2-1 求矩阵各行元素之和（15 分）本题要求编写程序，求一个给定的$m×n$矩阵各行元素之和。 输入格式：输入第一行给出两个正整数$m$和$n（1≤m,n≤6）$。随后m行，每行给出$n$个整数，其间 以空格分隔。 输出格式：每行输出对应矩阵行元素之和。 输入样例：12343 26 31 -83 12 输出样例：1239-715 123456789101112131415161718#include&lt;stdio.h&gt; main() { int i,j,m,n,sum; printf(\"输入正整数m和n（1&lt;=m,n&lt;=6）:\"); scanf(\"%d%d\",&amp;m,&amp;n); int a[m][n]; printf(\"输入数:\\n\"); for(i=0;i&lt;m;i++) for(j=0;j&lt;n;j++) scanf(\"%d\",&amp;a[i][j]); for(i=0;i&lt;m;i++){ sum=0; for(j=0;j&lt;n;j++){ sum+=a[i][j]; } printf(\"第%d行的和为：%d\\n\",i+1,sum); } return 0; }","link":"/2017/12/11/shryen7-2-1/"},{"title":"实验7-2-10 简易连连看（20 分）","text":"实验7-2-10 简易连连看（20 分）本题要求实现一个简易连连看游戏模拟程序。 给定一个$2N\\times2N$的方阵网格游戏盘面，每个格子中放置一些符号。这些符号一定是成对出现的，同一个符号可能不止一对。程序读入玩家给出的一对位置$(x_1,y_1)、(x_2,y_2)$，判断这两个位置上的符号是否匹配。如果匹配成功，则将两个符号消为“*”并输出消去后的盘面；否则输出“Uh-oh”。若匹配错误达到3次，则输出“Game Over”并结束游戏。或者当全部符号匹配成功，则输出“Congratulations!”，然后结束游戏。 输入格式：输入在一行中给一个正整数$N$（&lt;5）。随后$2N$行，每行$2N$个大写英文字母（其间以1个空格分隔），表示游戏盘面。盘面之后给出一个正整数K，随后K行，每行按照格式“$x_1 y_1 x_2 y_2$”给出一个玩家的输入。注意格子的行、列编号是从1到$2N$。 输出格式：根据玩家的每一步输入，输出相应的结果。输出盘面时注意，每行字符间以1个空格分隔，行末不得有多余空格。 输入样例1：12345678910111213141516172I T I TY T I AT A T YI K K T111 1 1 34 2 4 33 1 4 22 2 1 23 1 2 44 4 3 12 1 3 43 3 1 44 1 2 32 4 3 21 1 2 2 输出样例1：12345678910111213141516171819202122232425262728293031* T * TY T I AT A T YI K K T* T * TY T I AT A T YI * * TUh-oh* * * TY * I AT A T YI * * TUh-oh* * * TY * I A* A T YI * * ** * * T* * I A* A T *I * * ** * * ** * I A* A * *I * * ** * * ** * * A* A * ** * * *Congratulations! 输入样例2：12345678910112I T I TY T I AT A T YI K K T51 1 4 41 1 2 31 1 2 32 2 4 12 2 3 3 输出样例2：12345678Uh-oh* T I TY T * AT A T YI K K TUh-ohUh-ohGame Over 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(void){ int x1,y1,x2,y2; int i,j,k; int N;//题目中的N char array[10][10]; int count=0;//计次匹配错误的次数 int m=0;//玩家输入的次数 int letterLeft;//盘面中剩余的字母个数，当减少到0时，则胜利 scanf(\"%i\",&amp;N); getchar(); letterLeft=2*N*2*N; for(i=0;i&lt;(2*N);i++) for(j=0;j&lt;(2*N);j++){ array[i][j]=getchar(); getchar(); } scanf(\"%d\",&amp;m); getchar(); for(i=0;i&lt;m;i++){ scanf(\"%d %d %d %d\",&amp;x1,&amp;y1,&amp;x2,&amp;y2); //匹配成功，则将两个符号消为“*” if((array[x1-1][y1-1]==array[x2-1][y2-1]) &amp;&amp; (array[x1-1][y1-1]&lt;='Z' &amp;&amp; array[x1-1][y1-1]&gt;='A')){ array[x1-1][y1-1]='*'; array[x2-1][y2-1]='*'; letterLeft=letterLeft-2; } else{ printf(\"Uh-oh\\n\"); count++; continue; } //若匹配错误达到3次，则输出“Game Over”并结束游戏 if(count==3){ printf(\"Game Over\\n\"); exit(0); } //当全部符号匹配成功，则输出“Congratulations!”，然后结束游戏 if(letterLeft==0){ printf(\"Congratulations!\\n\"); exit(0); } //输出盘面 for(j=0;j&lt;2*N;j++){ for(k=0;k&lt;2*N-1;k++) printf(\"%c \",array[j][k]); printf(\"%c\\n\",array[j][2*N-1]); } } return 0;}","link":"/2017/12/20/shryen7-2-10/"},{"title":"实验7-2-2 矩阵运算（20 分）","text":"实验7-2-2 矩阵运算（20 分）给定一个$n×n$的方阵，本题要求计算该矩阵除副对角线、最后一列和最后一行以外的所有元素之和。副对角线为从矩阵的右上角至左下角的连线。 输入格式:输入第一行给出正整数$n（1&lt;n≤10）$；随后$n$行，每行给出$n$个整数，其间以空格分隔。 输出格式:在一行中给出该矩阵除副对角线、最后一列和最后一行以外的所有元素之和。 输入样例:1234542 3 4 15 6 1 17 1 8 11 1 1 1 输出样例:135 123456789101112131415161718192021222324252627#include&lt;stdio.h&gt;int main(void){ int a[6][6]; int i,j,sum,n; printf(\"Input n: \"); scanf(\"%d\",&amp;n); printf(\"Input array: \\n\"); for(i=0;i&lt;n;i++){ //this for(j=0;j&lt;n;j++) //and this scanf(\"%d\",&amp;a[i][j]); } sum=0; for(i=0;i&lt;n;i++) for(j=0;j&lt;n;j++) { if((i+j!=(n-1))&amp;&amp;(i!=(n-1))&amp;&amp;(j!=(n-1))) sum=sum+a[i][j]; } printf(\"sum=%d\\n\",sum); return 0; }","link":"/2017/12/11/shryen7-2-2/"},{"title":"实验7-2-5 判断上三角矩阵（15 分）","text":"实验7-2-5 判断上三角矩阵（15 分）上三角矩阵指主对角线以下的元素都为0的矩阵；主对角线为从矩阵的左上角至右下角的连线。 本题要求编写程序，判断一个给定的方阵是否上三角矩阵。 输入格式：输入第一行给出一个正整数$T$，为待测矩阵的个数。接下来给出$T$个矩阵的信息：每个矩阵信息的第一行给出一个不超过10的正整数$n$。随后$n$行，每行给出$n$个整数，其间以空格分隔。 输出格式：每个矩阵的判断结果占一行。如果输入的矩阵是上三角矩阵，输出“YES”，否则输出“NO”。 输入样例：12345678231 2 30 4 50 0 621 0-8 2 输出样例：12YESNO 1234567891011121314151617181920212223242526272829#include&lt;stdio.h&gt;int main(){ int n; scanf(\"%d\",&amp;n); while (n--) { int flag=1; int i=0; int size=0; int num=0; scanf(\"%d\",&amp;size); for (i=0;i&lt;size*size;i++) { scanf(\"%d\",&amp;num); if ((i/size&gt;i%size)&amp;&amp;num!=0) flag=0; } printf(flag?\"Yes\\n\":\"No\\n\"); } return 0;}","link":"/2017/12/11/shryen7-2-5/"},{"title":"实验7-2-4 计算天数（15 分）","text":"实验7-2-4 计算天数（15 分）本题要求编写程序计算某年某月某日是该年中的第几天。 输入格式:输入在一行中按照格式“yyyy/mm/dd”（即“年/月/日”）给出日期。注意：闰年的判别条件是该年年份能被4整除但不能被100整除、或者能被400整除。闰年的2月有29天。 输出格式:在一行输出日期是该年中的第几天。 输入样例1:12009/03/02 输出样例1:161 输入样例2:12000/03/02 输出样例2:162 12345678910111213141516171819#include&lt;stdio.h&gt;int main(int argc, const char * argv[]){ int year,month,day,i,num=0; int m[12]={31,28,31,30,31,30,31,31,30,31,30,31}; scanf(\"%d/%d/%d\",&amp;year,&amp;month,&amp;day); if(((year%4==0)&amp;&amp;(year%100!=0))||(year%400==0)) { if(month&gt;2) num=1; } for(i=0;i&lt;(month-1);i++) { num+=m[i]; } num=num+day; printf(\"%d\",num); return 0;}","link":"/2017/12/11/shryen7-2-4/"},{"title":"实验7-2-3 求矩阵的局部极大值（15 分）","text":"实验7-2-3 求矩阵的局部极大值（15 分）给定$M$行$N$列的整数矩阵A，如果A的非边界元素A[i][j]大于相邻的上下左右4个元素，那么就称元素A[i][j]是矩阵的局部极大值。本题要求给定矩阵的全部局部极大值及其所在的位置。 输入格式：输入在第一行中给出矩阵A的行数M和列数$N（3≤M,N≤20）$；最后$M$行，每行给出A在该行的$N$个元素的值。数字间以空格分隔。 输出格式：每行按照“元素值 行号 列号”的格式输出一个局部极大值，其中行、列编号从1开始。要求按照行号递增输出；若同行有超过1个局部极大值，则该行按列号递增输出。若没有局部极大值，则输出“None 总行数 总列数”。 输入样例1：123454 51 1 1 1 11 3 9 3 11 5 3 5 11 1 1 1 1 输出样例1：1239 2 35 3 25 3 4 输入样例2：12343 51 1 1 1 19 3 9 9 11 5 3 5 1 输出样例2：1None 3 5 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(int argc, char *argv[]){ int m, n; scanf(\"%d %d\", &amp;m, &amp;n); int** a = (int**)malloc(sizeof(int*)*m); //二维数组矩阵 int i, j; for (i = 0; i &lt; m; i++) { a[i] = (int*)malloc(sizeof(int)*n); } for (i = 0; i &lt; m; i++) { for (j = 0; j &lt; n; j++) { scanf(\"%d\", &amp;a[i][j]); } } int count = 0; for (i = 1; i &lt; m - 1; i++) { for (j = 1; j &lt; n - 1; j++) { if (a[i][j] &gt; a[i][j - 1] &amp;&amp; a[i][j] &gt; a[i - 1][j] &amp;&amp; a[i][j] &gt; a[i][j + 1] &amp;&amp; a[i][j] &gt; a[i + 1][j]) { //判断上下左右的值 printf(\"%d %d %d\\n\", a[i][j], i + 1, j + 1); count++; } } } for (i = 0; i &lt; m; i++) { //释放动态二维数组 free(a[i]); a[i] = NULL; } free(a); a = NULL; if (!count) printf(\"None %d %d\\n\", m, n); return 0;}","link":"/2017/12/11/shryen7-2-3/"},{"title":"实验7-2-7 方阵循环右移（20 分）","text":"实验7-2-7 方阵循环右移（20 分）本题要求编写程序，将给定n×n方阵中的每个元素循环向右移m个位置，即将第$0、1、⋯、n−1$列变换为第n−m、$n−m+1、⋯、n−1、0、1、⋯、n−m−1$列。 输入格式：输入第一行给出两个正整数$m和$n（1≤n≤6）$。接下来一共$n$行，每行$n$个整数，表示一个n阶的方阵。 输出格式：按照输入格式输出移动后的方阵：即输出n行，每行$n$个整数，每个整数后输出一个空格。 输入样例：12342 31 2 34 5 67 8 9 输出样例：1232 3 1 5 6 4 8 9 7 1234567891011121314151617181920#include &lt;stdio.h&gt; int main() { int a[10][10]; int i,j,n,m; scanf(\"%d %d\",&amp;m,&amp;n); for(i=0;i&lt;n;i++) { for(j=0;j&lt;n;j++) { scanf(\"%d\",&amp;a[i][j]); m%=n; } } for(i=0;i&lt;n;i++) { for(j=0;j&lt;n;j++) { printf(\"%d \",a[i][(n-m+j)%n]); } printf(\"\\n\"); } return 0; }}","link":"/2017/12/20/shryen7-2-7/"},{"title":"实验7-2-6 打印杨辉三角（20 分）","text":"实验7-2-6 打印杨辉三角（20 分）本题要求按照规定格式打印前$N$行杨辉三角。 输入格式：输入在一行中给出$N（1≤N≤10）$。 输出格式：以正三角形的格式输出前N行杨辉三角。每个数字占固定4位。 输入样例：16 输出样例：123456 1 1 1 1 2 1 1 3 3 1 1 4 6 4 11 5 10 10 5 1 12345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;int main(){ int n; int a[50][50]={0}; while(scanf(\"%d\",&amp;n)!=EOF) { int i,j; a[0][10]=1; for(j=0;j&lt;n-1;j++) printf(\" \"); printf(\"%4d\\n\",a[0][10]); for(i=1;i&lt;n;i++) { for(j=0;j&lt;n-i-1;j++) printf(\" \"); for(j=10-i;j&lt;10+1;j++) { a[i][j]=a[i-1][j]+a[i-1][j+1]; if(j==10) printf(\"%4d\\n\",a[i][j]); else printf(\"%4d\",a[i][j]); } } } return 0;}","link":"/2017/12/20/shryen7-2-6/"},{"title":"实验7-2-8 找鞍点（20 分）","text":"实验7-2-8 找鞍点（20 分）一个矩阵元素的“鞍点”是指该位置上的元素值在该行上最大、在该列上最小。 本题要求编写程序，求一个给定的n阶方阵的鞍点。 输入格式：输入第一行给出一个正整数$n（1\\leq n\\leq6）$。随后$n$行，每行给出$n$个整数，其间以空格分隔。 输出格式：输出在一行中按照“行下标 列下标”（下标从0开始）的格式输出鞍点的位置。如果鞍点不存在，则输出“NONE”。题目保证给出的矩阵至多存在一个鞍点。 输入样例1：1234541 7 4 14 8 3 61 6 1 20 7 8 9 输出样例1：12 1 输入样例2：12321 74 1 输出样例2：1NONE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;stdio.h&gt;int main(){ int a[6][6];//定义二维数组 int n; scanf(\"%d\",&amp;n); int i,j; for(i=0; i&lt;n; i++) for(j=0; j&lt;n; j++) { scanf(\"%d\",&amp;a[i][j]); } int k=0,y=0,flag=1,p=0; if(n==1) printf(\"0 0\");//只有一个点时，一定是鞍点 else { for(i=0; i&lt;n; i++) { y=i; for(p=0; p&lt;n; p++) //找行最大值 { if(a[i][k]&lt;=a[i][p])//数组元素之间比较，若比a[i][k]大，则将数组列标赋给k { k=p; } } for(j=0; j&lt;n; j++)//判断是否为列最小值 { if(a[y][k]&gt;a[j][k])//若此行最大值不是列所在最小值，把小的行标赋给y { y=j; break; } } if(i==y)//行最大且列最小，判断条件行标不改变 { flag=0; break; } } if(flag==0) printf(\"%d %d\",i,k); else printf(\"NONE\"); } return 0;}","link":"/2017/12/20/shryen7-2-8/"},{"title":"实验7-2-9 螺旋方阵（20 分）","text":"实验7-2-9 螺旋方阵（20 分）所谓“螺旋方阵”，是指对任意给定的$N$，将1到$N×N$的数字从左上角第1个格子开始，按顺时针螺旋方向顺序填入$N×N$的方阵里。本题要求构造这样的螺旋方阵。 输入格式：输入在一行中给出一个正整数$N（\\lt 10）$。 输出格式：输出$N×N$的螺旋方阵。每行$N$个数字，每个数字占3位。 输入样例：15 输出样例：12345 1 2 3 4 516 17 18 19 615 24 25 20 714 23 22 21 813 12 11 10 9 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;stdio.h&gt;#define SIZE 10 int main(){ int a[SIZE][SIZE]={0}; int N; scanf(\"%d\",&amp;N); //每条边的下标在x,y上的增量 int dx[]={0,1,0,-1}; int dy[]={1,0,-1,0}; int x=0,y=0,nx,ny,i,k=0; //k用来表示边，k=0,1,2,3 分别代表上，右，下，左 for(i=0;i&lt;N*N;i++) { a[x][y]=i+1; nx=x+dx[k]; //下一个坐标的位置 ny=y+dy[k]; if(nx&lt;0 || nx==N || ny&lt;0 || ny==N || a[nx][ny]!=0) //下标越界或下标上已经赋值，转变方向 { k=(k+1)%4; nx=x+dx[k]; ny=y+dy[k]; } x=nx; y=ny; } int j; for(i=0;i&lt;N;i++) { for(j=0;j&lt;N;j++) { printf(\"%3d\",a[i][j]); } printf(\"\\n\"); } return 0;}","link":"/2017/12/20/shryen7-2-9/"},{"title":"实验7-3-1 字符串逆序（15 分）","text":"实验7-3-1 字符串逆序（15 分）输入一个字符串，对该字符串进行逆序，输出逆序后的字符串。 输入格式：输入在一行中给出一个不超过80个字符长度的、以回车结束的非空字符串。 输出格式：在一行中输出逆序后的字符串。 输入样例：1Hello World! 输出样例：1!dlroW olleH 12345678910111213141516171819#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main(){ char str[81]; int i = 0; int c; while((c=getchar()) != '\\n'){// 记录字符串 str[i] = (char) c; i++; } i--; for(;i&gt;=0;i--){ printf(\"%c\", str[i]); }}","link":"/2017/12/21/shryen7-3-1/"},{"title":"实验7-3-10 删除重复字符（20 分）","text":"实验7-3-10 删除重复字符（20 分）本题要求编写程序，将给定字符串去掉重复的字符后，按照字符ASCII码顺序从小到大排序后输出。 输入格式：输入是一个以回车结束的非空字符串（少于80个字符）。 输出格式：输出去重排序后的结果字符串。 输入样例：1ad2f3adjfeainzzzv 输出样例：123adefijnvz 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;stdio.h&gt;int main(void){char str[80], ch;int i=0, j, index;while((str[i] = getchar( )) != '\\n')i++;str[i] = '\\0';for(i=0;str[i];i++){index=i;for(j=i+1;str[j];j++)if(str[j] &lt; str[index])index=j;ch=str[index];str[index]=str[i];str[i]=ch;}ch=0;for(i = 0; str[i] != '\\0'; i++)if(str[i]!=ch){putchar(str[i]);ch=str[i];}putchar('\\n');return 0; }","link":"/2017/12/27/shryen7-3-10/"},{"title":"实验7-3-2 查找指定字符（15 分）","text":"实验7-3-2 查找指定字符（15 分）本题要求编写程序，从给定字符串中查找某指定的字符。 输入格式：输入的第一行是一个待查找的字符。第二行是一个以回车结束的非空字符串（不超过80个字符）。 输出格式：如果找到，在一行内按照格式“index = 下标”输出该字符在字符串中所对应的最大下标（下标从0开始）；否则输出”Not Found”。 输入样例1：12mprogramming 输出样例1：1index = 7 输入样例2：12a1234 输出样例2：1Not Found 1234567891011121314#include&lt;stdio.h&gt;#include&lt;string.h&gt;char buf[80],search[80];int main(){ scanf(\"%s\",search); scanf(\"%s\",buf); char * pos = strstr(buf,search); if (pos==NULL) printf(\"Not Found\\n\"); else printf(\"index = %d\\n\",pos-buf+1); return 0;}","link":"/2017/12/21/shryen7-3-2/"},{"title":"实验7-3-6 字符串转换成十进制整数（15 分）","text":"实验7-3-6 字符串转换成十进制整数（15 分）输入一个以#结束的字符串，本题要求滤去所有的非十六进制字符（不分大小写），组成一个新的表示十六进制数字的字符串，然后将其转换为十进制数后输出。如果在第一个十六进制字符之前存在字符“-”，则代表该数是负数。 输入格式：输入在一行中给出一个以#结束的非空字符串。 输出格式：在一行中输出转换后的十进制数。题目保证输出在长整型范围内。 输入样例：1+-P-xf4+-1!# 输出样例：1-3905 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;stdio.h&gt;int main(){ int i, j, flag; char hexad[100], str[100]; long number; i = 0; while ((str[i] = getchar()) != '#') i++; str[i] = '\\0'; flag = 0; for (i = 0; str[i] != '\\0'; i++) { if (str[i] == '-') { flag = 1; break; } else if ((str[i] &gt;= '0' &amp;&amp; str[i] &lt;= '9')) break; } if (flag) { hexad[0] = '-'; j = 1; } else j = 0; for (i = 0; str[i] != '\\0'; i++) { if ((str[i] &gt;= '0' &amp;&amp; str[i] &lt;= '9') || (str[i] &gt;= 'a' &amp;&amp; str[i] &lt;= 'f') || (str[i] &gt;= 'A' &amp;&amp; str[i] &lt;= 'F')) { hexad[j] = str[i]; j++; } } hexad[j] = '\\0'; number = 0; for (i = 0; hexad[i] != '\\0'; i++) { if (hexad[i] &gt;= '0' &amp;&amp; hexad[i] &lt;= '9') number = number*16 + hexad[i]-'0'; else if (hexad[i] &gt;= 'A' &amp;&amp; hexad[i] &lt;= 'F') number = number*16+hexad[i]-'A'+10; else if (hexad[i] &gt;= 'a' &amp;&amp; hexad[i] &lt;= 'f') number = number*16 + hexad[i]-'a'+10; } if (hexad[0] == '-' &amp;&amp; number &lt; 0xabcdef) number = -1*number; printf(\"%ld\\n\", number); return 0;}","link":"/2017/12/27/shryen7-3-6/"},{"title":"实验7-3-4 字符串替换（15 分）","text":"实验7-3-4 字符串替换（15 分）本题要求编写程序，将给定字符串中的大写英文字母按以下对应规则替换： 原字母 对应字母 A Z B Y C X D W … … X C Y B Z A 输入格式：输入在一行中给出一个不超过80个字符、并以回车结束的字符串。 输出格式：输出在一行中给出替换完成后的字符串。 输入样例：1Only the 11 CAPItaL LeTtERS are replaced. 输出样例：1Lnly the 11 XZKRtaO OeGtVIH are replaced. 123456789101112131415161718192021222324//字符串替换#include&lt;stdio.h&gt;int main(void){ int i=0; char str[80]; printf(\"Enter a string:\"); while((str[i]=getchar())!='\\n') i++; str[i]='\\0'; for(i=0;str[i]!='\\0';i++) { if(str[i]&gt;='A'&amp;&amp;str[i]&lt;='Z') str[i]=155-str[i]; } printf(\"After change:\"); for(i=0;str[i]!='\\0';i++) putchar(str[i]); printf(\"\\n\"); return 0;}","link":"/2017/12/27/shryen7-3-4/"},{"title":"实验7-3-5 输出大写英文字母（15 分）","text":"实验7-3-5 输出大写英文字母（15 分）本题要求编写程序，顺序输出给定字符串中所出现过的大写英文字母，每个字母只输出一遍；若无大写英文字母则输出“Not Found”。 输入格式：输入为一个以回车结束的字符串（少于80个字符）。 输出格式：按照输入的顺序在一行中输出所出现过的大写英文字母，每个字母只输出一遍。若无大写英文字母则输出“Not Found”。 输入样例1：1FONTNAME and FILENAME 输出样例1：1FONTAMEIL 输入样例2：1fontname and filrname 输出样例2：1Not Found 12345678910111213141516171819#include &lt;stdio.h&gt;int main(void){char x[80],y[26]; int i,j,ny=0;gets(x);for(i=0;x[i]!='\\0' ; i++)if(x[i]&gt;='A'&amp;&amp; x[i]&lt;='Z'){for(j=0;j&lt;ny;j++)if(y[j]==x[i])break;if(j==ny){ y[ny]=x[i]; ny++; }}for(i=0;i&lt;ny;i++)printf(\"%c\",y[i]);if(ny==0){printf(\"Not Found\\n\");}return 0;}","link":"/2017/12/27/shryen7-3-5/"},{"title":"实验7-3-7 字符转换（15 分）","text":"实验7-3-7 字符转换（15 分）本题要求提取一个字符串中的所有数字字符（’0’……’9’），将其转换为一个整数输出。 输入格式：输入在一行中给出一个不超过80个字符且以回车结束的字符串。 输出格式：在一行中输出转换后的整数。题目保证输出不超过长整型范围。 输入样例：1free82jeep5 输出样例：1825 1234567891011121314151617181920212223242526272829303132#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main(){ char a[81]; char b[81]; gets(a); int m,i; m=strlen(a); int j=0; for(i=0;i&lt;m;i++) { if(a[i]&gt;='0'&amp;&amp;a[i]&lt;='9') { b[j]=a[i]; j++; } } int k=0; while(b[k]=='0') { k++; } if(k==j) printf(\"0\"); for(i=k;i&lt;j;i++) { printf(\"%c\",b[i]); } printf(\"\\n\"); return 0;}","link":"/2017/12/27/shryen7-3-7/"},{"title":"实验7-3-3 统计大写辅音字母（15 分）","text":"实验7-3-3 统计大写辅音字母（15 分）英文辅音字母是除A、E、I、O、U以外的字母。本题要求编写程序，统计给定字符串中大写辅音字母的个数。 输入格式：输入在一行中给出一个不超过80个字符、并以回车结束的字符串。 输出格式：输出在一行中给出字符串中大写辅音字母的个数。 输入样例：1HELLO World! 输出样例：14 12345678910111213141516171819202122//统计大写辅音字母#include&lt;stdio.h&gt;int main(){ int i=0; char str[80]; while((str[i]=getchar())!='\\n') i++; str[i]='\\0'; int count=0; for(i=0;str[i]!='\\0';i++) { if(str[i]&gt;='A'&amp;&amp;str[i]&lt;='Z'&amp;&amp;str[i]!='A'&amp;&amp;str[i]!='E'&amp;&amp;str[i]!='I'&amp;&amp;str[i]!='O'&amp;&amp;str[i]!='U') { count++; } } printf(\"%d\",count); return 0;}","link":"/2017/12/27/shryen7-3-3/"},{"title":"实验7-3-9 字符串字母大小写转换（15 分）","text":"实验7-3-9 字符串字母大小写转换（15 分）本题要求编写程序，对一个以“#”结束的字符串，将其小写字母全部转换成大写字母，把大写字母全部转换成小写字母，其他字符不变输出。 输入格式：输入为一个以“#”结束的字符串（不超过30个字符）。 输出格式：在一行中输出大小写转换后的结果字符串。 输入样例：1Hello World! 123# 输出样例：1hELLO wORLD! 123 123456789101112131415161718192021#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main(){ char str[50]; int i=0,j; gets(str); while(str[i]!='#') { if(str[i]&gt;='a'&amp;&amp;str[i]&lt;='z') str[i]=str[i]-32; else if(str[i]&gt;='A'&amp;&amp;str[i]&lt;='Z') str[i]=str[i]+32; i++; } for(j=0;j&lt;i;j++) printf(\"%c\",str[j]); printf(\"\\n\"); return 0;}","link":"/2017/12/27/shryen7-3-9/"},{"title":"实验7-2-8 找鞍点（20 分）","text":"实验7-3-8 统计字符出现次数（20 分）本题要求编写程序，统计并输出某给定字符在给定字符串中出现的次数。 输入格式：输入第一行给出一个以回车结束的字符串（少于80个字符）；第二行输入一个字符。 输出格式：在一行中输出给定字符在给定字符串中出现的次数。 输入样例：12programming is More fun!m 输出样例：12 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;stdio.h&gt;int main(){ int i, j, k, n, row, col, max, flag; int matrix[6][6]; scanf(\"%d\", &amp;n); for (i = 0; i &lt; n; i++) { for (j = 0; j &lt; n; j++) scanf(\"%d\", &amp;matrix[i][j]); } for (i = 0; i &lt; n; i++) { row = 0; col = 0; max = matrix[i][0]; for (j = 0; j &lt; n; j++) { if(max &lt;= matrix[i][j]) { max = matrix[i][j]; row = i; col = j; } } flag = 1; for (k = 0; k &lt; n; k++) { if (max &gt; matrix[k][col]) flag = 0; } if (flag) { printf(\"%d %d\\n\", row, col); break; } } if (!flag) printf(\"NONE\\n\"); return 0;}","link":"/2017/12/27/shryen7-3-8/"},{"title":"实验8-1-1 利用指针找最大值（10 分）","text":"实验8-1-1 利用指针找最大值（10 分）本题要求实现一个简单函数，找出两个数中的最大值。 函数接口定义：1void findmax( int *px, int *py, int *pmax ); 其中px和px是用户传入的两个整数的指针。函数findmax应找出两个指针所指向的整数中的最大值，存放在pmax指向的位置。 裁判测试程序样例：12345678910111213141516#include &lt;stdio.h&gt;void findmax( int *px, int *py, int *pmax );int main(){ int max, x, y; scanf(\"%d %d\", &amp;x, &amp;y); findmax( &amp;x, &amp;y, &amp;max ); printf(\"%d\\n\", max); return 0;} /* 你的代码将被嵌在这里 */ 输入样例：13 5 输出样例：15 123456789101112131415161718192021#include &lt;stdio.h&gt;void findmax( int *px, int *py, int *pmax );int main(){ int max, x, y; scanf(\"%d %d\", &amp;x, &amp;y); findmax( &amp;x, &amp;y, &amp;max ); printf(\"%d\\n\", max); return 0;} void findmax( int *px, int *py, int *pmax ){ if(*px&gt;*py) *pmax=*px; else *pmax=*py;}","link":"/2017/12/28/shryen8-1-1/"},{"title":"实验8-1-3 拆分实数的整数与小数部分（15 分）","text":"实验8-1-3 拆分实数的整数与小数部分（15 分）本题要求实现一个拆分实数的整数与小数部分的简单函数。 函数接口定义：1void splitfloat( float x, int *intpart, float *fracpart ); 其中x是被拆分的实数（0≤x&lt;10000），*intpart和*fracpart分别是将实数x拆分出来的整数部分与小数部分。 裁判测试程序样例：123456789101112131415161718#include &lt;stdio.h&gt;void splitfloat( float x, int *intpart, float *fracpart );int main(){ float x, fracpart; int intpart; scanf(\"%f\", &amp;x); splitfloat(x, &amp;intpart, &amp;fracpart); printf(\"The integer part is %d\\n\", intpart); printf(\"The fractional part is %g\\n\", fracpart); return 0;}/* 你的代码将被嵌在这里 */ 输入样例：12.718 输出样例：12The integer part is 2The fractional part is 0.718 1234567891011121314151617181920212223242526#include &lt;stdio.h&gt;void splitfloat( float x, int *intpart, float *fracpart );int main(){ float x, fracpart; int intpart; scanf(\"%f\", &amp;x); splitfloat(x, &amp;intpart, &amp;fracpart); printf(\"The integer part is %d\\n\", intpart); printf(\"The fractional part is %g\\n\", fracpart); return 0;}void splitfloat(float x, int *intpart, float *fracpart) {if(x&lt;0) x=-x;*intpart=(int)x;*fracpart=x-*intpart;}","link":"/2017/12/28/shryen8-1-3/"},{"title":"实验8-1-4 使用函数的选择法排序（25 分）","text":"实验8-1-4 使用函数的选择法排序（25 分）本题要求实现一个用选择法对整数数组进行简单排序的函数。 函数接口定义：1void sort( int a[], int n ); 其中a是待排序的数组，n是数组a中元素的个数。该函数用选择法将数组a中的元素按升序排列，结果仍然在数组a中。 裁判测试程序样例：12345678910111213141516171819202122232425#include &lt;stdio.h&gt;#define MAXN 10void sort( int a[], int n );int main(){ int i, n; int a[MAXN]; scanf(\"%d\", &amp;n); for( i=0; i&lt;n; i++ ) scanf(\"%d\", &amp;a[i]); sort(a, n); printf(\"After sorted the array is:\"); for( i = 0; i &lt; n; i++ ) printf(\" %d\", a[i]); printf(\"\\n\"); return 0;}/* 你的代码将被嵌在这里 */ 输入样例：1245 1 7 6 输出样例：1After sorted the array is: 1 5 6 7 123456789101112131415161718192021222324252627282930313233343536#include &lt;stdio.h&gt;#define MAXN 10void sort( int a[], int n );int main(){ int i, n; int a[MAXN]; scanf(\"%d\", &amp;n); for( i=0; i&lt;n; i++ ) scanf(\"%d\", &amp;a[i]); sort(a, n); printf(\"After sorted the array is:\"); for( i = 0; i &lt; n; i++ ) printf(\" %d\", a[i]); printf(\"\\n\"); return 0;}void sort( int a[], int n ){ int *p=&amp;a[0],i,j; for(i=0;i&lt;n;i++){ for(j=0;j&lt;n-i-1;j++){ if(*(p+j)&gt;*(p+j+1)){ int temp=*(p+j); *(p+j)=*(p+j+1); *(p+j+1)=temp; } } }}","link":"/2017/12/28/shryen8-1-4/"},{"title":"实验8-1-5 在数组中查找指定元素（15 分）","text":"实验8-1-5 在数组中查找指定元素（15 分）本题要求实现一个在数组中查找指定元素的简单函数。 函数接口定义：1int search( int list[], int n, int x ); 其中list[]是用户传入的数组；n（≥0）是list[]中元素的个数；x是待查找的元素。如果找到 则函数search返回相应元素的最小下标（下标从0开始），否则返回−1。 裁判测试程序样例：123456789101112131415161718192021222324#include &lt;stdio.h&gt;#define MAXN 10int search( int list[], int n, int x );int main(){ int i, index, n, x; int a[MAXN]; scanf(\"%d\", &amp;n); for( i = 0; i &lt; n; i++ ) scanf(\"%d\", &amp;a[i]); scanf(\"%d\", &amp;x); index = search( a, n, x ); if( index != -1 ) printf(\"index = %d\\n\", index); else printf(\"Not found\\n\"); return 0;}/* 你的代码将被嵌在这里 */ 输入样例1：12351 2 2 5 42 输出样例1：1index = 1 输入样例2：12351 2 2 5 40 输出样例2：1Not found 123456789101112131415161718192021222324252627282930313233int search( int list[], int n, int x );#define MAXN 10int main(){ int i, index, n, x; int a[MAXN]; scanf(\"%d\", &amp;n); for( i = 0; i &lt; n; i++ ) scanf(\"%d\", &amp;a[i]); scanf(\"%d\", &amp;x); index = search( a, n, x ); if( index != -1 ) printf(\"index = %d\\n\", index); else printf(\"Not found\\n\"); return 0;}int search( int list[], int n, int x ){ int i,*p=&amp;list[0]; for(i=0;i&lt;n;i++){ if(x==*p++){ break; } } if(i==n){ return -1; } return i;}","link":"/2017/12/28/shryen8-1-5/"},{"title":"实验8-1-2 计算两数的和与差（10 分）","text":"实验8-1-2 计算两数的和与差（10 分）本题要求实现一个计算输入的两数的和与差的简单函数。 函数接口定义：1void sum_diff( float op1, float op2, float *psum, float *pdiff ); 其中op1和op2是输入的两个实数，*psum和*pdiff是计算得出的和与差。 裁判测试程序样例：12345678910111213141516#include &lt;stdio.h&gt;void sum_diff( float op1, float op2, float *psum, float *pdiff );int main(){ float a, b, sum, diff; scanf(\"%f %f\", &amp;a, &amp;b); sum_diff(a, b, &amp;sum, &amp;diff); printf(\"The sum is %.2f\\nThe diff is %.2f\\n\", sum, diff); return 0; }/* 你的代码将被嵌在这里 */ 输入样例：14 6 输出样例：12The sum is 10.00The diff is -2.00 123456789101112131415161718#include &lt;stdio.h&gt;void sum_diff( float op1, float op2, float *psum, float *pdiff );int main(){ float a, b, sum, diff; scanf(\"%f %f\", &amp;a, &amp;b); sum_diff(a, b, &amp;sum, &amp;diff); printf(\"The sum is %.2f\\nThe diff is %.2f\\n\", sum, diff); return 0; }void sum_diff( float op1, float op2, float *psum, float *pdiff ){ *psum=op1+op2; *pdiff=op1-op2;}","link":"/2017/12/28/shryen8-1-2/"},{"title":"实验8-1-6 函数实现字符串逆序（15 分）","text":"实验8-1-6 函数实现字符串逆序（15 分）本题要求实现一个字符串逆序的简单函数。 函数接口定义：1void f( char *p ); 函数f对p指向的字符串进行逆序操作。要求函数f中不能定义任何数组，不能调用任何字符串处理函数。 裁判测试程序样例：123456789101112131415161718#include &lt;stdio.h&gt;#define MAXS 20void f( char *p );void ReadString( char *s ); /* 由裁判实现，略去不表 */int main(){ char s[MAXS]; ReadString(s); f(s); printf(\"%s\\n\", s); return 0;}/* 你的代码将被嵌在这里 */ 输入样例：1Hello World! 输出样例：1!dlroW olleH 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;stdio.h&gt;#define MAXS 20void f( char *p );void ReadString( char *s ); /* 由裁判实现，略去不表 */int main(){ char s[MAXS]; ReadString(s); f(s); printf(\"%s\\n\", s); return 0;}void ReadString(char s[]){ gets(s);}void f(char *p) { // p指向字符串头部 char *s=p; // q指向字符串尾部 char *q = s; while(*q) q++; q--; // 交换并移动指针，知道p和q交叉 while(q&gt;s) { char t = *s; *s++ = *q; *q-- = t; } }","link":"/2017/12/28/shryen8-1-6/"},{"title":"实验8-2-1 找最小的字符串（15 分）","text":"实验8-2-1 找最小的字符串（15 分）本题要求编写程序，针对输入的N个字符串，输出其中最小的字符串。 输入格式：输入第一行给出正整数N；随后N行，每行给出一个长度小于80的非空字符串，其中不会出现换行符，空格，制表符。 输出格式：在一行中用以下格式输出最小的字符串： 1Min is: 最小字符串 输入样例：1234565LiWangZhaJinXian 输出样例：1Min is: Jin `1234567891011121314151617181920#include &lt;stdio.h&gt;#include &lt;string.h&gt; int main(){ int i, j, N; char *min, str[100][80]; scanf (\"%d\", &amp;N); //输入行数 getchar (); for (i=0; i&lt;N; i++) gets (str[i]); //这个函数不读取换行符,请放心使用 min = str[0]; for (i=0; i&lt;N; i++) if (strcmp(min, str[i]) &gt; 0) min = str[i]; printf (\"Min is: %s\\n\", min); return 0;}","link":"/2018/01/01/shryen8-2-1/"},{"title":"实验8-1-8 报数（20 分）","text":"实验8-1-8 报数（20 分）报数游戏是这样的：有n个人围成一圈，按顺序从1到n编好号。从第一个人开始报数，报到m（&lt;n）的人退出圈子；下一个人从1开始报数，报到m的人退出圈子。如此下去，直到留下最后一个人。 本题要求编写函数，给出每个人的退出顺序编号。 函数接口定义：1void CountOff( int n, int m, int out[] ); 其中n是初始人数；m是游戏规定的退出位次（保证为小于n的正整数）。函数CountOff将每个人的退出顺序编号存在数组out[]中。因为C语言数组下标是从0开始的，所以第i个位置上的人是第out[i-1]个退出的。 裁判测试程序样例：1234567891011121314151617181920#include &lt;stdio.h&gt;#define MAXN 20void CountOff( int n, int m, int out[] );int main(){ int out[MAXN], n, m; int i; scanf(\"%d %d\", &amp;n, &amp;m); CountOff( n, m, out ); for ( i = 0; i &lt; n; i++ ) printf(\"%d \", out[i]); printf(\"\\n\"); return 0;}/* 你的代码将被嵌在这里 */ 输入样例：111 3 输出样例：14 10 1 7 5 2 11 9 3 6 8 `1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;stdio.h&gt;#define MAXN 20void CountOff( int n, int m, int out[] );int main(){ int out[MAXN], n, m; int i; scanf(\"%d %d\", &amp;n, &amp;m); CountOff( n, m, out ); for ( i = 0; i &lt; n; i++ ) printf(\"%d \", out[i]); printf(\"\\n\"); return 0;}void CountOff(int n, int m, int out[]){ int i, j, count, length, circle[MAXN], temp[MAXN]; for (i = 0, length = 0; i &lt; n; i++) { circle[i] = i+1; length++; } count = 0; j = 0; while (length &gt; 0) { for (i = 0; i &lt; n; i++) { if (circle[i] != 0) count++; else continue; if (count%m == 0) { temp[j] = circle[i]; j++; circle[i] = 0; length--; } } } for (i = 0; i &lt; n; i++) { j = temp[i]; out[j-1] = i + 1; }}","link":"/2018/01/01/shryen8-1-8/"},{"title":"实验8-1-9 输出学生成绩（20 分）","text":"实验8-1-9 输出学生成绩（20 分）本题要求编写程序，根据输入学生的成绩，统计并输出学生的平均成绩、最高成绩和最低成绩。建议使用动态内存分配来实现。 输入格式：输入第一行首先给出一个正整数N，表示学生的个数。接下来一行给出N个学生的成绩，数字间以空格分隔。 输出格式：按照以下格式输出： 123average = 平均成绩max = 最高成绩min = 最低成绩 结果均保留两位小数。 输入样例：12385 90 95 输出样例：123average = 90.00max = 95.00min = 85.00 `1234567891011121314151617181920212223242526#include &lt;stdlib.h&gt;int main(){ int n, sum, i, max, min, *p; double average; scanf(\"%d\", &amp;n); p = (int *) calloc(n,sizeof(int)); sum = 0; max = 0; min = 100; for (i=0; i&lt;n; i++) { scanf(\"%d\", p+i); sum = sum + *(p+i); if (max &lt;= *(p+i)) max = *(p+i); if (min &gt;= *(p+i)) min = *(p+i); } average = (double) sum/n; printf(\"average = %.2f\\nmax = %.2f\\nmin = %.2f\\n\", average, (double) max, (double) min); free(p); return 0;}","link":"/2018/01/01/shryen8-1-9/"},{"title":"实验8-1-7 数组循环右移（20 分）","text":"实验8-1-7 数组循环右移（20 分）本题要求实现一个对数组进行循环右移的简单函数：一个数组a中存有$n（\\gt 0）$个整数，将每个整数循环向右移$m（\\geq 0）$个位置，即将a中的数据由$\\left(a_{0} a_{1} \\cdots a_{n-1}\\right)$变换为$\\left(a_{n-m} \\cdots a_{n-1} a_{0} a_{1} \\cdots a_{n-m-1}\\right)$（最后m个数循环移至最前面的m个位置）。 函数接口定义：1int ArrayShift( int a[], int n, int m ); 其中a[]是用户传入的数组；n是数组的大小；m是右移的位数。函数ArrayShift须将循环右移后的数组仍然存在a[]中。 裁判测试程序样例：12345678910111213141516171819202122232425#include &lt;stdio.h&gt;#define MAXN 10int ArrayShift( int a[], int n, int m );int main(){ int a[MAXN], n, m; int i; scanf(\"%d %d\", &amp;n, &amp;m); for ( i = 0; i &lt; n; i++ ) scanf(\"%d\", &amp;a[i]); ArrayShift(a, n, m); for ( i = 0; i &lt; n; i++ ) { if (i != 0) printf(\" \"); printf(\"%d\", a[i]); } printf(\"\\n\"); return 0;}/* 你的代码将被嵌在这里 */ 输入样例：126 21 2 3 4 5 6 输出样例：15 6 1 2 3 4 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;stdio.h&gt;#define MAXN 10int ArrayShift( int a[], int n, int m );int main(){ int a[MAXN], n, m; int i; scanf(\"%d %d\", &amp;n, &amp;m); for ( i = 0; i &lt; n; i++ ) scanf(\"%d\", &amp;a[i]); ArrayShift(a, n, m); for ( i = 0; i &lt; n; i++ ) { if (i != 0) printf(\" \"); printf(\"%d\", a[i]); } printf(\"\\n\"); return 0;}int ArrayShift( int a[], int n, int m ){ int i, j = 0, s[MAXN],num; int *p=&amp;a[0]; if(m==0){ return 0; } if(m&gt;n){ if(m%n==0){ return 0; } m=m%n; } for (i = n - m; i &lt; n; i++) { s[j] = *(p+i); j++; } for (i = 0; i &lt; n - m ; i++) { s[j] = *(p+i); j++; } for(num = 0; num &lt; n; num++) { *(p+num)=s[num]; }}","link":"/2017/12/28/shryen8-1-7/"},{"title":"实验8-2-10 IP地址转换（20 分）","text":"实验8-2-10 IP地址转换（20 分）一个IP地址是用四个字节（每个字节8个位）的二进制码组成。请将32位二进制码表示的IP地址转换为十进制格式表示的IP地址输出。 输入格式：输入在一行中给出32位二进制字符串。 输出格式：在一行中输出十进制格式的IP地址，其由4个十进制数组成（分别对应4个8位的二进制数），中间用“.”分隔开。 输入样例：111001100100101000001010101110010 输出样例：1204.148.21.114 123456789101112131415161718192021222324#include&lt;stdio.h&gt;#include&lt;math.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;int main(){ char s[35]; gets(s); int a = 0, i, j; for(i = 0; i &lt; 32; i++) { if(i != 0 &amp;&amp; i % 8 == 0) { printf(\"%d.\", a); a = 0; } if(s[i] == '1') { a += pow(2, 7 - i % 8); } } printf(\"%d\\n\", a); return 0;}","link":"/2018/01/02/shryen8-2-10/"},{"title":"实验8-2-2 找最长的字符串（15 分）","text":"实验8-2-2 找最长的字符串（15 分）本题要求编写程序，针对输入的N个字符串，输出其中最长的字符串。 输入格式：输入第一行给出正整数N；随后N行，每行给出一个长度小于80的非空字符串，其中不会出现换行符，空格，制表符。 输出格式：在一行中用以下格式输出最长的字符串： 1The longest is: 最长的字符串 如果字符串的长度相同，则输出先输入的字符串。 输入样例：1234565liwangzhangjinxiang 输出样例：1The longest is: zhang `123456789101112131415161718192021222324252627282930#include&lt;stdio.h&gt;int main(){ char str[10000][100]; int N,i,j,k=0,m; scanf(\"%d\",&amp;N); for(i=0;i&lt;=N;i++) { for(j=0;j&lt;80;j++) { scanf(\"%c\",&amp;str[i][j]); if(str[i][j]=='\\n') break; } } for(i=0;i&lt;=N;i++) { for(j=0;j&lt;80;j++) if(str[i][j]=='\\n') if(j&gt;k) { k=j; m=i; } }printf(\"The longest is: \"); for(i=0;i&lt;k;i++) printf(\"%c\",str[m][i]); return 0; }","link":"/2018/01/01/shryen8-2-2/"},{"title":"实验8-2-5 判断回文字符串（20 分）","text":"实验8-2-5 判断回文字符串（20 分）本题要求编写函数，判断给定的一串字符是否为“回文”。所谓“回文”是指顺读和倒读都一样的字符串。如“XYZYX”和“xyzzyx”都是回文。 函数接口定义：1bool palindrome( char *s ); 函数palindrome判断输入字符串char *s是否为回文。若是则返回true，否则返回false。 裁判测试程序样例：1234567891011121314151617181920212223#include &lt;stdio.h&gt;#include &lt;string.h&gt;#define MAXN 20typedef enum {false, true} bool;bool palindrome( char *s );int main(){ char s[MAXN]; scanf(\"%s\", s); if ( palindrome(s)==true ) printf(\"Yes\\n\"); else printf(\"No\\n\"); printf(\"%s\\n\", s); return 0;}/* 你的代码将被嵌在这里 */ 输入样例1：1thisistrueurtsisiht 输出样例1：12Yesthisistrueurtsisiht 输入样例2：1thisisnottrue 输出样例2：12Nothisisnottrue 12345678910111213141516171819202122232425262728293031323334353637#include &lt;stdio.h&gt;#include &lt;string.h&gt;#define MAXN 20typedef enum {false, true} bool;bool palindrome( char *s );int main(){ char s[MAXN]; scanf(\"%s\", s); if ( palindrome(s)==true ) printf(\"Yes\\n\"); else printf(\"No\\n\"); printf(\"%s\\n\", s); return 0;}bool palindrome( char *s ){ int len; len=strlen(s); int i,j; for(i=0,j=len-1;i&lt;=j;i++,j--){ if(*(s+i)!=*(s+j)){ break; } } if(i&gt;j){ return true; }else{ return false; }}","link":"/2018/01/01/shryen8-2-5/"},{"title":"实验8-2-3 删除字符（20 分）","text":"实验8-2-3 删除字符（20 分）本题要求实现一个删除字符串中的指定字符的简单函数。 函数接口定义：1void delchar( char *str, char c ); 其中char *str是传入的字符串，c是待删除的字符。函数delchar的功能是将字符串str中出现的所有c字符删除。 裁判测试程序样例：12345678910111213141516171819#include &lt;stdio.h&gt;#define MAXN 20void delchar( char *str, char c );void ReadString( char s[] ); /* 由裁判实现，略去不表 */int main(){ char str[MAXN], c; scanf(\"%c\\n\", &amp;c); ReadString(str); delchar(str, c); printf(\"%s\\n\", str); return 0;}/* 你的代码将被嵌在这里 */ 输入样例：12ahappy new year 输出样例：1hppy new yer `12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;stdio.h&gt;#define MAXN 20void delchar( char *str, char c );int main(){ char str[MAXN], c; scanf(\"%c\\n\", &amp;c); gets(str); delchar(str, c); printf(\"%s\\n\", str); return 0;}void delchar( char *str, char c ){ int i=0,count=0,j=0,coun=0,q=0; char a [100],b[100];while(str[i++]!='\\0'){count++;}for(i=0;i&lt;count;i++){if(str[i]==c){continue;}else{a[j++]=str[i];coun++;}}j=0;for(i=0;i&lt;coun;i++){ str[q++]=a[j++]; } //注意此处加终止符表示结束 str[q]='\\0';}","link":"/2018/01/01/shryen8-2-3/"},{"title":"实验8-2-6 分类统计各类字符个数（15 分）","text":"实验8-2-6 分类统计各类字符个数（15 分）本题要求实现一个函数，统计给定字符串中的大写字母、小写字母、空格、数字以及其它字符各有多少。 函数接口定义：1void StringCount( char *s ); 其中 char *s 是用户传入的字符串。函数StringCount须在一行内按照 1大写字母个数 小写字母个数 空格个数 数字个数 其它字符个数 的格式输出。 裁判测试程序样例：1234567891011121314151617#include &lt;stdio.h&gt;#define MAXS 15void StringCount( char *s );void ReadString( char *s ); /* 由裁判实现，略去不表 */int main(){ char s[MAXS]; ReadString(s); StringCount(s); return 0;}/* Your function will be put here */ 输入样例：12aZ&amp;*?093 Az 输出样例：12 2 1 3 4 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;stdio.h&gt;#define MAXS 15void StringCount( char *s );void ReadString( char *s ); /* 由裁判实现，略去不表 */int main(){ char s[MAXS]; ReadString(s); StringCount(s); return 0;}void ReadString(char s[]){ gets(s);}void StringCount(char s[]){ int i, uppercase, lowercase, blank, digit, other; uppercase = lowercase = blank = digit = other =0; i = 0; while(s[i] != '\\0') { if (s[i] &gt;= 'A'&amp;&amp; s[i] &lt;= 'Z') uppercase++; else if (s[i] &gt;= 'a' &amp;&amp; s[i] &lt;= 'z') lowercase++; else if (s[i] == ' ') blank++; else if (s[i] &gt;= '0' &amp;&amp; s[i] &lt;= '9') digit++; else other++; i++; } printf(\"%d %d %d %d %d\\n\", uppercase, lowercase, blank, digit, other);}","link":"/2018/01/02/shryen8-2-6/"},{"title":"实验8-2-4 使用函数实现字符串部分复制（20 分）","text":"实验8-2-4 使用函数实现字符串部分复制（20 分）本题要求编写函数，将输入字符串t中从第m个字符开始的全部字符复制到字符串s中。 函数接口定义：1void strmcpy( char *t, int m, char *s ); 函数strmcpy将输入字符串char *t中从第m个字符开始的全部字符复制到字符串char *s中。若m超过输入字符串的长度，则结果字符串应为空串。 裁判测试程序样例：1234567891011121314151617181920#include &lt;stdio.h&gt;#define MAXN 20void strmcpy( char *t, int m, char *s );void ReadString( char s[] ); /* 由裁判实现，略去不表 */int main(){ char t[MAXN], s[MAXN]; int m; scanf(\"%d\\n\", &amp;m); ReadString(t); strmcpy( t, m, s ); printf(\"%s\\n\", s); return 0;}/* 你的代码将被嵌在这里 */ 输入样例：127happy new year 输出样例：1new year 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;stdio.h&gt;#define MAXN 20void strmcpy( char *t, int m, char *s );void ReadString( char s[] ); /* 由裁判实现，略去不表 */int main(){ char t[MAXN], s[MAXN]; int m; scanf(\"%d\\n\", &amp;m); ReadString(t); strmcpy( t, m, s ); printf(\"%s\\n\", s); return 0;}void ReadString(char s[]){ gets(s);}void strmcpy(char *t, int m, char *s){ int i, j, length; length=0; while (t[length] != '\\0') length++; j = 0; if (m&gt;0 &amp;&amp; m&lt;=length) { for (i=m-1; t[i] !='\\0'; i++) { s[j] = t[i]; j++; } s[j] = '\\0'; } else s[0] = '\\0';}","link":"/2018/01/01/shryen8-2-4/"},{"title":"实验8-2-7 字符串的连接（15 分）","text":"实验8-2-7 字符串的连接（15 分）本题要求实现一个函数，将两个字符串连接起来。 函数接口定义：1char *str_cat( char *s, char *t ); 函数str_cat应将字符串t复制到字符串s的末端，并且返回字符串s的首地址。 裁判测试程序样例：1234567891011121314151617181920#include &lt;stdio.h&gt;#include &lt;string.h&gt;#define MAXS 10char *str_cat( char *s, char *t );int main(){ char *p; char str1[MAXS+MAXS] = {'\\0'}, str2[MAXS] = {'\\0'}; scanf(\"%s%s\", str1, str2); p = str_cat(str1, str2); printf(\"%s\\n%s\\n\", p, str1); return 0;}/* 你的代码将被嵌在这里 */ 输入样例：12abcdef 输出样例：12abcdefabcdef 12345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;#include &lt;string.h&gt;#define MAXS 10char *str_cat( char *s, char *t );int main(){ char *p; char str1[MAXS+MAXS] = {'\\0'}, str2[MAXS] = {'\\0'}; scanf(\"%s%s\", str1, str2); p = str_cat(str1, str2); printf(\"%s\\n%s\\n\", p, str1); return 0;}char *str_cat( char *s, char *t ){ int i, j, index,length; index = strlen(s); length = index+strlen(t); for (i = index, j = 0; i &lt; length; i++, j++) s[i] = t[j]; s[length] = '\\0'; return s;}","link":"/2018/01/02/shryen8-2-7/"},{"title":"实验8-2-9 长整数转化成16进制字符串（15 分）","text":"实验8-2-9 长整数转化成16进制字符串（15 分）本题要求实现一个将长整数转化成16进制字符串的简单函数。 函数接口定义：1void f( long int x, char *p ); 其中x是待转化的十进制长整数，p指向某个字符数组的首元素。函数f的功能是把转换所得的16进制字符串写入p所指向的数组。16进制的A~F为大写字母。 裁判测试程序样例：123456789101112131415161718#include &lt;stdio.h&gt;#define MAXN 10void f( long int x, char *p );int main(){ long int x; char s[MAXN] = \"\"; scanf(\"%ld\", &amp;x); f(x, s); printf(\"%s\\n\", s); return 0;}/* 你的代码将被嵌在这里 */ 输入样例1：1123456789 输出样例1：175BCD15 输入样例2：1-125 输出样例2：1-7D 12345678910111213141516171819202122232425262728293031323334353637#include &lt;stdio.h&gt;#define MAXN 10void f( long int x, char *p );int main(){ long int x; char s[MAXN] = \"\"; scanf(\"%ld\", &amp;x); f(x, s); printf(\"%s\\n\", s); return 0;}void f(long int x,char *p){ char q; static int i=0,j=0; if(x&lt;0){ x=-x; *p='-'; p++; } q=x%16; if(q&lt;10) q=('0'+q); else q=('A'+q-10); x=x/16; j++; i=j; if(x&gt;0) f(x,p); *(p+(i-j))=q; j--;}","link":"/2018/01/02/shryen8-2-9/"},{"title":"实验9-1 计算职工工资（15 分）","text":"实验9-1 计算职工工资（15 分）给定N个职员的信息，包括姓名、基本工资、浮动工资和支出，要求编写程序顺序输出每位职员的姓名和实发工资（实发工资=基本工资+浮动工资-支出）。 输入格式：输入在一行中给出正整数N。随后N行，每行给出一位职员的信息，格式为“姓名 基本工资 浮动工资 支出”，中间以空格分隔。其中“姓名”为长度小于10的不包含空白字符的非空字符串，其他输入、输出保证在单精度范围内。 输出格式：按照输入顺序，每行输出一位职员的姓名和实发工资，间隔一个空格，工资保留2位小数。 输入样例：12343zhao 240 400 75qian 360 120 50zhou 560 150 80 输出样例：123zhao 565.00qian 430.00zhou 630.00 12345678910111213141516171819#include &lt;stdio.h&gt;int main(){ int N,i; float sum[1000],b[1000],c[1000],d[1000]; char a[1000][100]; scanf(\"%d\",&amp;N); for(i=0;i&lt;N;i++) { scanf(\"%s%f%f%f\",a[i],&amp;b[i],&amp;c[i],&amp;d[i]); sum[i]=(b[i]+c[i])-d[i]; } for(i=0;i&lt;N;i++) { printf(\"%s %.2f\\n\",a[i],sum[i]); } return 0;}","link":"/2018/01/04/shryen9-1/"},{"title":"实验8-2-8 字符串排序（20 分）","text":"实验8-2-8 字符串排序（20 分）本题要求编写程序，读入5个字符串，按由小到大的顺序输出。 输入格式：输入为由空格分隔的5个非空字符串，每个字符串不包括空格、制表符、换行符等空白字符，长度小于80。 输出格式：按照以下格式输出排序后的结果： 12After sorted:每行一个字符串 输入样例：1red yellow blue green white 输出样例：123456After sorted:bluegreenredwhiteyellow 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;void bubble(char *color[], int n);int main(){ int i; char *pcolor[5], str[80]; for (i=0; i&lt;5; i++) { scanf(\"%s\", str); pcolor[i] = malloc(sizeof(char)*(strlen(str)+1)); strcpy(pcolor[i], str); } bubble(pcolor, 5); printf(\"After sorted:\\n\"); for (i=0; i&lt;5; i++) { printf(\"%s\\n\", pcolor[i]); free(pcolor[i]); } return 0;}void bubble(char *color[], int n){ int k, j; char *temp; for (k=1; k&lt;n; k++) { for (j=0; j&lt;n-k; j++) { if (strcmp(color[j], color[j+1]) &gt; 0) { temp = color[j]; color[j] = color[j+1]; color[j+1] = temp; } } }}","link":"/2018/01/02/shryen8-2-8/"},{"title":"实验9-2 时间换算（15 分）","text":"实验9-2 时间换算（15 分）本题要求编写程序，以hh:mm:ss的格式输出某给定时间再过n秒后的时间值（超过23:59:59就从0点开始计时）。 输入格式：输入在第一行中以hh:mm:ss的格式给出起始时间，第二行给出整秒数n（&lt;60）。 输出格式：输出在一行中给出hh:mm:ss格式的结果时间。 输入样例：1211:59:4030 输出样例：112:00:10 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;stdio.h&gt;int main(){ struct time { int h; int m; int s; int n; }a; scanf(\"%d:%d:%d\", &amp;a.h, &amp;a.m, &amp;a.s); scanf(\"%d\", &amp;a.n); if (a.s+a.n&lt;59) a.s=a.s+a.n; else if (a.s+a.n==59) { a.s=0; if(a.m==59) { a.m=0; if(a.h==23) { a.h=0; }else { a.h=a.h+1; } } else { a.m=a.m+1; } } else if((a.s+a.n)&gt;59) { a.s=(a.n+a.s)-60; if(a.m==59) { a.m=0; if(a.h==23) { a.h=0; } else { a.h=a.h+1; } } else { a.m=a.m+1; } } printf(\"%02d:%02d:%02d\\n\", a.h, a.m, a.s); return 0;}","link":"/2018/01/04/shryen9-2/"},{"title":"实验9-3 计算平均成绩（15 分）","text":"实验9-3 计算平均成绩（15 分）给定$N$个学生的基本信息，包括学号（由5个数字组成的字符串）、姓名（长度小于10的不包含空白字符的非空字符串）和成绩（[0,100]区间内的整数），要求计算他们的平均成绩，并顺序输出平均线以下的学生名单。 输入格式：输入在一行中给出正整数$N（\\leq 10）$。随后$N$行，每行给出一位学生的信息，格式为“学号 姓名 成绩”，中间以空格分隔。 输出格式：首先在一行中输出平均成绩，保留2位小数。然后按照输入顺序，每行输出一位平均线以下的学生的姓名和学号，间隔一个空格。 输入样例：123456500001 zhang 7000002 wang 8000003 qian 9010001 li 10021987 chen 60 输出样例：12380.00zhang 00001chen 21987 123456789101112131415161718192021#include &lt;stdio.h&gt;int main(){ int N,i,m[10],sum=0; float ave; char a[10][10],b[10][20]; scanf(\"%d\",&amp;N); for(i=0;i&lt;N;i++) { scanf(\"%s%s%d\",a[i],b[i],&amp;m[i]); sum=sum+m[i]; } ave=sum/N; printf(\"%.2f\\n\",ave); for(i=0;i&lt;N;i++) { if(m[i]&lt;ave) printf(\"%s %s\\n\",b[i],a[i]); } return 0;}","link":"/2018/01/04/shryen9-3/"},{"title":"实验9-6 按等级统计学生成绩（20 分）","text":"实验9-6 按等级统计学生成绩（20 分）本题要求实现一个根据学生成绩设置其等级，并统计不及格人数的简单函数。 函数接口定义：1int set_grade( struct student *p, int n ); 其中p是指向学生信息的结构体数组的指针，该结构体的定义为： 123456struct student{ int num; char name[20]; int score; char grade;}; n是数组元素个数。学号num、姓名name和成绩score均是已经存储好的。set_grade函数需要根据学生的成绩score设置其等级grade。等级设置：85－100为A，70－84为B，60－69为C，0－59为D。同时，set_grade还需要返回不及格的人数。 裁判测试程序样例：123456789101112131415161718192021222324252627282930#include &lt;stdio.h&gt;#define MAXN 10struct student{ int num; char name[20]; int score; char grade;};int set_grade( struct student *p, int n );int main(){ struct student stu[MAXN], *ptr; int n, i, count; ptr = stu; scanf(\"%d\\n\", &amp;n); for(i = 0; i &lt; n; i++){ scanf(\"%d%s%d\", &amp;stu[i].num, stu[i].name, &amp;stu[i].score); } count = set_grade(ptr, n); printf(\"The count for failed (&lt;60): %d\\n\", count); printf(\"The grades:\\n\"); for(i = 0; i &lt; n; i++) printf(\"%d %s %c\\n\", stu[i].num, stu[i].name, stu[i].grade); return 0;}/* 你的代码将被嵌在这里 */ 输入样例：12345678910111031001 annie 8531002 bonny 7531003 carol 7031004 dan 8431005 susan 9031006 paul 6931007 pam 6031008 apple 5031009 nancy 10031010 bob 78 输出样例：123456789101112The count for failed (&lt;60): 1The grades:31001 annie A31002 bonny B31003 carol B31004 dan B31005 susan A31006 paul C31007 pam C31008 apple D31009 nancy A31010 bob B 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;stdio.h&gt;#define MAXN 10struct student{ int num; char name[20]; int score; char grade;};int set_grade( struct student *p, int n );int main(){ struct student stu[MAXN], *ptr; int n, i, count; ptr = stu; scanf(\"%d\\n\", &amp;n); for(i = 0; i &lt; n; i++){ scanf(\"%d%s%d\", &amp;stu[i].num, stu[i].name, &amp;stu[i].score); } count = set_grade(ptr, n); printf(\"The count for failed (&lt;60): %d\\n\", count); printf(\"The grades:\\n\"); for(i = 0; i &lt; n; i++) printf(\"%d %s %c\\n\", stu[i].num, stu[i].name, stu[i].grade); return 0;}int set_grade(struct student *p, int n){ int i, count=0; for (i=1; i&lt;=n; i++,p++) { if (p-&gt;score &gt;= 85) p-&gt;grade = 'A'; else if (p-&gt;score &gt;= 70) p-&gt;grade = 'B'; else if (p-&gt;score &gt;= 60) p-&gt;grade = 'C'; else { p-&gt;grade = 'D'; count++; } } return count; }","link":"/2018/01/04/shryen9-6/"},{"title":"实验9-4 计算两个复数之积（15 分）","text":"实验9-4 计算两个复数之积（15 分）本题要求实现一个计算复数之积的简单函数。 函数接口定义：1struct complex multiply(struct complex x, struct complex y); 其中struct complex是复数结构体，其定义如下： 1234struct complex{ int real; int imag;}; 裁判测试程序样例：12345678910111213141516171819202122#include &lt;stdio.h&gt;struct complex{ int real; int imag;};struct complex multiply(struct complex x, struct complex y);int main(){ struct complex product, x, y; scanf(\"%d%d%d%d\", &amp;x.real, &amp;x.imag, &amp;y.real, &amp;y.imag); product = multiply(x, y); printf(\"(%d+%di) * (%d+%di) = %d + %di\\n\", x.real, x.imag, y.real, y.imag, product.real, product.imag); return 0;}/* 你的代码将被嵌在这里 */ 输入样例：13 4 5 6 输出样例：1(3+4i) * (5+6i) = -9 + 38i 123456789101112131415161718192021222324252627#include &lt;stdio.h&gt;struct complex{ int real; int imag;};struct complex multiply(struct complex x, struct complex y);int main(){ struct complex product, x, y; scanf(\"%d%d%d%d\", &amp;x.real, &amp;x.imag, &amp;y.real, &amp;y.imag); product = multiply(x, y); printf(\"(%d+%di) * (%d+%di) = %d + %di\\n\", x.real, x.imag, y.real, y.imag, product.real, product.imag); return 0;}struct complex multiply(struct complex x, struct complex y){ struct complex result; result.real = x.real*y.real - x.imag*y.imag; result.imag = x.imag*y.real + x.real*y.imag; return result;}","link":"/2018/01/04/shryen9-4/"},{"title":"实验9-10 平面向量加法（15 分）","text":"实验9-10 平面向量加法（15 分）本题要求编写程序，计算两个二维平面向量的和向量。 输入格式:输入在一行中按照“$x_1\\quad y_1 \\quad x_2\\quad y_2$”的格式给出两个二维平面向量$v_1=(x_1, y_1)$和$v_2=(x_2, y_2)$的分量。 输出格式:在一行中按照$(x, y)$的格式输出和向量，坐标输出小数点后一位（注意不能输出−0.0）。 输入样例:13.5 -2.7 -13.9 8.7 输出样例:1(-10.4, 6.0) 1234567891011121314151617#include&lt;stdio.h&gt;int main(){ struct xy{ double x; double y; }; struct xy a,b,c; int i,j; scanf(\"%lf%lf%lf%lf\",&amp;a.x,&amp;a.y,&amp;b.x,&amp;b.y); c.x=a.x+b.x; c.y=a.y+b.y; if(c.x&lt;0&amp;&amp;c.x&gt;-0.05) c.x=0.0; if(c.y&lt;0&amp;&amp;c.y&gt;-0.05) c.y=0.0; printf(\"(%.1lf, %.1lf)\\n\",c.x,c.y); return 0;}","link":"/2018/01/07/shryen9-10/"},{"title":"实验9-7 找出总分最高的学生（15 分）","text":"实验9-7 找出总分最高的学生（15 分）给定$N$个学生的基本信息，包括学号（由5个数字组成的字符串）、姓名（长度小于10的不包含空白字符的非空字符串）和3门课程的成绩（[0,100]区间内的整数），要求输出总分最高学生的姓名、学号和总分。 输入格式：输入在一行中给出正整数$N（\\le10）$。随后N行，每行给出一位学生的信息，格式为“学号 姓名 成绩1 成绩2 成绩3”，中间以空格分隔。 输出格式：在一行中输出总分最高学生的姓名、学号和总分，间隔一个空格。题目保证这样的学生是唯一的。 输入样例：123456500001 huanglan 78 83 7500002 wanghai 76 80 7700003 shenqiang 87 83 7610001 zhangfeng 92 88 7821987 zhangmeng 80 82 75 输出样例：1zhangfeng 10001 258 1234567891011121314151617181920212223242526272829303132#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;int main(){ int n; scanf(\"%d\",&amp;n); char s[n][5][100]; int i,j; for(i=0;i&lt;n;i++){ for(j=0;j&lt;5;j++){ scanf(\"%s\",s[i][j]); } } int num;int k;int max=0;int index=0; for(i=0;i&lt;n;i++){ int sum=0; for(j=2;j&lt;5;j++){ num=strlen(s[i][j]); for(k=0;s[i][j][k]!='\\0';k++){ sum+=(s[i][j][k]-'0')*pow(10,num-1); num--; } } if(sum&gt;max){ max=sum; index=i; } } printf(\"%s %s %d\",s[index][1],s[index][0],max); return 0;}","link":"/2018/01/07/shryen9-7/"},{"title":"6-10 二分查找 (20 分)","text":"6-10 二分查找 (20 分)本题要求实现二分查找算法。 函数接口定义：1Position BinarySearch( List L, ElementType X ); 其中List结构定义如下： 123456typedef int Position;typedef struct LNode *List;struct LNode { ElementType Data[MAXSIZE]; Position Last; /* 保存线性表中最后一个元素的位置 */}; L是用户传入的一个线性表，其中ElementType元素可以通过&gt;、==、&lt;进行比较，并且题目保证传入的数据是递增有序的。函数BinarySearch要查找X在Data中的位置，即数组下标（注意：元素从下标1开始存储）。找到则返回下标，否则返回一个特殊的失败标记NotFound。 裁判测试程序样例：1234567891011121314151617181920212223242526272829303132#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define MAXSIZE 10#define NotFound 0typedef int ElementType;typedef int Position;typedef struct LNode *List;struct LNode { ElementType Data[MAXSIZE]; Position Last; /* 保存线性表中最后一个元素的位置 */};List ReadInput(); /* 裁判实现，细节不表。元素从下标1开始存储 */Position BinarySearch( List L, ElementType X );int main(){ List L; ElementType X; Position P; L = ReadInput(); scanf(\"%d\", &amp;X); P = BinarySearch( L, X ); printf(\"%d\\n\", P); return 0;}/* 你的代码将被嵌在这里 */ 输入样例1：123512 31 55 89 10131 输出样例1：12 输入样例2：123326 78 23331 输出样例2：10 鸣谢宁波大学 Eyre-lemon-郎俊杰 同学修正原题！ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define MAXSIZE 10#define NotFound 0typedef int ElementType;typedef int Position;typedef struct LNode *List;struct LNode { ElementType Data[MAXSIZE]; Position Last; /* 保存线性表中最后一个元素的位置 */};List ReadInput(); /* 裁判实现，细节不表。元素从下标1开始存储 */Position BinarySearch( List L, ElementType X );int main(){ List L; ElementType X; Position P; L = ReadInput(); scanf(\"%d\", &amp;X); P = BinarySearch( L, X ); printf(\"%d\\n\", P); return 0;}/* 你的代码将被嵌在这里 */ List ReadInput(){ List PtrL; int N; scanf(\"%d\", &amp;N); for(int i = 1; i &lt;= N; i++){ scanf(\"%d\",&amp;PtrL-&gt;Data[i]); } PtrL-&gt;Last = N; return PtrL; } Position BinarySearch( List L, ElementType X ){ int Left = 1, Right = L-&gt;Last, mid; while(Right - Left &gt;= 0 ){ mid = (Left + Right) / 2; if(L-&gt;Data[mid] &gt; X){ Right = mid - 1; }else if(L-&gt;Data[mid] == X){ return mid; }else{ Left = mid + 1; } } return NotFound; }","link":"/2018/05/06/shujiujiegou6-10/"},{"title":"实验9-5 查找书籍（20 分）","text":"实验9-5 查找书籍（20 分）给定$n$本书的名称和定价，本题要求编写程序，查找并输出其中定价最高和最低的书的名称和定价。 输入格式:输入第一行给出正整数$n（\\lt 10）$，随后给出n本书的信息。每本书在一行中给出书名，即长度不超过30的字符串，随后一行中给出正实数价格。题目保证没有同样价格的书。 输出格式:在一行中按照“价格, 书名”的格式先后输出价格最高和最低的书。价格保留2位小数。 输入样例:12345673Programming in C21.5Programming in VB18.5Programming in Delphi25.0 输出样例:1225.00, Programming in Delphi18.50, Programming in VB 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;stdio.h&gt;#include &lt;string.h&gt;struct book { char name[30]; double price;};int main(){ int n, i, maxIndex, minIndex; double max, min; struct book store[10]; scanf(\"%d\", &amp;n); for (i=0; i&lt;n; i++) { getchar(); gets(store[i].name); scanf(\"%lf\", &amp;store[i].price); } max = min = store[0].price; for (i=0; i&lt;n; i++) { if (max &lt;= store[i].price) { max = store[i].price; maxIndex = i; } if (min &gt;= store[i].price) { min = store[i].price; minIndex = i; } } printf(\"%.2f, %s\\n\", max, store[maxIndex].name); printf(\"%.2f, %s\\n\", min, store[minIndex].name); return 0;}","link":"/2018/01/04/shryen9-5/"},{"title":"实验9-9 有理数比较（10 分）","text":"实验9-9 有理数比较（10 分）本题要求编写程序，比较两个有理数的大小。 输入格式：输入在一行中按照“a1/b1 a2/b2”的格式给出两个分数形式的有理数，其中分子和分母全是整形范围内的正整数。 输出格式：在一行中按照“a1/b1 关系符 a2/b2”的格式输出两个有理数的关系。其中“&gt;”表示“大于”，“&lt;”表示“小于”，“=”表示“等于”。 输入样例1：11/2 3/4 输出样例1：11/2 &lt; 3/4 输入样例2：16/8 3/4 输出样例2：16/8 = 3/4 12345678910111213141516171819202122#include&lt;stdio.h&gt;int main(void){ struct num{ int a; char c; int b; }; struct num n[2]; int i; char ch; for(i=0;i&lt;2;i++){ scanf(\"%d\",&amp;n[i].a); n[i].c=getchar(); scanf(\"%d\",&amp;n[i].b); } if(1.0*n[0].a/n[0].b==1.0*n[1].a/n[1].b) ch='='; else if(1.0*n[0].a/n[0].b&gt;1.0*n[1].a/n[1].b) ch='&gt;'; else ch='&lt;'; printf(\"%d/%d %c %d/%d\",n[0].a,n[0].b,ch,n[1].a,n[1].b); return 0;}","link":"/2018/01/07/shryen9-9/"},{"title":"6-1 单链表逆转（20 分）","text":"6-1 单链表逆转（20 分）本题要求实现一个函数，将给定的单链表逆转。 函数接口定义：1List Reverse( List L ); 其中List结构定义如下： 123456typedef struct Node *PtrToNode;struct Node { ElementType Data; /* 存储结点数据 */ PtrToNode Next; /* 指向下一个结点的指针 */};typedef PtrToNode List; /* 定义单链表类型 */ L是给定单链表，函数Reverse要返回被逆转后的链表。 裁判测试程序样例：123456789101112131415161718192021222324252627#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef int ElementType;typedef struct Node *PtrToNode;struct Node { ElementType Data; PtrToNode Next;};typedef PtrToNode List;List Read(); /* 细节在此不表 */void Print( List L ); /* 细节在此不表 */List Reverse( List L );int main(){ List L1, L2; L1 = Read(); L2 = Reverse(L1); Print(L1); Print(L2); return 0;}/* 你的代码将被嵌在这里 */ 输入样例：1251 3 4 5 2 输出样例：1212 5 4 3 1 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef int ElementType;typedef struct Node *PtrToNode;struct Node { ElementType Data; PtrToNode Next;};typedef PtrToNode List;List Read(); /* 细节在此不表 */void Print( List L ); /* 细节在此不表 */List Reverse( List L );int main(){ List L1, L2; L1 = Read(); L2 = Reverse(L1); Print(L1); Print(L2); return 0;}List Read(){ PtrToNode head=NULL; PtrToNode list=NULL; int len; scanf(\"%d\",&amp;len); if(len==0) return NULL; int num; scanf(\"%d\",&amp;num); head=(PtrToNode)malloc(sizeof(struct Node)); head-&gt;Data=num; head-&gt;Next=NULL; list=head; len--; while(len) { PtrToNode node=(PtrToNode)malloc(sizeof(struct Node)); scanf(\"%d\",&amp;num); node-&gt;Data=num; node-&gt;Next=NULL; list-&gt;Next=node; list=node; len--; } return head; }void Print( List L ){ if(L==NULL) return ; while(L!=NULL) { printf(\"%d \",L-&gt;Data); L=L-&gt;Next; } putchar('\\n');}List Reverse( List L ){ if(L==NULL) return NULL; PtrToNode l1=NULL;// PtrToNode l3=L; PtrToNode l2=NULL; while(L!=NULL) { l1=L-&gt;Next; L-&gt;Next=l2; l2=L; L=l1; } return l2;}","link":"/2018/05/06/shujiujiegou6-1/"},{"title":"实验9-8 通讯录排序（20 分）","text":"实验9-8 通讯录排序（20 分）输入n个朋友的信息，包括姓名、生日、电话号码，本题要求编写程序，按照年龄从大到小的顺序依次输出通讯录。题目保证所有人的生日均不相同。 输入格式:输入第一行给出正整数n（&lt;10）。随后n行，每行按照“姓名 生日 电话号码”的格式给出一位朋友的信息，其中“姓名”是长度不超过10的英文字母组成的字符串，“生日”是yyyymmdd格式的日期，“电话号码”是不超过17位的数字及+、-组成的字符串。 输出格式:按照年龄从大到小输出朋友的信息，格式同输出。 输入样例:12343zhang 19850403 13912345678wang 19821020 +86-0571-88018448qian 19840619 13609876543 输出样例:123wang 19821020 +86-0571-88018448qian 19840619 13609876543zhang 19850403 13912345678 123456789101112131415161718192021222324252627282930313233#include &lt;stdio.h&gt;#include &lt;string.h&gt;struct contact { char name[10]; int birthday; char telephoneNumber[17];};int main(){ int i, index, j, n; struct contact friend[10], temp; scanf(\"%d\", &amp;n); for (i=0; i&lt;n; i++) scanf(\"%s %d %s\", friend[i].name, &amp;friend[i].birthday, friend[i].telephoneNumber); for (i=0; i&lt;n-1; i++) { index=i; for (j=i+1; j&lt;n; j++) if (friend[index].birthday &gt; friend[j].birthday) index=j; temp=friend[index]; friend[index]=friend[i]; friend[i]=temp; } for (i=0; i&lt;n; i++) printf(\"%s %d %s\\n\", friend[i].name, friend[i].birthday, friend[i].telephoneNumber); return 0;}","link":"/2018/01/07/shryen9-8/"},{"title":"6-11 先序输出叶结点 (15 分)","text":"6-11 先序输出叶结点 (15 分)本题要求按照先序遍历的顺序输出给定二叉树的叶结点。 函数接口定义：1void PreorderPrintLeaves( BinTree BT ); 其中BinTree结构定义如下： 1234567typedef struct TNode *Position;typedef Position BinTree;struct TNode{ ElementType Data; BinTree Left; BinTree Right;}; 函数PreorderPrintLeaves应按照先序遍历的顺序输出给定二叉树BT的叶结点，格式为一个空格跟着一个字符。 裁判测试程序样例：12345678910111213141516171819202122232425#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef char ElementType;typedef struct TNode *Position;typedef Position BinTree;struct TNode{ ElementType Data; BinTree Left; BinTree Right;};BinTree CreatBinTree(); /* 实现细节忽略 */void PreorderPrintLeaves( BinTree BT );int main(){ BinTree BT = CreatBinTree(); printf(\"Leaf nodes are:\"); PreorderPrintLeaves(BT); printf(\"\\n\"); return 0;}/* 你的代码将被嵌在这里 */ 输出样例（对于图中给出的树）： 1Leaf nodes are: D E H I 12345678910111213141516void PreorderPrintLeaves(BinTree BT){ if(!BT) ;//如果该节点为空,则什么也不做,这是 else{ if (!(BT-&gt;Left) &amp;&amp; !(BT-&gt;Right)) //左孩子和右孩子均为空时,才会输出,注意输出格式 { putchar(' '); putchar(BT-&gt;Data); } else { PreorderPrintLeaves(BT-&gt;Left); PreorderPrintLeaves(BT-&gt;Right); } } }","link":"/2018/05/06/shujiujiegou6-11/"},{"title":"6-2 顺序表操作集 (20 分)","text":"6-2 顺序表操作集 (20 分)本题要求实现顺序表的操作集。 函数接口定义：1234List MakeEmpty(); Position Find( List L, ElementType X );bool Insert( List L, ElementType X, Position P );bool Delete( List L, Position P ); 其中List结构定义如下： 123456typedef int Position;typedef struct LNode *List;struct LNode { ElementType Data[MAXSIZE]; Position Last; /* 保存线性表中最后一个元素的位置 */}; 各个操作函数的定义为： List MakeEmpty()：创建并返回一个空的线性表； Position Find( List L, ElementType X )：返回线性表中X的位置。若找不到则返回ERROR； bool Insert( List L, ElementType X, Position P )：将X插入在位置P并返回true。若空间已满，则打印“FULL”并返回false；如果参数P指向非法位置，则打印“ILLEGAL POSITION”并返回false； bool Delete( List L, Position P )：将位置P的元素删除并返回true。若参数P指向非法位置，则打印“POSITION P EMPTY”（其中P是参数值）并返回false。 裁判测试程序样例：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define MAXSIZE 5#define ERROR -1typedef enum {false, true} bool;typedef int ElementType;typedef int Position;typedef struct LNode *List;struct LNode { ElementType Data[MAXSIZE]; Position Last; /* 保存线性表中最后一个元素的位置 */};List MakeEmpty(); Position Find( List L, ElementType X );bool Insert( List L, ElementType X, Position P );bool Delete( List L, Position P );int main(){ List L; ElementType X; Position P; int N; L = MakeEmpty(); scanf(\"%d\", &amp;N); while ( N-- ) { scanf(\"%d\", &amp;X); if ( Insert(L, X, 0)==false ) printf(\" Insertion Error: %d is not in.\\n\", X); } scanf(\"%d\", &amp;N); while ( N-- ) { scanf(\"%d\", &amp;X); P = Find(L, X); if ( P == ERROR ) printf(\"Finding Error: %d is not in.\\n\", X); else printf(\"%d is at position %d.\\n\", X, P); } scanf(\"%d\", &amp;N); while ( N-- ) { scanf(\"%d\", &amp;P); if ( Delete(L, P)==false ) printf(\" Deletion Error.\\n\"); if ( Insert(L, 0, P)==false ) printf(\" Insertion Error: 0 is not in.\\n\"); } return 0;}/* 你的代码将被嵌在这里 */ 输入样例：12345661 2 3 4 5 636 5 12-1 6 输出样例：12345678FULL Insertion Error: 6 is not in.Finding Error: 6 is not in.5 is at position 0.1 is at position 4.POSITION -1 EMPTY Deletion Error.FULL Insertion Error: 0 is not in.POSITION 6 EMPTY Deletion Error.FULL Insertion Error: 0 is not in. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546List MakeEmpty(){ List p; p = (List)malloc(sizeof(struct LNode)); p-&gt;Last = -1;//这里令last为-1,这样可以last每次指的就是最后一个数据，而不是下一个数据的下一个 return p;}Position Find( List L, ElementType X ){ int i; for(i = 0; i &lt;= L-&gt;Last; i++){ if(X==L-&gt;Data[i]){//遍历搜索查找 return i; } } return ERROR;}bool Insert( List L, ElementType X, Position P ){ if(L-&gt;Last==MAXSIZE-1){//容量慢 printf(\"FULL\"); return false; } if(P&lt;0||P&gt;L-&gt;Last+1){//只能查到已有数字的位置或最后一个的下一个 printf(\"ILLEGAL POSITION\"); return false; } int i; for(i = L-&gt;Last+1; i &gt; P; i--){ L-&gt;Data[i] = L-&gt;Data[i-1];//向右平移 } L-&gt;Data[i] = X;//插入 L-&gt;Last++;//个数增加 return true;}bool Delete( List L, Position P ){ int i; //if(L-&gt;Last==-1)return false;//为空！！！因为这一句多此一举的判断导致为空时应输出empty没输出 if(P&lt;0||P&gt;L-&gt;Last){//删除的位置不在已有位置内 printf(\"POSITION %d EMPTY\",P); return false; } for(i = P; i &lt; L-&gt;Last; i++){//删除后向左平移 L-&gt;Data[i] = L-&gt;Data[i+1]; } L-&gt;Last--;//减少一个 return true;}","link":"/2018/05/06/shujiujiegou6-2/"},{"title":"6-2 顺序表操作集 (20 分)","text":"6-3 求链式表的表长 (10 分)本题要求实现一个函数，求链式表的表长。 函数接口定义：1int Length( List L ); 其中List结构定义如下： 123456typedef struct LNode *PtrToLNode;struct LNode { ElementType Data; PtrToLNode Next;};typedef PtrToLNode List; L是给定单链表，函数Length要返回链式表的长度。 裁判测试程序样例：1234567891011121314151617181920212223#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef int ElementType;typedef struct LNode *PtrToLNode;struct LNode { ElementType Data; PtrToLNode Next;};typedef PtrToLNode List;List Read(); /* 细节在此不表 */int Length( List L );int main(){ List L = Read(); printf(\"%d\\n\", Length(L)); return 0;}/* 你的代码将被嵌在这里 */ 输入样例：11 3 4 5 2 -1 输出样例：15 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef int ElementType;typedef struct LNode *PtrToLNode;struct LNode { ElementType Data; PtrToLNode Next;};typedef PtrToLNode List;List Read(); /* 细节在此不表 */int Length( List L );int main(){ List L = Read(); printf(\"%d\\n\", Length(L)); return 0;}List Read(){ int num; scanf(\"%d\",&amp;num); if(num==-1) { return NULL; } PtrToLNode head=NULL,list=NULL; head=(PtrToLNode)malloc(sizeof(struct LNode)); head-&gt;Data=num; head-&gt;Next=NULL; list=head; scanf(\"%d\",&amp;num); while(num!=-1) { PtrToLNode node=(PtrToLNode)malloc(sizeof(struct LNode)); node-&gt;Data=num; node-&gt;Next=NULL; list-&gt;Next=node; list=node; scanf(\"%d\",&amp;num); } return head;}/* 你的代码将被嵌在这里 */int Length( List L ){ int n=0; if(L==NULL)return 0; while(L!=NULL) { L=L-&gt;Next; n++; } return n;}","link":"/2018/05/06/shujiujiegou6-3/"},{"title":"6-12 二叉搜索树的操作集 (30 分)","text":"6-12 二叉搜索树的操作集 (30 分)本题要求实现给定二叉搜索树的5种常用操作。 函数接口定义：12345BinTree Insert( BinTree BST, ElementType X );BinTree Delete( BinTree BST, ElementType X );Position Find( BinTree BST, ElementType X );Position FindMin( BinTree BST );Position FindMax( BinTree BST ); 其中BinTree结构定义如下： 1234567typedef struct TNode *Position;typedef Position BinTree;struct TNode{ ElementType Data; BinTree Left; BinTree Right;}; 函数Insert将X插入二叉搜索树BST并返回结果树的根结点指针； 函数Delete将X从二叉搜索树BST中删除，并返回结果树的根结点指针；如果X不在树中，则打印一行Not Found并返回原树的根结点指针； 函数Find在二叉搜索树BST中找到X，返回该结点的指针；如果找不到则返回空指针； 函数FindMin返回二叉搜索树BST中最小元结点的指针； 函数FindMax返回二叉搜索树BST中最大元结点的指针。 裁判测试程序样例：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef int ElementType;typedef struct TNode *Position;typedef Position BinTree;struct TNode{ ElementType Data; BinTree Left; BinTree Right;};void PreorderTraversal( BinTree BT ); /* 先序遍历，由裁判实现，细节不表 */void InorderTraversal( BinTree BT ); /* 中序遍历，由裁判实现，细节不表 */BinTree Insert( BinTree BST, ElementType X );BinTree Delete( BinTree BST, ElementType X );Position Find( BinTree BST, ElementType X );Position FindMin( BinTree BST );Position FindMax( BinTree BST );int main(){ BinTree BST, MinP, MaxP, Tmp; ElementType X; int N, i; BST = NULL; scanf(\"%d\", &amp;N); for ( i=0; i&lt;N; i++ ) { scanf(\"%d\", &amp;X); BST = Insert(BST, X); } printf(\"Preorder:\"); PreorderTraversal(BST); printf(\"\\n\"); MinP = FindMin(BST); MaxP = FindMax(BST); scanf(\"%d\", &amp;N); for( i=0; i&lt;N; i++ ) { scanf(\"%d\", &amp;X); Tmp = Find(BST, X); if (Tmp == NULL) printf(\"%d is not found\\n\", X); else { printf(\"%d is found\\n\", Tmp-&gt;Data); if (Tmp==MinP) printf(\"%d is the smallest key\\n\", Tmp-&gt;Data); if (Tmp==MaxP) printf(\"%d is the largest key\\n\", Tmp-&gt;Data); } } scanf(\"%d\", &amp;N); for( i=0; i&lt;N; i++ ) { scanf(\"%d\", &amp;X); BST = Delete(BST, X); } printf(\"Inorder:\"); InorderTraversal(BST); printf(\"\\n\"); return 0;}/* 你的代码将被嵌在这里 */ 输入样例：123456105 8 6 2 4 1 0 10 9 756 3 10 0 555 7 0 10 3 输出样例：12345678910Preorder: 5 2 1 0 4 8 6 7 10 96 is found3 is not found10 is found10 is the largest key0 is found0 is the smallest key5 is foundNot FoundInorder: 1 2 4 6 8 9 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283BinTree Insert( BinTree BST, ElementType X ){ //如果是一个空节点 if(!BST){ BST = (BinTree)malloc(sizeof(struct TNode));//既然为空所以要生成一个 BST-&gt;Data = X; BST-&gt;Left = NULL; BST-&gt;Right = NULL; } else{//一般情况 if(X &lt; BST-&gt;Data){//插入值小于节点，应该往左子树中找位置 BST-&gt;Left = Insert(BST-&gt;Left,X);//递归插入左子树 } else if(X &gt; BST-&gt;Data){//插入值大于节点，应该往右子树中找 BST-&gt;Right = Insert(BST-&gt;Right,X);//递归插入右子树 } //如果相等说明X已经存在，什么也不做 } return BST;}Position Find( BinTree BST, ElementType X ){ while(BST){//直接循环查找，类似链表 if(X &lt; BST-&gt;Data){ BST = BST-&gt;Left;//小于节点，找左子树 } else if(X &gt; BST-&gt;Data){//大于节点，找右子树 BST = BST-&gt;Right; } else{//相等则找到 return BST; } } return NULL;}Position FindMin( BinTree BST ){ if(!BST){ return NULL; } else if(!BST-&gt;Left) return BST; else return FindMin(BST-&gt;Left);}Position FindMax( BinTree BST ){ if(!BST)return NULL; else if(!BST-&gt;Right)return BST; else return FindMax(BST-&gt;Right);}BinTree Delete( BinTree BST, ElementType X ){ Position temp; if(!BST){ printf(\"Not Found\\n\");//如果最终树为空，说明没有 } else{//这里类似于插入重点在于找到后怎么办 if(X &lt; BST-&gt;Data){ BST-&gt;Left = Delete(BST-&gt;Left,X);//从左子树递归删除 } else if(X &gt; BST-&gt;Data){ BST-&gt;Right = Delete(BST-&gt;Right,X);//从右子树递归删除 } else{//当前BST就是要删除的节点 if(BST-&gt;Left &amp;&amp; BST-&gt;Right){//要被删除的节点有左右两个孩子，就从右子树中找最小的数填充删除的节点 temp = FindMin(BST-&gt;Right);//找最小 BST-&gt;Data = temp-&gt;Data;//填充删除的节点 BST-&gt;Right = Delete(BST-&gt;Right,temp-&gt;Data);//删除拿来填充的那个节点 } else{//只有一个子节点 temp = BST; if(!BST-&gt;Left){//只有右节点 BST = BST-&gt;Right;//直接赋值就可以 } else if(!BST-&gt;Right){//只有左节点 BST = BST-&gt;Left;//直接赋值就可以 } free(temp);//如果啥也没有直接删除就可以，当然上面两种情况赋值后也要删除 } } } return BST;}--------------------- 作者：一只二十四节气 来源：CSDN 原文：https://blog.csdn.net/codeswarrior/article/details/78465879 版权声明：本文为博主原创文章，转载请附上博文链接！","link":"/2018/05/06/shujiujiegou6-12/"},{"title":"6-4 链式表的按序号查找 (10 分)","text":"6-4 链式表的按序号查找 (10 分)本题要求实现一个函数，找到并返回链式表的第K个元素。 函数接口定义：1ElementType FindKth( List L, int K ); 其中List结构定义如下： 123456typedef struct LNode *PtrToLNode;struct LNode { ElementType Data; PtrToLNode Next;};typedef PtrToLNode List; L是给定单链表，函数FindKth要返回链式表的第K个元素。如果该元素不存在，则返回ERROR。 裁判测试程序样例：12345678910111213141516171819202122232425262728293031323334#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define ERROR -1typedef int ElementType;typedef struct LNode *PtrToLNode;struct LNode { ElementType Data; PtrToLNode Next;};typedef PtrToLNode List;List Read(); /* 细节在此不表 */ElementType FindKth( List L, int K );int main(){ int N, K; ElementType X; List L = Read(); scanf(\"%d\", &amp;N); while ( N-- ) { scanf(\"%d\", &amp;K); X = FindKth(L, K); if ( X!= ERROR ) printf(\"%d \", X); else printf(\"NA \"); } return 0;}/* 你的代码将被嵌在这里 */ 输入样例：1231 3 4 5 2 -163 6 1 5 4 2 输出样例：14 NA 1 2 5 3 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define ERROR -1typedef int ElementType;typedef struct LNode *PtrToLNode;struct LNode { ElementType Data; PtrToLNode Next;};typedef PtrToLNode List;List Read();ElementType FindKth( List L, int K );int main(){ //freopen(\"in.txt\",\"r\",stdin); int N, K; ElementType X; List L = Read(); scanf(\"%d\", &amp;N); while ( N-- ) { scanf(\"%d\", &amp;K); X = FindKth(L, K); if ( X!= ERROR ) printf(\"%d \", X); else printf(\"NA \"); } return 0;}List Read() //尾插法 { int num = 0; scanf( \"%d\",&amp;num ); List list = ( List )malloc( sizeof( struct LNode ) ); list-&gt;Next = NULL; //生成链表 list-&gt;Data = num; List last = list; //生成指向表尾的指针 while( scanf( \"%d\",&amp;num )==1&amp;&amp;(num!=-1)){ PtrToLNode node = ( List )malloc( sizeof( struct LNode ) );//生成新节点 node-&gt;Data = num; node-&gt;Next = NULL; last-&gt;Next = node; //将新节点插入表尾 last = node; //表尾指针指向新节点 } return list;}ElementType FindKth( List L, int K ){ if(L==NULL) return ERROR; while(--K){ //往后移动K-1次,查找第K个元素 if(L-&gt;Next==NULL) return ERROR; //若K大于链表的长度，返回ERROR else L=L-&gt;Next; } return L-&gt;Data; //返回第K个元素 }","link":"/2018/05/06/shujiujiegou6-4/"},{"title":"6-7 在一个数组中实现两个堆栈 (20 分)","text":"6-7 在一个数组中实现两个堆栈 (20 分)本题要求在一个数组中实现两个堆栈。 函数接口定义：123Stack CreateStack( int MaxSize );bool Push( Stack S, ElementType X, int Tag );ElementType Pop( Stack S, int Tag ); 其中Tag是堆栈编号，取1或2；MaxSize堆栈数组的规模；Stack结构定义如下： 1234567typedef int Position;struct SNode { ElementType *Data; Position Top1, Top2; int MaxSize;};typedef struct SNode *Stack; 注意：如果堆栈已满，Push函数必须输出“Stack Full”并且返回false；如果某堆栈是空的，则Pop函数必须输出“Stack Tag Empty”（其中Tag是该堆栈的编号），并且返回ERROR。 裁判测试程序样例：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define ERROR 1e8typedef int ElementType;typedef enum { push, pop, end } Operation;typedef enum { false, true } bool;typedef int Position;struct SNode { ElementType *Data; Position Top1, Top2; int MaxSize;};typedef struct SNode *Stack;Stack CreateStack( int MaxSize );bool Push( Stack S, ElementType X, int Tag );ElementType Pop( Stack S, int Tag );Operation GetOp(); /* details omitted */void PrintStack( Stack S, int Tag ); /* details omitted */int main(){ int N, Tag, X; Stack S; int done = 0; scanf(\"%d\", &amp;N); S = CreateStack(N); while ( !done ) { switch( GetOp() ) { case push: scanf(\"%d %d\", &amp;Tag, &amp;X); if (!Push(S, X, Tag)) printf(\"Stack %d is Full!\\n\", Tag); break; case pop: scanf(\"%d\", &amp;Tag); X = Pop(S, Tag); if ( X==ERROR ) printf(\"Stack %d is Empty!\\n\", Tag); break; case end: PrintStack(S, 1); PrintStack(S, 2); done = 1; break; } } return 0;}/* 你的代码将被嵌在这里 */ 输入样例：1234567891011125Push 1 1Pop 2Push 2 11Push 1 2Push 2 12Pop 1Push 2 13Push 2 14Push 1 3Pop 2End 输出样例：123456Stack 2 EmptyStack 2 is Empty!Stack FullStack 1 is Full!Pop from Stack 1: 1Pop from Stack 2: 13 12 11 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071Operation GetOp(){ char Push[] = \"Push\"; char Pop[] = \"Pop\"; char End[] = \"End\"; char s[100]; scanf(\"%s\", s); if (strcmp(Push, s) == 0)return push; if (strcmp(Pop, s) == 0)return pop; if (strcmp(End, s) == 0)return end;}void PrintStack(Stack S, int Tag){ printf(\"Pop from Stack %d:\", Tag); if (Tag == 1){ while (S-&gt;Top1 != -1){ printf(\" %d\", S-&gt;Data[S-&gt;Top1--]); } } else { while (S-&gt;Top2 != S-&gt;MaxSize){ printf(\" %d\", S-&gt;Data[S-&gt;Top2++]); } } putchar('\\n');}Stack CreateStack(int MaxSize){ Stack stack = (Stack)malloc(sizeof(struct SNode)); stack-&gt;Data = (int *)malloc(sizeof(ElementType)* MaxSize); stack-&gt;Top1 = -1; stack-&gt;Top2 = MaxSize; stack-&gt;MaxSize = MaxSize; return stack;}bool Push(Stack S, ElementType X, int Tag){ if (S == NULL)return false; if (S-&gt;Top1+1==S-&gt;Top2){ printf(\"Stack Full\\n\"); return false; } if (Tag == 1) S-&gt;Data[++S-&gt;Top1] = X; else S-&gt;Data[--S-&gt;Top2] = X; return true;}ElementType Pop(Stack S, int Tag){ if (S == NULL)return ERROR; if (Tag == 1){ if (S-&gt;Top1 == -1) { printf(\"Stack %d Empty\\n\",Tag); return ERROR; } return S-&gt;Data[S-&gt;Top1--]; } if (S-&gt;Top2 == S-&gt;MaxSize) { printf(\"Stack %d Empty\\n\", Tag); return ERROR; } return S-&gt;Data[S-&gt;Top2++]; }","link":"/2018/05/06/shujiujiegou6-7/"},{"title":"6-6 带头结点的链式表操作集 (20 分)","text":"6-6 带头结点的链式表操作集 (20 分)本题要求实现带头结点的链式表操作集。 函数接口定义：1234List MakeEmpty(); Position Find( List L, ElementType X );bool Insert( List L, ElementType X, Position P );bool Delete( List L, Position P ); 其中List结构定义如下： 1234567typedef struct LNode *PtrToLNode;struct LNode { ElementType Data; PtrToLNode Next;};typedef PtrToLNode Position;typedef PtrToLNode List; 各个操作函数的定义为： List MakeEmpty()：创建并返回一个空的线性表； Position Find( List L, ElementType X )：返回线性表中X的位置。若找不到则返回ERROR； bool Insert( List L, ElementType X, Position P )：将X插入在位置P指向的结点之前，返回true。如果参数P指向非法位置，则打印“Wrong Position for Insertion”，返回false； bool Delete( List L, Position P )：将位置P的元素删除并返回true。若参数P指向非法位置，则打印“Wrong Position for Deletion”并返回false。 裁判测试程序样例：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define ERROR NULLtypedef enum {false, true} bool;typedef int ElementType;typedef struct LNode *PtrToLNode;struct LNode { ElementType Data; PtrToLNode Next;};typedef PtrToLNode Position;typedef PtrToLNode List;List MakeEmpty(); Position Find( List L, ElementType X );bool Insert( List L, ElementType X, Position P );bool Delete( List L, Position P );int main(){ List L; ElementType X; Position P; int N; bool flag; L = MakeEmpty(); scanf(\"%d\", &amp;N); while ( N-- ) { scanf(\"%d\", &amp;X); flag = Insert(L, X, L-&gt;Next); if ( flag==false ) printf(\"Wrong Answer\\n\"); } scanf(\"%d\", &amp;N); while ( N-- ) { scanf(\"%d\", &amp;X); P = Find(L, X); if ( P == ERROR ) printf(\"Finding Error: %d is not in.\\n\", X); else { flag = Delete(L, P); printf(\"%d is found and deleted.\\n\", X); if ( flag==false ) printf(\"Wrong Answer.\\n\"); } } flag = Insert(L, X, NULL); if ( flag==false ) printf(\"Wrong Answer\\n\"); else printf(\"%d is inserted as the last element.\\n\", X); P = (Position)malloc(sizeof(struct LNode)); flag = Insert(L, X, P); if ( flag==true ) printf(\"Wrong Answer\\n\"); flag = Delete(L, P); if ( flag==true ) printf(\"Wrong Answer\\n\"); for ( P=L-&gt;Next; P; P = P-&gt;Next ) printf(\"%d \", P-&gt;Data); return 0;}/* 你的代码将被嵌在这里 */ 输入样例：1234612 2 4 87 10 242 12 87 5 输出样例：123456782 is found and deleted.12 is found and deleted.87 is found and deleted.Finding Error: 5 is not in.5 is inserted as the last element.Wrong Position for InsertionWrong Position for Deletion10 4 2 5 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061List MakeEmpty(){ List list = (List)malloc(sizeof(struct LNode)); list-&gt;Data = 0; list-&gt;Next = NULL; return list;}Position Find(List L, ElementType X){ List list = L-&gt;Next; int flag = 0; for (int i = 0; i &lt; L-&gt;Data; i++){ if (list-&gt;Data == X) { flag = 1; break; } else list = list-&gt;Next; } return flag == 1 ? list : ERROR;}bool Insert(List L, ElementType X, Position P){ List list = L; int flag = 0; List temp = (List)malloc(sizeof(struct LNode)); temp-&gt;Data = X; temp-&gt;Next = NULL; for (int i = 0; i &lt;= L-&gt;Data; i++, list = list-&gt;Next) if (list-&gt;Next == P) { flag = 1; break; } if (flag){ temp-&gt;Next = list-&gt;Next; list-&gt;Next = temp; L-&gt;Data++; return true; } printf(\"Wrong Position for Insertion\\n\"); return false; }bool Delete(List L, Position P){ List list = L; int flag = 0; for (int i = 0; i &lt; L-&gt;Data; i++, list = list-&gt;Next) if (list-&gt;Next == P) { flag = 1; break; } if (flag){ list-&gt;Next = list-&gt;Next-&gt;Next; L-&gt;Data--; return true; } printf(\"Wrong Position for Deletion\\n\"); return false;}","link":"/2018/05/06/shujiujiegou6-6/"},{"title":"6-5 链式表操作集 (20 分)","text":"6-5 链式表操作集 (20 分)本题要求实现链式表的操作集。 函数接口定义：123Position Find( List L, ElementType X );List Insert( List L, ElementType X, Position P );List Delete( List L, Position P ); 其中List结构定义如下： 1234567typedef struct LNode *PtrToLNode;struct LNode { ElementType Data; PtrToLNode Next;};typedef PtrToLNode Position;typedef PtrToLNode List; 各个操作函数的定义为： Position Find( List L, ElementType X )：返回线性表中首次出现X的位置。若找不到则返回ERROR； List Insert( List L, ElementType X, Position P )：将X插入在位置P指向的结点之前，返回链表的表头。如果参数P指向非法位置，则打印“Wrong Position for Insertion”，返回ERROR； List Delete( List L, Position P )：将位置P的元素删除并返回链表的表头。若参数P指向非法位置，则打印“Wrong Position for Deletion”并返回ERROR。 裁判测试程序样例：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define ERROR NULLtypedef int ElementType;typedef struct LNode *PtrToLNode;struct LNode { ElementType Data; PtrToLNode Next;};typedef PtrToLNode Position;typedef PtrToLNode List;Position Find( List L, ElementType X );List Insert( List L, ElementType X, Position P );List Delete( List L, Position P );int main(){ List L; ElementType X; Position P, tmp; int N; L = NULL; scanf(\"%d\", &amp;N); while ( N-- ) { scanf(\"%d\", &amp;X); L = Insert(L, X, L); if ( L==ERROR ) printf(\"Wrong Answer\\n\"); } scanf(\"%d\", &amp;N); while ( N-- ) { scanf(\"%d\", &amp;X); P = Find(L, X); if ( P == ERROR ) printf(\"Finding Error: %d is not in.\\n\", X); else { L = Delete(L, P); printf(\"%d is found and deleted.\\n\", X); if ( L==ERROR ) printf(\"Wrong Answer or Empty List.\\n\"); } } L = Insert(L, X, NULL); if ( L==ERROR ) printf(\"Wrong Answer\\n\"); else printf(\"%d is inserted as the last element.\\n\", X); P = (Position)malloc(sizeof(struct LNode)); tmp = Insert(L, X, P); if ( tmp!=ERROR ) printf(\"Wrong Answer\\n\"); tmp = Delete(L, P); if ( tmp!=ERROR ) printf(\"Wrong Answer\\n\"); for ( P=L; P; P = P-&gt;Next ) printf(\"%d \", P-&gt;Data); return 0;}/* 你的代码将被嵌在这里 */ 输入样例：1234612 2 4 87 10 242 12 87 5 输出样例：123456782 is found and deleted.12 is found and deleted.87 is found and deleted.Finding Error: 5 is not in.5 is inserted as the last element.Wrong Position for InsertionWrong Position for Deletion10 4 2 5 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt; #define ERROR NULLtypedef int ElementType;typedef struct LNode *PtrToLNode;struct LNode { ElementType Data; PtrToLNode Next;};typedef PtrToLNode Position;typedef PtrToLNode List; Position Find( List L, ElementType X );List Insert( List L, ElementType X, Position P );List Delete( List L, Position P ); int main(){ List L; ElementType X; Position P, tmp; int N; L = NULL; scanf(\"%d\", &amp;N); while ( N-- ) { scanf(\"%d\", &amp;X); L = Insert(L, X, L); if ( L==ERROR ) printf(\"Wrong Answer\\n\"); } scanf(\"%d\", &amp;N); while ( N-- ) { scanf(\"%d\", &amp;X); P = Find(L, X); if ( P == ERROR ) printf(\"Finding Error: %d is not in.\\n\", X); else { L = Delete(L, P); printf(\"%d is found and deleted.\\n\", X); if ( L==ERROR ) printf(\"Wrong Answer or Empty List.\\n\"); } } L = Insert(L, X, NULL); if ( L==ERROR ) printf(\"Wrong Answer\\n\"); else printf(\"%d is inserted as the last element.\\n\", X); P = (Position)malloc(sizeof(struct LNode)); tmp = Insert(L, X, P); if ( tmp!=ERROR ) printf(\"Wrong Answer\\n\"); tmp = Delete(L, P); if ( tmp!=ERROR ) printf(\"Wrong Answer\\n\"); for ( P=L; P; P = P-&gt;Next ) printf(\"%d \", P-&gt;Data); return 0;} /* 你的代码将被嵌在这里 */Position Find( List L, ElementType X ){ while(L!=NULL){ if(L-&gt;Data == X){ return L; } L = L-&gt;Next; } return ERROR;}List Insert( List L, ElementType X, Position P ){ List head = L; List p = (List)malloc(sizeof(List)); p-&gt;Data=X; p-&gt;Next=NULL; if(L==P){ p-&gt;Next=L; return p; } while(L){ if(P==L-&gt;Next){ p-&gt;Next=L-&gt;Next; L-&gt;Next=p; return head; } L=L-&gt;Next; } printf(\"Wrong Position for Insertion\\n\"); return ERROR;}List Delete( List L, Position P ){ if(L==P){ L=L-&gt;Next; return L; } List head = L; while(L){ if(L-&gt;Next==P){ L-&gt;Next=P-&gt;Next; return head; } L=L-&gt;Next; } printf(\"Wrong Position for Deletion\\n\"); return ERROR; }","link":"/2018/05/06/shujiujiegou6-5/"},{"title":"6-8 求二叉树高度 (20 分)","text":"6-8 求二叉树高度 (20 分)本题要求给定二叉树的高度。 函数接口定义：1int GetHeight( BinTree BT ); 其中BinTree结构定义如下： 1234567typedef struct TNode *Position;typedef Position BinTree;struct TNode{ ElementType Data; BinTree Left; BinTree Right;}; 要求函数返回给定二叉树BT的高度值。 裁判测试程序样例：12345678910111213141516171819202122#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef char ElementType;typedef struct TNode *Position;typedef Position BinTree;struct TNode{ ElementType Data; BinTree Left; BinTree Right;};BinTree CreatBinTree(); /* 实现细节忽略 */int GetHeight( BinTree BT );int main(){ BinTree BT = CreatBinTree(); printf(\"%d\\n\", GetHeight(BT)); return 0;}/* 你的代码将被嵌在这里 */ 输出样例（对于图中给出的树）： 14 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#define OVERFLOW -2typedef char ElementType;typedef struct TNode *Position;typedef Position BinTree;struct TNode{ ElementType Data; BinTree Left; BinTree Right;};BinTree CreatBinTree(){ BinTree BT = (BinTree)malloc(sizeof(struct TNode)); BT-&gt;Left=NULL; BT-&gt;Right=NULL; return BT;}int GetHeight( BinTree BT );int main(){ BinTree BT = CreatBinTree(); printf(\"%d\\n\", GetHeight(BT)); return 0;}/* 你的代码将被嵌在这里 */int GetHeight(BinTree BT)//输出二叉树的高度{ int high=4;int high1,high2; if(BT) { high1=GetHeight(BT-&gt;Left); high2=GetHeight(BT-&gt;Right); if(high1&gt;high2) high=high1; else high=high2; } return high;}","link":"/2018/05/06/shujiujiegou6-8/"},{"title":"6-9 二叉树的遍历 (25 分)","text":"6-9 二叉树的遍历 (25 分)本题要求给定二叉树的4种遍历。 函数接口定义：1234void InorderTraversal( BinTree BT );void PreorderTraversal( BinTree BT );void PostorderTraversal( BinTree BT );void LevelorderTraversal( BinTree BT ); 其中BinTree结构定义如下： 1234567typedef struct TNode *Position;typedef Position BinTree;struct TNode{ ElementType Data; BinTree Left; BinTree Right;}; 要求4个函数分别按照访问顺序打印出结点的内容，格式为一个空格跟着一个字符。 裁判测试程序样例：12345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef char ElementType;typedef struct TNode *Position;typedef Position BinTree;struct TNode{ ElementType Data; BinTree Left; BinTree Right;};BinTree CreatBinTree(); /* 实现细节忽略 */void InorderTraversal( BinTree BT );void PreorderTraversal( BinTree BT );void PostorderTraversal( BinTree BT );void LevelorderTraversal( BinTree BT );int main(){ BinTree BT = CreatBinTree(); printf(\"Inorder:\"); InorderTraversal(BT); printf(\"\\n\"); printf(\"Preorder:\"); PreorderTraversal(BT); printf(\"\\n\"); printf(\"Postorder:\"); PostorderTraversal(BT); printf(\"\\n\"); printf(\"Levelorder:\"); LevelorderTraversal(BT); printf(\"\\n\"); return 0;}/* 你的代码将被嵌在这里 */ 输出样例（对于图中给出的树）： 1234Inorder: D B E F A G H C IPreorder: A B D F E C G H IPostorder: D E F B H G I C ALevelorder: A B C D F G I E H 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt; typedef char ElementType;typedef struct TNode *Position;typedef Position BinTree;struct TNode{ ElementType Data; BinTree Left; BinTree Right;}; BinTree CreatBinTree(); /* 实现细节忽略 */void InorderTraversal( BinTree BT );void PreorderTraversal( BinTree BT );void PostorderTraversal( BinTree BT );void LevelorderTraversal( BinTree BT ); BinTree CreatBinTree(){ BinTree BT = (BinTree)malloc(sizeof(struct TNode)); BT-&gt;Left=NULL; BT-&gt;Right=NULL; return BT;}int main(){ BinTree BT = CreatBinTree(); printf(\"Inorder:\"); InorderTraversal(BT); printf(\"\\n\"); printf(\"Preorder:\"); PreorderTraversal(BT); printf(\"\\n\"); printf(\"Postorder:\"); PostorderTraversal(BT); printf(\"\\n\"); printf(\"Levelorder:\"); LevelorderTraversal(BT); printf(\"\\n\"); return 0;}/* 你的代码将被嵌在这里 */void InorderTraversal( BinTree BT ){ if(BT == NULL){ return; } InorderTraversal(BT-&gt;Left); printf(\" %c\",BT-&gt;Data); InorderTraversal(BT-&gt;Right);} void PreorderTraversal( BinTree BT ){ if(BT == NULL){ return; } printf(\" %c\",BT-&gt;Data); PreorderTraversal(BT-&gt;Left); PreorderTraversal(BT-&gt;Right);} void PostorderTraversal( BinTree BT ){ if(BT == NULL){ return; } PostorderTraversal(BT-&gt;Left); PostorderTraversal(BT-&gt;Right); printf(\" %c\",BT-&gt;Data);} void LevelorderTraversal( BinTree BT ){ BinTree Queue[1000]; //数据不大，1000够用 int top = -1; int tail = -1; if(BT)Queue[++tail] = BT; while(top&lt;tail){ BinTree bt = Queue[++top]; printf(\" %c\",bt-&gt;Data); if(bt-&gt;Left){ Queue[++tail] = bt-&gt;Left; } if(bt-&gt;Right){ Queue[++tail] = bt-&gt;Right; } }}","link":"/2018/05/06/shujiujiegou6-9/"},{"title":"7-13 统计工龄 (20 分)","text":"7-13 统计工龄 (20 分)给定公司$N$名员工的工龄，要求按工龄增序输出每个工龄段有多少员工。 输入格式:输入首先给出正整数$N$（≤105），即员工总人数；随后给出$N$个整数，即每个员工的工龄，范围在[0, 50]。 输出格式:按工龄的递增顺序输出每个工龄的员工个数，格式为：“工龄:人数”。每项占一行。如果人数为0则不输出该项。 输入样例:12810 2 0 5 7 2 5 2 输出样例:123450:12:35:27:110:1 12345678910111213141516171819202122232425262728293031#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#define MAXN 100005#define GONGLING 55#define INFINITY 65535int a[MAXN];int gl[GONGLING];int main(){ int i; int n; scanf(\"%d\",&amp;n); for( i=0; i&lt;n; i++){ scanf(\"%d\",&amp;a[i]); } for( i=0; i&lt;n; i++){ gl[a[i]] ++; } for( i=0; i&lt;51; i++){ if( gl[i] ){ printf(\"%d:%d\\n\",i,gl[i]); } } return 0;}","link":"/2018/05/06/shujiujiegou7-13/"},{"title":"7-12 排序 (25 分)","text":"7-12 排序 (25 分)给定$N$个（长整型范围内的）整数，要求输出从小到大排序后的结果。 本题旨在测试各种不同的排序算法在各种数据情况下的表现。各组测试数据特点如下： 数据1：只有1个元素； 数据2：11个不相同的整数，测试基本正确性； 数据3：$10^3$个随机整数； 数据4：$10^4$个随机整数； 数据5：$10^5$个随机整数； 数据6：$10^5$个随机整数； 数据7：$10^5$个随机整数； 数据8：$10^5$个随机整数； 数据9：$10^5$个随机正整数，每个数字不超过1000。 输入格式:输入第一行给出正整数$N$（≤105），随后一行给出$N$个（长整型范围内的）整数，其间以空格分隔。 输出格式:在一行中输出从小到大排序后的结果，数字间以1个空格分隔，行末不得有多余空格。 输入样例:12114 981 10 -17 0 -20 29 50 8 43 -5 输出样例:1-20 -17 -5 0 4 8 10 29 43 50 981 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#define MAXN 100005#define INFINITY 65535int a[MAXN];int n;void ShellSort();int main(){ int i; scanf(\"%d\",&amp;n); for( i=0; i&lt;n; i++){ scanf(\"%d\",&amp;a[i]); } ShellSort(); for( i=0; i&lt;n; i++){ printf(\"%d\",a[i]); if( i!=(n-1)){ printf(\" \"); } } return 0;}void ShellSort(){ int i,j; int temp; int increment; for( increment=n/2; increment&gt;0; increment/=2){ for( i=increment; i&lt;n; i++){ temp = a[i]; for( j=i-increment; j&gt;=0 &amp;&amp; temp&lt;a[j]; j-=increment){ a[ j+increment ] = a[j]; } a[ j+increment ] = temp; } }}","link":"/2018/05/06/shujiujiegou7-12/"},{"title":"7-10 公路村村通 (30 分)","text":"7-10 公路村村通 (30 分)现有村落间道路的统计数据表中，列出了有可能建设成标准公路的若干条道路的成本，求使每个村落都有公路连通所需要的最低成本。 输入格式:输入数据包括城镇数目正整数$N$（≤1000）和候选道路数目$M$（≤3$N$）；随后的$M$行对应$M$条道路，每行给出3个正整数，分别是该条道路直接连通的两个城镇的编号以及该道路改建的预算成本。为简单起见，城镇从1到$N$编号。 输出格式:输出村村通需要的最低成本。如果输入数据不足以保证畅通，则输出−1，表示需要建设更多公路。 输入样例:123456789101112131415166 151 2 51 3 31 4 71 5 41 6 22 3 42 4 62 5 22 6 63 4 63 5 13 6 14 5 104 6 85 6 3 输出样例:112 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#define MAXVEX 1003#define INFINITY 65535void CreateGraph( );int Prim();int G[MAXVEX][MAXVEX],Nv,Ne;int main(){ int f = 0; scanf(\"%d %d\",&amp;Nv,&amp;Ne); CreateGraph(); f =Prim(); printf(\"%d\",f); return 0;}void CreateGraph(){ //用邻接矩阵表示图 int i,j; int v1,v2,w; for( i=1; i&lt;=Nv; i++) { for( j=1; j&lt;=Nv; j++) { G[i][j] = INFINITY; //初始化 } } for( i=0; i&lt;Ne; i++) //注意这里是读入边 { scanf(\"%d %d %d\",&amp;v1,&amp;v2,&amp;w); G[v1][v2] = w; //读入权值 G[v2][v1]= G[v1][v2]; //无向图对称 }}int Prim(){ int min; int i,j,k; int lowcost[MAXVEX]; int cost =0; lowcost[1] = 0; //初始化第一个权值为0,即v0加入生成树 for( i=2; i&lt;=Nv; i++) { lowcost[i] = G[1][i]; } for( i=2; i&lt;=Nv; i++) { min = INFINITY; j = 1; k = 0; while( j&lt;=Nv ) { if( lowcost[j]!=0 &amp;&amp; lowcost[j]&lt;min) { min = lowcost[j]; k = j; //将当前最小值的下标存入k } j++; } if(k==0) { return -1; //不连通 } cost += min; lowcost[k] = 0; //将当前顶点设置为0，表示此结点已经完成任务 for( j=2; j&lt;=Nv; j++) { if( lowcost[j]!=0 &amp;&amp; G[k][j]&lt;lowcost[j]) { //若下标为k顶点各边权值小于此前这些顶点未被加入生成树的权值 lowcost[j] = G[k][j]; } } } return cost;}","link":"/2018/05/06/shujiujiegou7-10/"},{"title":"7-1 最大子列和问题 (20 分)","text":"7-1 最大子列和问题 (20 分)给定K个整数组成的序列${ N_1, N_2, \\dots, N_K }，“$连续子列”被定义为$\\left{N_{i}, N_{i+1}, \\dots, N_{j}\\right}$，其中$ 1 \\leq i \\leq j \\leq K $。“最大子列和”则被定义为所有连续子列元素的和中最大者。例如给定序列{ -2, 11, -4, 13, -5, -2 }，其连续子列{ 11, -4, 13 }有最大的和20。现要求你编写程序，计算给定整数序列的最大子列和。 本题旨在测试各种不同的算法在各种数据情况下的表现。各组测试数据特点如下： 数据1：与样例等价，测试基本正确性； 数据2：102个随机整数； 数据3：103个随机整数； 数据4：104个随机整数； 数据5：105个随机整数； 输入格式:输入第1行给出正整数$K (\\leq 100000)$；第2行给出$K$个整数，其间以空格分隔。 输出格式:在一行中输出最大子列和。如果序列中所有整数皆为负数，则输出0。 输入样例:126-2 11 -4 13 -5 -2 输出样例:120 123456789101112131415161718#include&lt;stdio.h&gt;int main(){ int n,i,a[100000]; scanf(\"%d\",&amp;n); for(i=0;i&lt;n;i++) scanf(\"%d\",&amp;a[i]); int msum=0,k,j,sum=0; for(i=0;i&lt;n;i++) { sum=sum+a[i]; if(sum&gt;msum) msum=sum; else if(sum&lt;0) sum=0; } printf(\"%d\\n\",msum); }","link":"/2018/05/06/shujiujiegou7-1/"},{"title":"7-11 关键活动 (30 分)","text":"7-11 关键活动 (30 分)假定一个工程项目由一组子任务构成，子任务之间有的可以并行执行，有的必须在完成了其它一些子任务后才能执行。“任务调度”包括一组子任务、以及每个子任务可以执行所依赖的子任务集。 比如完成一个专业的所有课程学习和毕业设计可以看成一个本科生要完成的一项工程，各门课程可以看成是子任务。有些课程可以同时开设，比如英语和C程序设计，它们没有必须先修哪门的约束；有些课程则不可以同时开设，因为它们有先后的依赖关系，比如C程序设计和数据结构两门课，必须先学习前者。 但是需要注意的是，对一组子任务，并不是任意的任务调度都是一个可行的方案。比如方案中存在“子任务A依赖于子任务B，子任务B依赖于子任务C，子任务C又依赖于子任务A”，那么这三个任务哪个都不能先执行，这就是一个不可行的方案。 任务调度问题中，如果还给出了完成每个子任务需要的时间，则我们可以算出完成整个工程需要的最短时间。在这些子任务中，有些任务即使推迟几天完成，也不会影响全局的工期；但是有些任务必须准时完成，否则整个项目的工期就要因此延误，这种任务就叫“关键活动”。 请编写程序判定一个给定的工程项目的任务调度是否可行；如果该调度方案可行，则计算完成整个工程项目需要的最短时间，并输出所有的关键活动。 输入格式:输入第1行给出两个正整数$N$(≤100)和$M$，其中N是任务交接点（即衔接相互依赖的两个子任务的节点，例如：若任务2要在任务1完成后才开始，则两任务之间必有一个交接点）的数量。交接点按1~$N$编号，$M$是子任务的数量，依次编号为1~$M$。随后$M$行，每行给出了3个正整数，分别是该任务开始和完成涉及的交接点编号以及该任务所需的时间，整数间用空格分隔。 输出格式:如果任务调度不可行，则输出0；否则第1行输出完成整个工程项目需要的时间，第2行开始输出所有关键活动，每个关键活动占一行，按格式“V-&gt;W”输出，其中V和W为该任务开始和完成涉及的交接点编号。关键活动输出的顺序规则是：任务开始的交接点编号小者优先，起点编号相同时，与输入时任务的顺序相反。 输入样例:1234567897 81 2 41 3 32 4 53 4 34 5 14 6 65 7 56 7 2 输出样例:12345171-&gt;22-&gt;44-&gt;66-&gt;7 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#define MAXVER 105#define INFINITY 65535int G[MAXVER][MAXVER]; //图int early[MAXVER]; //最早发生时间int late[MAXVER]; //最迟发生时间int in[MAXVER]; //入度int out[MAXVER]; //出度int nv,ne; //顶点数目 ，边数目void CreatGraph();int EarlyTime();void LateTime(int Scost);int FindMax( int a,int b);int FindMin( int a,int b);int main(){ int flag; int i,j; scanf(\"%d %d\",&amp;nv,&amp;ne); CreatGraph(); flag = EarlyTime(); if( flag==-1) { printf(\"0\\n\"); } else { printf(\"%d\\n\",flag); LateTime( flag ); for( i=1; i&lt;=nv; i++) { if(early[i] != late[i]) continue; for( j=nv; j&gt;=1 ; j--) { if( G[i][j]&gt;=0 &amp;&amp; early[j]==late[j] &amp;&amp;late[j]-G[i][j]==early[i]) { //i,j均在关键路径上且相邻 printf(\"%d-&gt;%d\\n\",i,j); } } } } return 0;}void CreatGraph(){ int i,j; int s,d,cost; for( i=1; i&lt;=nv; i++) { for( j=1; j&lt;=nv; j++) { G[i][j] = -1; } early[i] = 0; late[i] = INFINITY; in[i] = 0; out[i] = 0; } for( i=0; i&lt;ne; i++) { scanf(\"%d %d %d\",&amp;s,&amp;d,&amp;cost); G[s][d] = cost; //有向边 in[d] ++; out[s]++; }}int EarlyTime(){ int queue[nv]; int first =-1,rear = -1; int count=0; int i; int temp,ret=0; for( i=1; i&lt;=nv; i++) { if( in[i]==0) { //如果入度为0则入队 queue[++rear] = i; } } while( first&lt;rear) //判断队是否为空 { temp = queue[++first]; //出队 count++; for( i=1; i&lt;=nv; i++) { if( G[temp][i]&gt;=0 ) { in[i]--; early[i] = FindMax( early[i],early[temp]+G[temp][i]); if( in[i]==0) { queue[++rear] = i; } } } } if( count!=nv) { ret = -1; } else { ret = early[1]; for( i=2; i&lt;=nv; i++) { if(early[i] &gt; ret) { //找出最大的early[i] ret = early[i]; } } } return ret;}void LateTime(int Scost){ int i; int queue[MAXVER]; int first=-1,rear=-1; int temp; for( i=1; i&lt;=nv; i++) { if( out[i]==0) { queue[++rear] = i; late[i] = Scost; } } while( first&lt;rear ) { temp = queue[++first]; for( i=nv; i&gt;=1; i--) { if( G[i][temp]&gt;=0) { late[i] = FindMin( late[i],late[temp]-G[i][temp]); out[i]--; if(out[i]==0) { queue[++rear] = i; } } } }}int FindMax( int a,int b){ if( a&gt;b ) { return a; } else { return b; }}int FindMin( int a,int b){ if( a&gt;b ) { return b; } else { return a; }}","link":"/2018/05/06/shujiujiegou7-11/"},{"title":"7-14 电话聊天狂人 (25 分)","text":"7-14 电话聊天狂人 (25 分)给定大量手机用户通话记录，找出其中通话次数最多的聊天狂人。 输入格式:输入首先给出正整数$N$（≤105），为通话记录条数。随后$N$行，每行给出一条通话记录。简单起见，这里只列出拨出方和接收方的11位数字构成的手机号码，其中以空格分隔。 输出格式:在一行中给出聊天狂人的手机号码及其通话次数，其间以空格分隔。如果这样的人不唯一，则输出狂人中最小的号码及其通话次数，并且附加给出并列狂人的人数。 输入样例:12345413005711862 1358862583213505711862 1308862583213588625832 1808792583215005713862 13588625832 输出样例:113588625832 3 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;math.h&gt; #define KEYLENGTH 12 //关键词字符串最大长度 #define MAXTABLESIZE 1000000 //允许开辟的最大散列表长度 #define MAXD 5 //参与散列映射计算的字符个数 typedef char ElementType[KEYLENGTH ]; typedef int Index; //散列地址类型 //单链表定义 typedef struct LNode *PtrToLNode; struct LNode { ElementType Data; PtrToLNode Next; int Count; }; typedef PtrToLNode Position; typedef PtrToLNode List; //散列表结点定义 typedef struct TblNode *HashTable; //散列表类型 struct TblNode { int TableSize; //表的最大长度 List Heads; //指向链表头结点的数组 }; int NextPrime( int N ) { //返回大于N且不超过MAXTABLESIZE的最小素数 int i, p = ( N % 2 ) ? N + 2 : N + 1; //从大于N的下一个奇数开始 while ( p &lt;= MAXTABLESIZE ) { double q = p; for ( i = (int)sqrt(q); i &gt; 2; i-- ) if ( !(p % i) ) break; //p不是素数 if ( i == 2 ) break; // for正常结束，说明p是素数 else p += 2; //否则试探下一个奇数 } return p; } HashTable CreateTable ( int TableSize ) { HashTable H; int i; H = (HashTable)malloc(sizeof(struct TblNode)); H-&gt;TableSize = NextPrime(TableSize); //保证散列表最大长度是素数 //以下分配链表头结点数组 H-&gt;Heads = (List)malloc(H-&gt;TableSize * sizeof(struct LNode)); //分配表头结点数组空间 for ( i = 0; i &lt; H-&gt;TableSize; i++ ) { //初始化表头结点 H-&gt;Heads[i].Data[0] = '\\0'; H-&gt;Heads[i].Next = NULL; //链表为NULL H-&gt;Heads[i].Count = 0; //对应号码的个数为0 } return H; //最后将表头结点数组的首地址返回 } //hash函数 Index Hash ( const char *Key, int TableSize ) { unsigned int h = 0; //散列函数值，初始化为0 while ( *Key != '\\0' ) //位移映射 h = ( h &lt;&lt; 5 ) + *Key++; //左移五位 return h % TableSize; } Position Find ( HashTable H, ElementType Key ) { Position P; Index Pos; Pos = Hash( Key + KEYLENGTH - MAXD, H-&gt;TableSize ); //初始散列位置（利用hash函数快速定位） P = H-&gt;Heads[Pos].Next; //从该链表的第1个结点开始 while ( P &amp;&amp; strcmp( P-&gt;Data, Key ) ) //寻找是否有Key，退出的条件：P为NULL， 或者是找到了 P = P-&gt;Next; return P; //此时P或者指向找到的结点，或者为NULL } int Insert ( HashTable H, ElementType Key ) { Position P, NewCell; Index Pos; P = Find( H, Key ); //先定位：找到or找不到 if ( !P ) { //关键词未找到，可以插入（声明临时节点存储待插入的数据，然后利用hash函数找到对应的位置，之后是链表的头插法） NewCell = (Position)malloc(sizeof(struct LNode)); strcpy(NewCell-&gt;Data, Key); NewCell-&gt;Count = 1; //个数+1 Pos = Hash( Key + KEYLENGTH - MAXD, H-&gt;TableSize ); //初始散列位置 //将NewCell插入为H-&gt;Heads[Pos]链表的第一个结点（头插法） NewCell-&gt;Next = H-&gt;Heads[Pos].Next; H-&gt;Heads[Pos].Next = NewCell; return 1; } else { //关键词已存在 P-&gt;Count++; return 0; } } void DestroyTable( HashTable H ) { //释放空间 int i; Position P, Tmp; //释放每个链表的结点 for( i = 0; i &lt; H-&gt;TableSize; i++ ) { P = H-&gt;Heads[i].Next; while ( P ) { //依次释放链表每一个元素的空间 Tmp = P-&gt;Next; free( P ); P = Tmp; } } free( H-&gt;Heads ); //释放头结点数组 free( H ); //释放散列表头结点 } void ScanAndOutput ( HashTable H ) { int i, MaxCnt = 0, PCnt = 0; ElementType MinPhone; List Ptr; MinPhone[0] = '\\0'; for ( i = 0; i &lt; H-&gt;TableSize; i++ ) { //扫描链表 Ptr = H-&gt;Heads[i].Next; //从该链表的第1个结点开始 while ( Ptr ) { //要找最大的通话次数 if ( Ptr-&gt;Count &gt; MaxCnt ) { //更新最大通话次数 MaxCnt = Ptr-&gt;Count; strcpy( MinPhone, Ptr-&gt;Data ); PCnt = 1; } else if ( Ptr-&gt;Count == MaxCnt ) { PCnt++; //狂人计数 if ( strcmp( MinPhone, Ptr-&gt;Data ) &gt; 0 ) strcpy( MinPhone, Ptr-&gt;Data ); //更新狂人的最小手机号码 } Ptr = Ptr-&gt;Next; } } printf(\"%s %d\", MinPhone, MaxCnt); if ( PCnt &gt; 1 ) printf(\" %d\", PCnt); printf(\"\\n\"); } int main () { int N, i; ElementType Key; HashTable H; scanf(\"%d\", &amp;N); H = CreateTable( N * 2 ); //创建一个散列表 for ( i = 0; i &lt; N; i++ ) { scanf(\"%s\", Key); Insert( H, Key ); scanf(\"%s\", Key); Insert( H, Key ); } ScanAndOutput( H ); DestroyTable( H ); return 0; }","link":"/2018/05/06/shujiujiegou7-14/"},{"title":"7-15 QQ帐户的申请与登陆 (25 分)","text":"7-15 QQ帐户的申请与登陆 (25 分)实现QQ新帐户申请和老帐户登陆的简化版功能。最大挑战是：据说现在的QQ号码已经有10位数了。 输入格式:输入首先给出一个正整数$N$（≤105），随后给出$N$行指令。每行指令的格式为：“命令符（空格）QQ号码（空格）密码”。其中命令符为“N”（代表New）时表示要新申请一个QQ号，后面是新帐户的号码和密码；命令符为“L”（代表Login）时表示是老帐户登陆，后面是登陆信息。QQ号码为一个不超过10位、但大于1000（据说QQ老总的号码是1001）的整数。密码为不小于6位、不超过16位、且不包含空格的字符串。 输出格式:针对每条指令，给出相应的信息： 1）若新申请帐户成功，则输出“New: OK”；2）若新申请的号码已经存在，则输出“ERROR: Exist”；3）若老帐户登陆成功，则输出“Login: OK”；4）若老帐户QQ号码不存在，则输出“ERROR: Not Exist”；5）若老帐户密码错误，则输出“ERROR: Wrong PW”。 输入样例:1234565L 1234567890 myQQ@qq.comN 1234567890 myQQ@qq.comN 1234567890 myQQ@qq.comL 1234567890 myQQ@qqL 1234567890 myQQ@qq.com 输出样例:12345ERROR: Not ExistNew: OKERROR: ExistERROR: Wrong PWLogin: OK 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;char s[200000][12];int cmp(const void *a,const void *b){ return strcmp((char*)a,(char*)b)&gt;0?1:-1;}int main(){ int n; int c = 1,d = 1; int maxi = 0; char ans[12] = \"00000000000\"; scanf(\"%d\",&amp;n); for(int i = 0;i &lt; n;i ++) { scanf(\"%s%s\",s[i*2],s[i*2+1]); } qsort(s,2*n,sizeof(s[0]),cmp);// for(int i = 0;i &lt; n * 2 + 1;i ++)// printf(\"%s\\n\",s[i]); for(int i = 1;i &lt; n * 2 + 1;i ++) { if(strcmp(s[i],s[i - 1]) == 0)d ++; else { if(d&gt;maxi) { strcpy(ans,s[i - 1]); maxi = d; c = 1; } else if(d == maxi) { c ++; } d = 1; } } printf(\"%s %d\",ans,maxi); if(c&gt;1)printf(\" %d\",c);}","link":"/2018/05/06/shujiujiegou7-15/"},{"title":"7-18 银行业务队列简单模拟 (25 分)","text":"7-18 银行业务队列简单模拟 (25 分)设某银行有A、B两个业务窗口，且处理业务的速度不一样，其中A窗口处理速度是B窗口的2倍 —— 即当A窗口每处理完2个顾客时，B窗口处理完1个顾客。给定到达银行的顾客序列，请按业务完成的顺序输出顾客序列。假定不考虑顾客先后到达的时间间隔，并且当不同窗口同时处理完2个顾客时，A窗口顾客优先输出。 输入格式:输入为一行正整数，其中第1个数字N(≤1000)为顾客总数，后面跟着N位顾客的编号。编号为奇数的顾客需要到A窗口办理业务，为偶数的顾客则去B窗口。数字间以空格分隔。 输出格式:按业务处理完成的顺序输出顾客的编号。数字间以空格分隔，但最后一个编号后不能有多余的空格。 输入样例:18 2 1 3 9 4 11 13 15 输出样例:11 3 2 9 11 4 13 15 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;stdio.h&gt;#define MAX 1004void print( int i);int main(){ int a[MAX]; int b[MAX]; int ahead=0,atail=0; int bhead=0,btail=0; int n; int temp; int i; scanf(\"%d\",&amp;n); for( i=0; i&lt;n; i++) { scanf(\"%d\",&amp;temp); if( temp%2) { a[atail++] = temp; } else { b[btail++] = temp; } } while( ahead&lt;atail || bhead&lt;btail ){ if( ahead&lt;atail ) print(a[ahead++]); if( ahead&lt;atail ) print(a[ahead++]); if( bhead&lt;btail ) print(b[bhead++]); } return 0;}void print( int i){ static int flag = 0; if( flag ) { printf(\" \"); } flag++; printf(\"%d\",i);}","link":"/2018/05/06/shujiujiegou7-18/"},{"title":"7-19 求链式线性表的倒数第K项 (20 分)","text":"7-19 求链式线性表的倒数第K项 (20 分)给定一系列正整数，请设计一个尽可能高效的算法，查找倒数第K个位置上的数字。 输入格式:输入首先给出一个正整数K，随后是若干正整数，最后以一个负整数表示结尾（该负数不算在序列内，不要处理）。 输出格式:输出倒数第K个位置上的数据。如果这个位置不存在，输出错误信息NULL。 输入样例:14 1 2 3 4 5 6 7 8 9 0 -1 输出样例:17 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;typedef struct LNode{ int data; struct LNode *next;}LNode,*LinkList;int main(){ int temp; int k,cnt=0; LinkList L; L = (LinkList)malloc( sizeof ( struct LNode)); LNode *s=L,*r=L,*p; scanf(\"%d\",&amp;k); int f=k; //保护k的值 while(1){ scanf(\"%d\",&amp;temp); if( temp&lt;0 ){ break; } else{ p=(LNode *)malloc(sizeof(LNode)); p-&gt;data = temp; r-&gt;next = p; r = p; k--; cnt++; if( k&lt;1){ s= s-&gt;next; } } } if( f&gt;cnt){ printf(\"NULL\"); } else printf(\"%d\",s-&gt;data); return 0;}","link":"/2018/05/06/shujiujiegou7-19/"},{"title":"7-17 汉诺塔的非递归实现 (25 分)","text":"7-17 汉诺塔的非递归实现 (25 分)借助堆栈以非递归（循环）方式求解汉诺塔的问题（n, a, b, c），即将N个盘子从起始柱（标记为“a”）通过借助柱（标记为“b”）移动到目标柱（标记为“c”），并保证每个移动符合汉诺塔问题的要求。 输入格式:输入为一个正整数N，即起始柱上的盘数。 输出格式:每个操作（移动）占一行，按柱1 -&gt; 柱2的格式输出。 输入样例:13 输出样例:1234567a -&gt; ca -&gt; bc -&gt; ba -&gt; cb -&gt; ab -&gt; ca -&gt; c 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main(){ int i; int n; int topa = -1; int topb = -1; int topc = -1; int temp; int to = 1; //用to表示当前最小值所在的柱子，1为a，2为b int count ; scanf(\"%d\",&amp;n); int a[n]; int b[n]; int c[n]; count = 0; //如果n是偶数，那运行完成后C柱上有n个元素，奇数的话B柱上有n个元素 for( i=n; i&gt;0; i--) { a[++topa] = i; //初始化低层数值大 } while( 1 ) { if( n%2==0) { //这里主要处理n为偶数第一步放在b上 if( to==1) { //当前最小值在a上,往前移一步 temp = a[topa--]; b[++topb] = temp; to = 2; printf(\"a -&gt; b\\n\"); if( a[topa]&lt;c[topc] || c[topc]==0) { //如果a的最小值&lt;c的最小值或者c为空,则将a的最小值移到c temp = a[topa--]; c[++topc] = temp; printf(\"a -&gt; c\\n\"); count++; if(count==n) { break; } } else { //否则将c的最小值移动到a temp = c[topc--]; a[++topa] = temp; printf(\"c -&gt; a\\n\"); count--; } } else if( to==2) { temp = b[topb--]; c[++topc] = temp; to = 3; printf(\"b -&gt; c\\n\"); count++; if(count==n) { break; } if( a[topa]&lt;b[topc] || b[topb]==0) { temp = a[topa--]; b[++topb] = temp; printf(\"a -&gt; b\\n\"); } else { temp = b[topb--]; a[++topa] = temp; printf(\"b -&gt; a\\n\"); } } else if( to==3) { temp = c[topc--]; a[++topa] = temp; to = 1; printf(\"c -&gt; a\\n\"); count--; if( b[topa]&lt;c[topc] || c[topc]==0) { temp = b[topb--]; c[++topc] = temp; printf(\"b -&gt; c\\n\"); count++; if(count==n) { break; } } else { temp = c[topc--]; b[++topb] = temp; printf(\"c -&gt; b\\n\"); count--; } } } else { //这里主要处理n为奇数第一步放在c上 if( to==1) { temp = a[topa--]; b[++topb] = temp; to = 2; printf(\"a -&gt; c\\n\"); count++; if(count==n) { break; } if( a[topa]&lt;c[topc] || c[topc]==0) { temp = a[topa--]; c[++topc] = temp; printf(\"a -&gt; b\\n\"); } else { temp = c[topc--]; a[++topa] = temp; printf(\"b -&gt; a\\n\"); } } else if( to==2) { temp = b[topb--]; c[++topc] = temp; to = 3; printf(\"c -&gt; b\\n\"); count--; if( a[topa]&lt;b[topc] || b[topb]==0) { temp = a[topa--]; b[++topb] = temp; printf(\"a -&gt; c\\n\"); count++; if(count==n) { break; } } else { temp = b[topb--]; a[++topa] = temp; printf(\"c -&gt; a\\n\"); count--; } } else if( to==3) { temp = c[topc--]; a[++topa] = temp; to = 1; printf(\"b -&gt; a\\n\"); if( b[topa]&lt;c[topc] || c[topc]==0) { temp = b[topb--]; c[++topc] = temp; printf(\"c -&gt; b\\n\"); count--; } else { temp = c[topc--]; b[++topb] = temp; printf(\"b -&gt; c\\n\"); count++; if(count==n) { break; } } } } } return 0;}","link":"/2018/05/06/shujiujiegou7-17/"},{"title":"7-16 一元多项式求导 (20 分)","text":"7-16 一元多项式求导 (20 分)设计函数求一元多项式的导数。 输入格式:以指数递降方式输入多项式非零项系数和指数（绝对值均为不超过1000的整数）。数字间以空格分隔。 输出格式:以与输入相同的格式输出导数多项式非零项的系数和指数。数字间以空格分隔，但结尾不能有多余空格。 输入样例:13 4 -5 2 6 1 -2 0 输出样例:112 3 -10 1 6 0 12345678910111213141516171819202122#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main(){ int xi,zi; //系数，指数 int flag=0; while(scanf(\"%d %d\",&amp;xi,&amp;zi)!=EOF){ if( zi ){ if( flag ) printf(\" \"); //如果不是第一个数就先输出一个空格 else flag =1; printf(\"%d %d\",xi*zi,zi-1); } else break; } if( flag==0 ){ printf(\"0 0\"); } return 0;}","link":"/2018/05/06/shujiujiegou7-16/"},{"title":"7-20 表达式转换 (25 分)","text":"7-20 表达式转换 (25 分)算术表达式有前缀表示法、中缀表示法和后缀表示法等形式。日常使用的算术表达式是采用中缀表示法，即二元运算符位于两个运算数中间。请设计程序将中缀表达式转换为后缀表达式。 输入格式:输入在一行中给出不含空格的中缀表达式，可包含+、-、*、\\以及左右括号()，表达式不超过20个字符。 输出格式:在一行中输出转换后的后缀表达式，要求不同对象（运算数、运算符号）之间以空格分隔，但结尾不得有多余空格。 输入样例:12+3*(7-4)+8/4 输出样例:12 3 7 4 - * + 8 4 / + 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;int IsNum( char c);int IsZhengfu( char c);int Compare( char a, char b);int main(){ char str1[21]; char str2[21]; int len; int flag =0; //表示str2是否为空 int i,j; int space =0; scanf(\"%s\",str1); len = strlen(str1); for( i=0; i&lt;len; i++) { if(IsNum(str1[i])) { //str1[i]是数字则输出 if( space ) { printf(\" \"); space = 0; } printf(\"%c\",str1[i]); } else if( IsZhengfu(str1[i]) &amp;&amp; (i? !IsNum(str1[i-1]) &amp;&amp; str1[i-1]!=')':1)) { //若第一个符号是负号或者出现连续两个符号 if( str1[i]=='-') { if(space) { printf(\" \"); space = 0; } printf(\"%c\",str1[i]); } } else { //其他符号 if( flag) { if( str1[i]==')') { //str2出栈直至遇到（ while( flag--) { if(str2[flag]=='(') break; printf(\" %c\",str2[flag]); } } else { while( flag ) { //str2内不为空，比较栈顶与str1[i]的优先级 if( Compare( str2[flag-1],str1[i])) { //若str1优先级低，出栈 printf(\" %c\",str2[--flag]); } else break; } str2[flag++] = str1[i]; } } else str2[flag++] = str1[i]; for ( j=0; j&lt;flag; j++) { if( str2[j]!='(') { //遇见‘（’不输出空格 space = 1; break; } } } } while (flag) { printf(\" %c\",str2[--flag]); } return 0;}int IsNum( char c){ //c是数字，注意题目数据会有小数 return ( c &gt;='0'&amp;&amp;c&lt;='9')||c=='.';}int IsZhengfu( char c){ return c=='+' || c=='-';}int Compare( char a, char b){ //比较两个符号优先级 //连续的两个case语句表示这两个case是同一种情况 if( b==')') return 1; if( b=='(' || a=='(') return 0; switch(b) { case '+': case '-': return 1; case '*': case '/': switch(a) { case '+': case '-': return 0; case '*': case '/': return 1; } }}","link":"/2018/05/06/shujiujiegou7-20/"},{"title":"7-23 还原二叉树 (25 分)","text":"7-23 还原二叉树 (25 分)给定一棵二叉树的先序遍历序列和中序遍历序列，要求计算该二叉树的高度。 输入格式:输入首先给出正整数$N$（≤50），为树中结点总数。下面两行先后给出先序和中序遍历序列，均是长度为$N$的不包含重复英文字母（区别大小写）的字符串。 输出格式:输出为一个整数，即该二叉树的高度。 输入样例:1239ABDFGHIECFDHGIBEAC 输出样例:15 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;typedef struct TNode{ char data; struct TNode *lchild,*rchild;} TNode,*Tree;Tree CreatTree( char xian[],char zhong[],int n);int High( Tree t);char xian[55]; //先序序列char zhong[55]; //中序序列int n;int main(){ scanf(\"%d\",&amp;n); scanf(\"%s\",xian); scanf(\"%s\",zhong); Tree tree = CreatTree( xian,zhong,n); printf(\"%d\",High(tree)); return 0;}Tree CreatTree( char xian[],char zhong[],int n){ if( n==0 ) return NULL; int index = 0; Tree temp = (Tree) malloc(sizeof(struct TNode)); while( index &lt; n) { if( zhong[index]==xian[0]) break; index ++; } temp-&gt;data = xian[0]; temp-&gt;lchild = CreatTree(xian+1,zhong,index); temp-&gt;rchild = CreatTree(xian+1+index,zhong+index+1,n-index-1); return temp;}int High( Tree t){ if( !t ) return 0; int lh = High(t-&gt;lchild); int rh = High(t-&gt;rchild); if( lh&gt;rh ) return ++lh; else return ++rh;}","link":"/2018/05/06/shujiujiegou7-23/"},{"title":"7-22 堆栈模拟队列 (25 分)","text":"7-22 堆栈模拟队列 (25 分)设已知有两个堆栈S1和S2，请用这两个堆栈模拟出一个队列Q。 所谓用堆栈模拟队列，实际上就是通过调用堆栈的下列操作函数: int IsFull(Stack S)：判断堆栈S是否已满，返回1或0； int IsEmpty (Stack S )：判断堆栈S是否为空，返回1或0； void Push(Stack S, ElementType item )：将元素item压入堆栈S； ElementType Pop(Stack S )：删除并返回S的栈顶元素。 实现队列的操作，即入队void AddQ(ElementType item)和出队ElementType DeleteQ()。 输入格式:输入首先给出两个正整数N1和N2，表示堆栈S1和S2的最大容量。随后给出一系列的队列操作：A item表示将item入列（这里假设item为整型数字）；D表示出队操作；T表示输入结束。 输出格式:对输入中的每个D操作，输出相应出队的数字，或者错误信息ERROR:Empty。如果入队操作无法执行，也需要输出ERROR:Full。每个输出占1行。 输入样例:123 2A 1 A 2 A 3 A 4 A 5 D A 6 D A 7 D A 8 D D D D T 输出样例:123456789ERROR:Full1ERROR:Full23478ERROR:Empty 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;stdlib.h&gt;int main(){ int stack1[1000],stack2[1000]; int top1=-1,top2=-1; char c; int temp; int n1,n2; scanf(\"%d %d\",&amp;n1,&amp;n2); if( n1&gt;n2 ) { //容量小的作为第一个输入栈 temp = n1; n1 = n2; n2 = temp; } while(1) { scanf(\"%c\",&amp;c); if( c=='T') break; else if( c=='A') { scanf(\"%d\",&amp;temp); if( top1==n1-1 &amp;&amp; top2!=-1) { //栈1满，栈2不为空 printf(\"ERROR:Full\\n\"); } else if( top1==n1-1) { //栈1满，栈2为空 while( top1&gt;-1 ) { //栈1出栈到栈2 stack2[++top2] = stack1[top1--]; } stack1[++top1] = temp; } else stack1[++top1] = temp; } else if( c=='D') { if( top2!=-1) printf(\"%d\\n\",stack2[top2--]); else if( top2==-1 &amp;&amp; top1!=-1) { while(top1&gt;-1) { stack2[++top2] = stack1[top1--]; } printf(\"%d\\n\",stack2[top2--]); } else printf(\"ERROR:Empty\"); } } return 0;}","link":"/2018/05/06/shujiujiegou7-22/"},{"title":"7-21 求前缀表达式的值 (25 分)","text":"7-21 求前缀表达式的值 (25 分)算术表达式有前缀表示法、中缀表示法和后缀表示法等形式。前缀表达式指二元运算符位于两个运算数之前，例如2+3*(7-4)+8/4的前缀表达式是：+ + 2 * 3 - 7 4 / 8 4。请设计程序计算前缀表达式的结果值。 输入格式:输入在一行内给出不超过30个字符的前缀表达式，只包含+、-、*、/以及运算数，不同对象（运算数、运算符号）之间以空格分隔。 输出格式:输出前缀表达式的运算结果，保留小数点后1位，或错误信息ERROR。 输入样例:1+ + 2 * 3 - 7 4 / 8 4 输出样例:113.0 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;double exp();int main(){ printf(\"%.1f\",exp()); return 0;}double exp(){ char a[10]; //存储第一个非空格字符 scanf(\"%s\",a); if( !a[1]) { //a[1]为空只有一位 switch( a[0]) { case '+' : return exp()+exp(); case '-' : return exp()-exp(); case '*' : return exp()*exp(); case '/' : { double fenzi = exp(); double fenmu = exp(); if(fenmu !=0) return fenzi/fenmu; else { printf(\"ERROR\"); //分母为0 exit(0); //程序结束 } } default : return atof(a); //字符串转换为浮点数 } } else { if( a[0]=='-' || a[0]=='+') { char flag = a[0]; //记录符号 int i =0 ; while(a[i]) { a[i] = a[i+1]; i++; } if(flag=='-') return 0-atof(a); else return atof(a); } else return atof(a); }}","link":"/2018/05/06/shujiujiegou7-21/"},{"title":"7-24 树种统计 (25 分)","text":"7-24 树种统计 (25 分)随着卫星成像技术的应用，自然资源研究机构可以识别每一棵树的种类。请编写程序帮助研究人员统计每种树的数量，计算每种树占总数的百分比。 输入格式:输入首先给出正整数N（≤105），随后N行，每行给出卫星观测到的一棵树的种类名称。种类名称由不超过30个英文字母和空格组成（大小写不区分）。 输出格式:按字典序递增输出各种树的种类名称及其所占总数的百分比，其间以空格分隔，保留小数点后4位。 输入样例:12345678910111213141516171819202122232425262728293029Red AlderAshAspenBasswoodAshBeechYellow BirchAshCherryCottonwoodAshCypressRed ElmGumHackberryWhite OakHickoryPecanHard MapleWhite OakSoft MapleRed OakRed OakWhite OakPoplanSassafrasSycamoreBlack WalnutWillow 输出样例:1234567891011121314151617181920212223Ash 13.7931%Aspen 3.4483%Basswood 3.4483%Beech 3.4483%Black Walnut 3.4483%Cherry 3.4483%Cottonwood 3.4483%Cypress 3.4483%Gum 3.4483%Hackberry 3.4483%Hard Maple 3.4483%Hickory 3.4483%Pecan 3.4483%Poplan 3.4483%Red Alder 3.4483%Red Elm 3.4483%Red Oak 6.8966%Sassafras 3.4483%Soft Maple 3.4483%Sycamore 3.4483%White Oak 10.3448%Willow 3.4483%Yellow Birch 3.4483% 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;typedef struct TNode *Position;typedef Position BinTree;struct TNode{ char data[35]; BinTree left; BinTree right; int count;};BinTree Insert( BinTree BT , char name[]);void Print( BinTree BT , int n);int main(){ int n; int i; BinTree BT = NULL; scanf(\"%d\",&amp;n); getchar(); for( i=0; i&lt;n; i++){ char name[35]; gets(name); BT = Insert( BT,name); } Print( BT ,n); return 0;}BinTree Insert( BinTree BT , char name[]){ if( !BT ){ BT = ( BinTree )malloc(sizeof(struct TNode)); strcpy(BT-&gt;data,name); BT-&gt;count=1; BT-&gt;left = BT-&gt;right =NULL; } else{ int a = strcmp( BT-&gt;data,name); if( a&lt;0 ) BT-&gt;right = Insert( BT-&gt;right,name); else if( a&gt;0 ) BT-&gt;left=Insert( BT-&gt;left,name); else BT-&gt;count++; } return BT;}void Print( BinTree BT , int n){ if( !BT ) return; else{ Print( BT-&gt;left,n); printf(\"%s \",BT-&gt;data); printf(\"%.4f%%\\n\",(double)BT-&gt;count/n*100.0); Print( BT-&gt;right,n); }}","link":"/2018/05/06/shujiujiegou7-24/"},{"title":"7-26 Windows消息队列 (25 分)","text":"7-26 Windows消息队列 (25 分)消息队列是Windows系统的基础。对于每个进程，系统维护一个消息队列。如果在进程中有特定事件发生，如点击鼠标、文字改变等，系统将把这个消息加到队列当中。同时，如果队列不是空的，这一进程循环地从队列中按照优先级获取消息。请注意优先级值低意味着优先级高。请编辑程序模拟消息队列，将消息加到队列中以及从队列中获取消息。 输入格式:输入首先给出正整数$N$（≤105），随后$N$行，每行给出一个指令——GET或PUT，分别表示从队列中取出消息或将消息添加到队列中。如果指令是PUT，后面就有一个消息名称、以及一个正整数表示消息的优先级，此数越小表示优先级越高。消息名称是长度不超过10个字符且不含空格的字符串；题目保证队列中消息的优先级无重复，且输入至少有一个GET。 输出格式:对于每个GET指令，在一行中输出消息队列中优先级最高的消息的名称和参数。如果消息队列中没有消息，输出EMPTY QUEUE!。对于PUT指令则没有输出。 输入样例:123456789109PUT msg1 5PUT msg2 4GETPUT msg3 2PUT msg4 4GETGETGETGET 输出样例:12345msg2msg3msg4msg1EMPTY QUEUE! 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;typedef struct Node *node;struct Node{ char mes[11]; int priority;};struct{ node heap[100005]; int num;} Heap;void Put();void Get();int main(){ int n; scanf(\"%d\",&amp;n); Heap.heap[0] = (node)malloc( sizeof(struct Node)); Heap.heap[0]-&gt;priority = -1; Heap.num = 0; while( n--) { char op[4]; getchar(); scanf(\"%s\",op); switch( op[0]) { case 'P' : Put(); break; case 'G' : Get(); break; default : break; } } return 0;}void Put(){ //读入数据，建立一个小顶堆 int i; node temp = ( node ) malloc( sizeof( struct Node)); scanf(\"%s %d\",temp-&gt;mes,&amp;temp-&gt;priority); for( i=++Heap.num; Heap.heap[i/2]-&gt;priority &gt; temp-&gt;priority; i=i/2) { Heap.heap[i] = Heap.heap[i/2]; } Heap.heap[i] = temp;}void Get(){ //输出数据，重建顶堆 int i; if( Heap.num&lt;1) { printf(\"EMPTY QUEUE!\\n\"); return ; } printf(\"%s\\n\",Heap.heap[1]-&gt;mes); for( i=1; i*2&lt;Heap.num; ) { if( i*2+1&lt;Heap.num &amp;&amp; Heap.heap[i*2+1]-&gt;priority&lt;Heap.heap[i*2]-&gt;priority) { //如果有两个根节点，并且右结点优先数小于左结点优先数 if( Heap.heap[i*2+1]-&gt;priority&lt;Heap.heap[Heap.num]-&gt;priority) { Heap.heap[i] = Heap.heap[i*2+1]; i=i*2+1; } else break; } else { if(Heap.heap[i*2]-&gt;priority &lt; Heap.heap[Heap.num]-&gt;priority) { Heap.heap[i] = Heap.heap[i*2]; i *= 2; } else break; } } Heap.heap[i] = Heap.heap[Heap.num--]; //将最后的一个元素补在空缺}","link":"/2018/05/06/shujiujiegou7-26/"},{"title":"7-27 家谱处理 (30 分)","text":"7-27 家谱处理 (30 分)人类学研究对于家族很感兴趣，于是研究人员搜集了一些家族的家谱进行研究。实验中，使用计算机处理家谱。为了实现这个目的，研究人员将家谱转换为文本文件。下面为家谱文本文件的实例： 123456John Robert Frank Andrew Nancy David 家谱文本文件中，每一行包含一个人的名字。第一行中的名字是这个家族最早的祖先。家谱仅包含最早祖先的后代，而他们的丈夫或妻子不出现在家谱中。每个人的子女比父母多缩进2个空格。以上述家谱文本文件为例，John这个家族最早的祖先，他有两个子女Robert和Nancy，Robert有两个子女Frank和Andrew，Nancy只有一个子女David。 在实验中，研究人员还收集了家庭文件，并提取了家谱中有关两个人关系的陈述语句。下面为家谱中关系的陈述语句实例： 123John is the parent of RobertRobert is a sibling of NancyDavid is a descendant of Robert 研究人员需要判断每个陈述语句是真还是假，请编写程序帮助研究人员判断。 输入格式:输入首先给出2个正整数N（2≤N≤100）和M（≤100），其中N为家谱中名字的数量，M为家谱中陈述语句的数量，输入的每行不超过70个字符。 名字的字符串由不超过10个英文字母组成。在家谱中的第一行给出的名字前没有缩进空格。家谱中的其他名字至少缩进2个空格，即他们是家谱中最早祖先（第一行给出的名字）的后代，且如果家谱中一个名字前缩进k个空格，则下一行中名字至多缩进k+2个空格。 在一个家谱中同样的名字不会出现两次，且家谱中没有出现的名字不会出现在陈述语句中。每句陈述语句格式如下，其中X和Y为家谱中的不同名字： 12345X is a child of YX is the parent of YX is a sibling of YX is a descendant of YX is an ancestor of Y 输出格式:对于测试用例中的每句陈述语句，在一行中输出True，如果陈述为真，或False，如果陈述为假。 输入样例:1234567891011126 5John Robert Frank Andrew Nancy DavidRobert is a child of JohnRobert is an ancestor of AndrewRobert is a sibling of NancyNancy is the parent of FrankJohn is a descendant of Andrew 输出样例:12345TrueTrueTrueFalseFalse 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;struct Node{ char name[15]; char father[15]; int num; //空格数} people[102];int main(){ int n,m; char temp[75]; int i,j,k; scanf(\"%d %d\",&amp;n,&amp;m); getchar(); for( i=0; i&lt;n; i++) { people[i].num = 0; //空格数初始化为0 gets(temp); int L = strlen(temp); for( j=0; j&lt;L; j++) { if( temp[j]==' ') people[i].num++; else { strcpy( people[i].name, temp+j); //复制空格以后的字符 break; } } if( !people[i].num ) strcpy( people[i].father,\"root\"); //如果空格数为0则表示根 else { for( k=i-1; k&gt;=0; k--) { if( people[i].num&gt; people[k].num) { //从后往前寻找父节点 strcpy( people[i].father,people[k].name); break; } } } } char a[15],b[15],c[15],d[15]; char temp1[15],temp2[15]; for( i=0; i&lt;m; i++) { scanf(\"%s %s %s %s %s %s\",a,d,d,b,d,c); if( b[0] == 'c') { //X is a child of Y for( k=0; k&lt;n; k++) { if( !strcmp( people[k].name,a)) { if( !strcmp( people[k].father,c)) printf(\"True\\n\"); else printf(\"False\\n\"); break; } } } else if( b[0] == 'p') { //X is the parent of Y for( k=0; k&lt;n; k++) { if( !strcmp( people[k].name,c)) { if( !strcmp( people[k].father,a)) printf(\"True\\n\"); else printf(\"False\\n\"); break; } } } else if( b[0] == 's') { // X is a sibling of Y for( k=0; k&lt;n; k++) { //寻找两个结点的父节点 if( !strcmp( people[k].name,a)) strcpy(temp1,people[k].father); if( !strcmp( people[k].name,c)) strcpy(temp2,people[k].father); } if( !strcmp(temp1,temp2)) printf(\"True\\n\"); else printf(\"False\\n\"); } else if( b[0] == 'd') { //X is a descendant of Y for( k=0; k&lt;n; k++) { if( !strcmp( people[k].name,a)) strcpy(temp1,people[k].father); } while( strcmp(temp1,c) &amp;&amp; strcmp( temp1,\"root\")) { for( k=0; k&lt;n; k++) if( !strcmp(people[k].name,temp1)) strcpy( temp1,people[k].father); } if( !strcmp(temp1,\"root\")) printf(\"False\\n\"); else printf(\"True\\n\"); } else if( b[0] == 'a') { //X is an ancestor of Y for( k=0; k&lt;n; k++) { if( !strcmp( people[k].name,c)) strcpy(temp1,people[k].father); } while( strcmp(temp1,a) &amp;&amp; strcmp( temp1,\"root\")) { for( k=0; k&lt;n; k++) if( !strcmp(people[k].name,temp1)) strcpy( temp1,people[k].father); } if( !strcmp(temp1,\"root\")) printf(\"False\\n\"); else printf(\"True\\n\"); } } getchar(); return 0;}","link":"/2018/05/06/shujiujiegou7-27/"},{"title":"7-30 目录树 (30 分)","text":"7-30 目录树 (30 分)在ZIP归档文件中，保留着所有压缩文件和目录的相对路径和名称。当使用WinZIP等GUI软件打开ZIP归档文件时，可以从这些信息中重建目录的树状结构。请编写程序实现目录的树状结构的重建工作。 输入格式:输入首先给出正整数N（≤104），表示ZIP归档文件中的文件和目录的数量。随后N行，每行有如下格式的文件或目录的相对路径和名称（每行不超过260个字符）： 路径和名称中的字符仅包括英文字母（区分大小写）； 符号“\\”仅作为路径分隔符出现； 目录以符号“\\”结束； 不存在重复的输入项目； 整个输入大小不超过2MB。 输出格式:假设所有的路径都相对于root目录。从root目录开始，在输出时每个目录首先输出自己的名字，然后以字典序输出所有子目录，然后以字典序输出所有文件。注意，在输出时，应根据目录的相对关系使用空格进行缩进，每级目录或文件比上一级多缩进2个空格。 输入样例:123456787bc\\ab\\cda\\bcab\\da\\d\\aa\\d\\z\\ 输出样例:1234567891011root a d z a bc ab cd d c b 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include&lt;bits/stdc++.h&gt;#include&lt;cmath&gt; #define mem(a,b) memset(a,b,sizeof a);#define INF 0x3f3f3f3f using namespace std; typedef long long ll; const int maxn=500; struct node{ string name; int pri; vector&lt;node&gt; vec; node(){} node(string name,int pri):name(name),pri(pri){}}rt; int cmp(node n1,node n2){ if(n1.pri==n2.pri) return n1.name&lt;n2.name; return n1.pri&gt;n2.pri;} string a[maxn];int pris[maxn]; void add(node &amp;nd,int pos,int cnt){ if(cnt==pos) return; int i; for(i=0;i&lt;nd.vec.size();i++) { if(a[pos]==nd.vec[i].name) { add(nd.vec[i],pos+1,cnt); return ; } } node tnd(a[pos],pris[pos]); nd.vec.push_back(tnd); add(nd.vec[i],pos+1,cnt);} void dfs(node nd,int cnt){ for(int i=0;i&lt;cnt;i++) printf(\" \"); printf(\"%s\\n\",nd.name.c_str()); sort(nd.vec.begin(),nd.vec.end(),cmp); for(int i=0;i&lt;nd.vec.size();i++) dfs(nd.vec[i],cnt+1);} int main(){ int n, cur; string s,ts; stringstream ss; while(~scanf(\"%d\",&amp;n)) { cin.get(); rt.name=\"root\"; rt.pri=1; // 是目录 rt.vec.clear(); for(int i=0;i&lt;n;i++) { getline(cin,s); int flag=s[s.length()-1]=='\\\\'?1:0; // 判断最后是否为目录 for(int j=0;j&lt;s.length();j++) if(!isalpha(s[j])) s[j]=' '; ss.clear(); ss.str(\"\"); ss&lt;&lt;s; cur=0; while(ss&gt;&gt;ts) { a[cur]=ts; pris[cur++]=1; // 标记为目录 } if(!flag) pris[cur-1]=0; add(rt,0,cur); } dfs(rt,0); } return 0;}","link":"/2018/05/06/shujiujiegou7-30/"},{"title":"7-25 朋友圈 (25 分)","text":"7-25 朋友圈 (25 分)某学校有$N$个学生，形成$M$个俱乐部。每个俱乐部里的学生有着一定相似的兴趣爱好，形成一个朋友圈。一个学生可以同时属于若干个不同的俱乐部。根据“我的朋友的朋友也是我的朋友”这个推论可以得出，如果A和B是朋友，且B和C是朋友，则A和C也是朋友。请编写程序计算最大朋友圈中有多少人。 输入格式:输入的第一行包含两个正整数$N$（≤30000）和$M$（≤1000），分别代表学校的学生总数和俱乐部的个数。后面的$M$行每行按以下格式给出1个俱乐部的信息，其中学生从1~$N$编号： 1第i个俱乐部的人数Mi（空格）学生1（空格）学生2 … 学生Mi 输出格式:输出给出一个整数，表示在最大朋友圈中有多少人。 输入样例:123457 43 1 2 32 1 43 5 6 71 6 输出样例:14 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;void Union( int x,int y);int Find( int x);int n,m;int bcj[30005];int main(){ int i; int n1; int x,y; int ans = 0; scanf(\"%d %d\",&amp;n,&amp;m); for( i=1; i&lt;=n; i++) bcj[i] = -1; //初始化并查集 while( m-- ) { scanf(\"%d\",&amp;n1); for( i=1; i&lt;=n1; i++) { if( i==1 ) { scanf(\"%d\",&amp;x); } else { scanf(\"%d\",&amp;y); Union(x,y); } } } for( i=1; i&lt;=n; i++) { if( bcj[i]&lt;ans ) ans = bcj[i]; //负数需寻找最小的值 } ans = 0-ans; //用负数表示集合中元素的个数 printf(\"%d\",ans); return 0;}//以下是并查集的两个基本操作int Find( int x){ if(bcj[x]&lt;0) return x; return bcj[x] = Find(bcj[x]);}void Union( int x, int y){ x = Find(x); y = Find(y); if( x==y ) return; bcj[x] += bcj[y]; bcj[y] = x;}","link":"/2018/05/06/shujiujiegou7-25/"},{"title":"7-28 搜索树判断 (25 分)","text":"7-28 搜索树判断 (25 分)对于二叉搜索树，我们规定任一结点的左子树仅包含严格小于该结点的键值，而其右子树包含大于或等于该结点的键值。如果我们交换每个节点的左子树和右子树，得到的树叫做镜像二叉搜索树。 现在我们给出一个整数键值序列，请编写程序判断该序列是否为某棵二叉搜索树或某镜像二叉搜索树的前序遍历序列，如果是，则输出对应二叉树的后序遍历序列。 输入格式:输入的第一行包含一个正整数$N$（≤1000），第二行包含$N$个整数，为给出的整数键值序列，数字间以空格分隔。 输出格式:输出的第一行首先给出判断结果，如果输入的序列是某棵二叉搜索树或某镜像二叉搜索树的前序遍历序列，则输出YES，否侧输出NO。如果判断结果是YES，下一行输出对应二叉树的后序遍历序列。数字间以空格分隔，但行尾不能有多余的空格。 输入样例1:1278 6 5 7 10 8 11 输出样例1:12YES5 7 6 8 11 10 8 输入样例2:1278 6 8 5 10 9 11 输出样例2:1NO 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;typedef struct TNode *tree;struct TNode{ int data; tree lchild; tree rchild;};int flag = 0; //控制最后一个输出后面没有空格int flag1 ; //如果不是二叉搜索树返回1int flag2 ; //如果不是二叉镜像搜索树返回1void Print( tree t);tree Find ( int pre[],int len);tree FindMirror( int pre[],int len);int main(){ int len; int pre[1005]; int i; tree t,tm; scanf(\"%d\",&amp;len); for( i=0; i&lt;len; i++) { scanf(\"%d\",&amp;pre[i]); } t = Find( pre,len); tm = FindMirror( pre,len ); if( t &amp;&amp; !flag1) { //树不为空并且是二叉搜索树 printf(\"YES\\n\"); Print( t ); printf(\"\\n\"); } else if( tm &amp;&amp; !flag2) { //树不为空并且是二叉镜像搜索树 printf(\"YES\\n\"); Print( tm ); printf(\"\\n\"); } else printf(\"NO\\n\"); return 0;}tree Find ( int pre[],int len){ int i,j; if( !len ) return NULL; tree temp = (tree) malloc( sizeof( struct TNode)); temp-&gt;data = *pre; for( i=1; i&lt;len; i++) { if( pre[i] &gt;= temp-&gt;data) //寻找右子树 break; } for( j=i; j&lt;len; j++) { if( pre[j] &lt; temp-&gt;data) { //右子树中有小于根结点的值，不是二叉搜索树 flag1 = 1; return NULL; } } temp-&gt;lchild = Find( pre+1, i-1); temp-&gt;rchild = Find( pre+i, len-i); return temp;}tree FindMirror( int pre[],int len){ //镜像树，左子树大于根大于右子树 int i,j; if( !len ) return NULL; tree temp = (tree) malloc( sizeof( struct TNode)); temp-&gt;data = *pre; for( i=1; i&lt;len; i++) { if( pre[i] &lt; temp-&gt;data) //寻找右子树 break; } for( j=i; j&lt;len; j++) { if( pre[j] &gt;= temp-&gt;data) { //右子树中有大于等于根结点的值，不是二叉搜索树 flag2 = 1; return NULL; } } temp-&gt;lchild = FindMirror( pre+1, i-1); temp-&gt;rchild = FindMirror( pre+i, len-i); return temp;}void Print( tree t){ if( t ) { //后序遍历 Print(t-&gt;lchild); Print(t-&gt;rchild); if( !flag ) flag = 1; else printf(\" \"); printf(\"%d\",t-&gt;data); }}","link":"/2018/05/06/shujiujiegou7-28/"},{"title":"7-2 一元多项式的乘法与加法运算 (20 分)","text":"7-2 一元多项式的乘法与加法运算 (20 分)设计函数分别求两个一元多项式的乘积与和。 输入格式:输入分2行，每行分别先给出多项式非零项的个数，再以指数递降方式输入一个多项式非零项系数和指数（绝对值均为不超过1000的整数）。数字间以空格分隔。 输出格式:输出分2行，分别以指数递降方式输出乘积多项式以及和多项式非零项的系数和指数。数字间以空格分隔，但结尾不能有多余空格。零多项式应输出0 0。 输入样例:124 3 4 -5 2 6 1 -2 03 5 20 -7 4 3 1 输出样例:1215 24 -25 22 30 21 -10 20 -21 8 35 6 -33 5 14 4 -15 3 18 2 -6 15 20 -4 4 -5 2 9 1 -2 0 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define N 10000/*输入分2行，每行分别先给出多项式非零项的个数，再以指数递降方式输入一个多项式非零项系数和指数（绝对值均为不超过1000的整数）。数字间以空格分隔。输出分2行，分别以指数递降方式输出乘积多项式以及和多项式非零项的系数和指数。数字间以空格分隔，但结尾不能有多余空格。零多项式应输出0 0。*/int main(){ int a[N] = {0}; int b[N] = {0}; int c[N] = {0}; //求积 int d[N] = {0}; //求和 int i ,j; int x,z ; //系数 指数 int cnt=0; scanf(\"%d\",&amp;i); //读入第一个单项式 while( i-- ){ scanf(\"%d %d\",&amp;x,&amp;z); a[z] += x; //指数为z的系数放在z位置上 } scanf(\"%d\",&amp;i); //读入第二个单项式 while( i-- ){ scanf(\"%d %d\",&amp;x,&amp;z); b[z] += x; } //多项式乘法 for( i=N-1; i&gt;=0; i--){ if( a[i] ){ for( j=0; j&lt;N; j++){ if( b[j]){ c[ i+j ] += a[i]*b[j]; } } } } //输出多项式乘法结果 for( i=N-1; i&gt;=0; i--){ if( c[i] ){ if( cnt ){ //处理结尾不能有多余空格 printf(\" \"); } printf(\"%d %d\",c[i],i); cnt++; } } if( !cnt ){ printf(\"0 0\"); } printf(\"\\n\"); //多项式加法 for( i=N-1; i&gt;=0; i--){ if( a[i]){ d[i] += a[i]; } } for( j=N-1; j&gt;=0; j--){ if( b[j]){ d[j] += b[j]; } } //输出多项式加法结果 cnt = 0; for( i=N-1; i&gt;=0; i--){ if( d[i] ){ if( cnt ){ printf(\" \"); } printf(\"%d %d\",d[i],i); cnt++; } } if(!cnt){ printf(\"0 0\"); } return 0;}","link":"/2018/05/06/shujiujiegou7-2/"},{"title":"7-3 树的同构 (25 分)","text":"7-3 树的同构 (25 分)给定两棵树T1和T2。如果T1可以通过若干次左右孩子互换就变成T2，则我们称两棵树是“同构”的。例如图1给出的两棵树就是同构的，因为我们把其中一棵树的结点A、B、G的左右孩子互换后，就得到另外一棵树。而图2就不是同构的。 图1 图2 现给定两棵树，请你判断它们是否是同构的。 输入格式:输入给出2棵二叉树树的信息。对于每棵树，首先在一行中给出一个非负整数N (≤10)，即该树的结点数（此时假设结点从0到N−1编号）；随后N行，第i行对应编号第i个结点，给出该结点中存储的1个英文大写字母、其左孩子结点的编号、右孩子结点的编号。如果孩子结点为空，则在相应位置上给出“-”。给出的数据间用一个空格分隔。注意：题目保证每个结点中存储的字母是不同的。 输出格式:如果两棵树是同构的，输出“Yes”，否则输出“No”。 输入样例1（对应图1）：1234567891011121314151617188A 1 2B 3 4C 5 -D - -E 6 -G 7 -F - -H - -8G - 4B 7 6F - -A 5 1H - -C 0 -D - -E 2 - 输出样例1:1Yes 输入样例2（对应图2）：1234567891011121314151617188B 5 7F - -A 0 3C 6 -H - -D - -G 4 -E 1 -8D 6 -B 5 -E - -H - -C 0 2G - 3F - -A 1 4 输出样例2:1No 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define MaxTree 10#define ElementType char#define Tree int#define Null -1struct TreeNode{ ElementType e; Tree left; Tree right;}T1[MaxTree],T2[MaxTree];Tree BuildTree ( struct TreeNode T[]);int Isomorphic(Tree R1,Tree R2);int main(){ Tree R1,R2; R1 = BuildTree(T1); R2 = BuildTree(T2); if( Isomorphic(R1,R2)){ printf(\"Yes\\n\"); } else{ printf(\"No\\n\"); } return 0;}Tree BuildTree ( struct TreeNode T[]){ int i; int n; int check[MaxTree]; char cl,cr; Tree root =Null; //若n为0，返回Null scanf(\"%d\",&amp;n); if( n ){ for( i=0; i&lt;n; i++){ check[i] = 0; } for( i=0; i&lt;n; i++){ scanf(\"\\n%c %c %c\",&amp;T[i].e,&amp;cl,&amp;cr); if( cl!='-' ){ T[i].left = cl-'0'; //若输入不为'-',那字符减去字符0转换为整型数值 check[T[i].left] = 1; //把在静态链表中出现过的数值标记为1 } else if( cl=='-' ){ T[i].left = Null; } if( cr!='-' ){ T[i].right = cr-'0'; check[T[i].right] = 1; } else if( cr=='-' ){ T[i].right = Null; } } for( i=0; i&lt;n; i++){ if( !check[i]){ break; } } root = i; } return root;}int Isomorphic(Tree R1,Tree R2){ if((R1==Null)&amp;&amp;(R2==Null)) //如果为空树则是同构的 return 1; if(((R1==Null)&amp;&amp;(R2!=Null))||((R1!=Null)&amp;&amp;(R2==Null)))//如果一个为空一个不为空则不是同构的 return 0; if((T1[R1].e)!=(T2[R2].e))//如果数据不同则不是同构的 return 0; //如果左儿子都为空判断右儿子是否同构 if((T1[R1].left==Null)&amp;&amp;(T2[R2].left==Null)) return Isomorphic(T1[R1].right,T2[R2].right); /* 如果两棵树左儿子都不为空并且数据还是一样的，对左儿子进行递归*/ if ( ((T1[R1].left!=Null)&amp;&amp;(T2[R2].left!=Null))&amp;&amp;((T1[T1[R1].left].e)==(T2[T2[R2].left].e)) ) return ( Isomorphic( T1[R1].left, T2[R2].left )&amp;&amp;Isomorphic( T1[R1].right, T2[R2].right ) ); /* 如果两棵树左儿子（一个空一个不空或者都不空）并且数据不一样， 那么判断第一棵树的左（右）儿子是否跟第二棵树的右（左）儿子同构 */ else return ( Isomorphic( T1[R1].left, T2[R2].right)&amp;&amp;Isomorphic( T1[R1].right, T2[R2].left ) );}","link":"/2018/05/06/shujiujiegou7-3/"},{"title":"7-29 修理牧场 (25 分)","text":"7-29 修理牧场 (25 分)农夫要修理牧场的一段栅栏，他测量了栅栏，发现需要$N$块木头，每块木头长度为整数$L_i$个长度单位，于是他购买了一条很长的、能锯成$N$块的木头，即该木头的长度是$L_i$的总和。 但是农夫自己没有锯子，请人锯木的酬金跟这段木头的长度成正比。为简单起见，不妨就设酬金等于所锯木头的长度。例如，要将长度为20的木头锯成长度为8、7和5的三段，第一次锯木头花费20，将木头锯成12和8；第二次锯木头花费12，将长度为12的木头锯成7和5，总花费为32。如果第一次将木头锯成15和5，则第二次锯木头花费15，总花费为35（大于32）。 请编写程序帮助农夫计算将木头锯成$N$块的最少花费。 输入格式:输入首先给出正整数$N$（≤104），表示要将木头锯成$N$块。第二行给出$N$个正整数（≤50），表示每段木块的长度。 输出格式:输出一个整数，即将木头锯成$N$块的最少花费。 输入样例:1284 5 1 2 1 3 1 1 输出样例:149 123456789101112131415161718192021222324252627#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;int main(){ priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; q; int n,t,s=0; cin&gt;&gt;n; for(int i=0;i&lt;n;i++){ cin&gt;&gt;t; q.push(t); } int a,b; while(q.size()!=1){ a=q.top(); q.pop(); b=q.top(); q.pop(); s=s+a+b; q.push(a+b); } cout&lt;&lt;s&lt;&lt;endl; return 0;}","link":"/2018/05/06/shujiujiegou7-29/"},{"title":"7-31 笛卡尔树 (25 分)","text":"7-31 笛卡尔树 (25 分)笛卡尔树是一种特殊的二叉树，其结点包含两个关键字K1和K2。首先笛卡尔树是关于K1的二叉搜索树，即结点左子树的所有K1值都比该结点的K1值小，右子树则大。其次所有结点的K2关键字满足优先队列（不妨设为最小堆）的顺序要求，即该结点的K2值比其子树中所有结点的K2值小。给定一棵二叉树，请判断该树是否笛卡尔树。 输入格式:输入首先给出正整数N（≤1000），为树中结点的个数。随后N行，每行给出一个结点的信息，包括：结点的K1值、K2值、左孩子结点编号、右孩子结点编号。设结点从0~(N-1)顺序编号。若某结点不存在孩子结点，则该位置给出−1。 输出格式:输出YES如果该树是一棵笛卡尔树；否则输出NO。 输入样例1:123456768 27 5 19 40 -1 -110 20 0 312 21 -1 415 22 -1 -15 35 -1 -1 输出样例1:1YES 输入样例2:123456768 27 5 19 40 -1 -110 20 0 312 11 -1 415 22 -1 -150 35 -1 -1 输出样例2:1NO 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;iostream&gt;#include&lt;vector&gt; using namespace std; struct node{ int K1, K2, lchild, rchild;}; int N;node Node[1000];vector&lt;int&gt; inOrder; void inOrderTraversal(int head);bool judge1(int head);bool judge2(int head); int main(){ std::ios::sync_with_stdio(false); cin &gt;&gt; N; bool flag[N]; fill(flag, flag + N, false); for(int i = 0; i &lt; N; i++){ cin &gt;&gt; Node[i].K1 &gt;&gt; Node[i].K2 &gt;&gt; Node[i].lchild &gt;&gt; Node[i].rchild; if(Node[i].lchild != -1){ flag[Node[i].lchild] = true; } if(Node[i].rchild != -1){ flag[Node[i].rchild] = true; } } int head = -1; for(int i = 0; i &lt; N; i++){ if(!flag[i]){ head = i; break; } } if(judge1(head) &amp;&amp; judge2(head)){ cout &lt;&lt; \"YES\" &lt;&lt; endl; }else{ cout &lt;&lt; \"NO\" &lt;&lt; endl; } return 0;} void inOrderTraversal(int head){ if(head == -1){ return; } inOrderTraversal(Node[head].lchild); inOrder.push_back(Node[head].K1); inOrderTraversal(Node[head].rchild);} bool judge1(int head){ inOrderTraversal(head); for(int i = 1; i &lt; inOrder.size(); i++){ if(inOrder[i] &lt;= inOrder[i - 1]){ return false; } } return true;} bool judge2(int head){ if(head == -1){ return true; } if(Node[head].lchild != -1 &amp;&amp; Node[Node[head].lchild].K2 &lt;= Node[head].K2){ return false; } if(Node[head].rchild != -1 &amp;&amp; Node[Node[head].rchild].K2 &lt;= Node[head].K2){ return false; } return judge2(Node[head].lchild) &amp;&amp; judge2(Node[head].rchild);}","link":"/2018/05/06/shujiujiegou7-31/"},{"title":"7-33 地下迷宫探索 (30 分)","text":"7-33 地下迷宫探索 (30 分)地道战是在抗日战争时期，在华北平原上抗日军民利用地道打击日本侵略者的作战方式。地道网是房连房、街连街、村连村的地下工事，如下图所示。 我们在回顾前辈们艰苦卓绝的战争生活的同时，真心钦佩他们的聪明才智。在现在和平发展的年代，对多数人来说，探索地下通道或许只是一种娱乐或者益智的游戏。本实验案例以探索地下通道迷宫作为内容。 假设有一个地下通道迷宫，它的通道都是直的，而通道所有交叉点（包括通道的端点）上都有一盏灯和一个开关。请问你如何从某个起点开始在迷宫中点亮所有的灯并回到起点？ 输入格式:输入第一行给出三个正整数，分别表示地下迷宫的节点数$N$（1&lt;$N$≤1000，表示通道所有交叉点和端点）、边数$M$（≤3000，表示通道数）和探索起始节点编号$S$（节点从1到$N$编号）。随后的$M$行对应$M$条边（通道），每行给出一对正整数，分别是该条边直接连通的两个节点的编号。 输出格式:若可以点亮所有节点的灯，则输出从$S$开始并以$S$结束的包含所有节点的序列，序列中相邻的节点一定有边（通道）；否则虽然不能点亮所有节点的灯，但还是输出点亮部分灯的节点序列，最后输出0，此时表示迷宫不是连通图。 由于深度优先遍历的节点序列是不唯一的，为了使得输出具有唯一的结果，我们约定以节点小编号优先的次序访问（点灯）。在点亮所有可以点亮的灯后，以原路返回的方式回到起点。 输入样例1:1234567896 8 11 22 33 44 55 66 43 61 5 输出样例1:11 2 3 4 5 6 5 4 3 2 1 输入样例2:12345676 6 61 21 32 35 46 56 4 输出样例2:16 4 5 4 6 0 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;iostream&gt;#include&lt;set&gt;#include&lt;vector&gt; using namespace std; int N, M, S;set&lt;int&gt; graph[1001];bool visited[1001];vector&lt;int&gt; path; void dfs(int nowVisit); int main() { scanf(\"%d %d %d\", &amp;N, &amp;M, &amp;S); for(int i = 0; i &lt; M; i++) { int v1, v2; scanf(\"%d %d\", &amp;v1, &amp;v2); graph[v1].insert(v2); graph[v2].insert(v1); } fill(visited + 1, visited + N + 1, false); dfs(S); for(int i = 1; i &lt;= N; i++){ if(!visited[i]){ path.push_back(0); break; } } for(int i = 0; i &lt; path.size(); i++) { printf(\"%d\", path[i]); if(i != path.size() - 1) { printf(\" \"); } else { printf(\"\\n\"); } } return 0;} void dfs(int nowVisit) { visited[nowVisit] = true; path.push_back(nowVisit); for(set&lt;int&gt;::iterator it = graph[nowVisit].begin(); it != graph[nowVisit].end(); it++) { if(!visited[*it]) { dfs(*it); path.push_back(nowVisit); } }}","link":"/2018/05/06/shujiujiegou7-33/"},{"title":"7-34 任务调度的合理性 (25 分)","text":"7-34 任务调度的合理性 (25 分)假定一个工程项目由一组子任务构成，子任务之间有的可以并行执行，有的必须在完成了其它一些子任务后才能执行。“任务调度”包括一组子任务、以及每个子任务可以执行所依赖的子任务集。 比如完成一个专业的所有课程学习和毕业设计可以看成一个本科生要完成的一项工程，各门课程可以看成是子任务。有些课程可以同时开设，比如英语和C程序设计，它们没有必须先修哪门的约束；有些课程则不可以同时开设，因为它们有先后的依赖关系，比如C程序设计和数据结构两门课，必须先学习前者。 但是需要注意的是，对一组子任务，并不是任意的任务调度都是一个可行的方案。比如方案中存在“子任务A依赖于子任务B，子任务B依赖于子任务C，子任务C又依赖于子任务A”，那么这三个任务哪个都不能先执行，这就是一个不可行的方案。你现在的工作是写程序判定任何一个给定的任务调度是否可行。 输入格式:输入说明：输入第一行给出子任务数$N$（≤100），子任务按1~$N$编号。随后$N$行，每行给出一个子任务的依赖集合：首先给出依赖集合中的子任务数$K$，随后给出$K$个子任务编号，整数之间都用空格分隔。 输出格式:如果方案可行，则输出1，否则输出0。 输入样例1:1234567891011121312002 1 201 41 52 3 61 32 7 81 71 101 7 输出样例1:11 输入样例2:12345651 42 1 42 2 51 30 输出样例2:10 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;queue&gt; using namespace std; int N;int inDegree[101];vector&lt;int&gt; graph[101]; int main(){ std::ios::sync_with_stdio(false); cin &gt;&gt; N; for(int i = 1; i &lt;= N; i++){ int K; cin &gt;&gt; K; for(int j = 0; j &lt; K; j++){ int num; cin &gt;&gt; num; graph[i].push_back(num); inDegree[num]++; } } queue&lt;int&gt; q; for(int i = 1; i &lt;= N; i++){ if(inDegree[i] == 0){ q.push(i); } } int count = 0; while(!q.empty()){ int u = q.front(); q.pop(); for(int i = 0; i &lt; graph[u].size(); i++){ int v = graph[u][i]; inDegree[v]--; if(inDegree[v] == 0){ q.push(v); } } count++; } if(count == N){ cout &lt;&lt; 1 &lt;&lt; endl; }else{ cout &lt;&lt; 0 &lt;&lt; endl; } return 0;}","link":"/2018/05/06/shujiujiegou7-34/"},{"title":"7-35 城市间紧急救援 (25 分)","text":"7-35 城市间紧急救援 (25 分)作为一个城市的应急救援队伍的负责人，你有一张特殊的全国地图。在地图上显示有多个分散的城市和一些连接城市的快速道路。每个城市的救援队数量和每一条连接两个城市的快速道路长度都标在地图上。当其他城市有紧急求助电话给你的时候，你的任务是带领你的救援队尽快赶往事发地，同时，一路上召集尽可能多的救援队。 输入格式:输入第一行给出4个正整数$N$、$M$、$S$、$D$，其中$N$（2≤$N$≤500）是城市的个数，顺便假设城市的编号为0 ~ ($N$−1)；$M$是快速道路的条数；$S$是出发地的城市编号；$D$是目的地的城市编号。 第二行给出$N$个正整数，其中第$i$个数是第$i$个城市的救援队的数目，数字间以空格分隔。随后的$M$行中，每行给出一条快速道路的信息，分别是：城市1、城市2、快速道路的长度，中间用空格分开，数字均为整数且不超过500。输入保证救援可行且最优解唯一。 输出格式:第一行输出最短路径的条数和能够召集的最多的救援队数量。第二行输出从$S$到$D$的路径中经过的城市编号。数字间以空格分隔，输出结尾不能有多余空格。 输入样例:12345674 5 0 320 30 40 100 1 11 3 20 3 30 2 22 3 2 输出样例:122 600 1 3 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;set&gt; using namespace std; struct node { int v, len; node(int _v, int _len) { v = _v; len = _len; }}; int N, M, S, D, INF = 1000000000;int teams[500], d[500], countInq[500];vector&lt;node&gt; graph[500];bool inq[500];set&lt;int&gt; pre[500];vector&lt;int&gt; tempPath, path;int count = 0, maxTeams = 0; bool spfa(int s);void dfs(int nowVisit); int main() { std::ios::sync_with_stdio(false); cin &gt;&gt; N &gt;&gt; M &gt;&gt; S &gt;&gt; D; for(int i = 0; i &lt; N; i++) { cin &gt;&gt; teams[i]; } for(int i = 0; i &lt; M; i++) { int v1, v2, len; cin &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; len; graph[v1].push_back(node(v2, len)); graph[v2].push_back(node(v1, len)); } spfa(S); dfs(D); cout &lt;&lt; count &lt;&lt; \" \" &lt;&lt; maxTeams &lt;&lt; endl; for(int i = path.size() - 1; i &gt;= 0; i--){ cout &lt;&lt; path[i]; if(i == 0){ cout &lt;&lt; endl; }else{ cout &lt;&lt; \" \"; } } return 0;} bool spfa(int s) { fill(d, d + N, INF); fill(countInq, countInq + N, 0); fill(inq, inq + N, false); d[s] = 0; queue&lt;int&gt; q; q.push(s); countInq[s]++; inq[s] = true; while(!q.empty()) { int u = q.front(); q.pop(); inq[u] = false; for(int i = 0; i &lt; graph[u].size(); i++) { int v = graph[u][i].v; int len = graph[u][i].len; if(d[u] + len &lt; d[v]) { d[v] = d[u] + len; pre[v].clear(); pre[v].insert(u); if(!inq[v]) { q.push(v); inq[v] = true; countInq[v]++; if(countInq[v] &gt; N - 1){ return false; } } }else if(d[u] + len == d[v]) { pre[v].insert(u); if(!inq[v]) { q.push(v); inq[v] = true; countInq[v]++; if(countInq[v] &gt; N - 1){ return false; } } } } } return true;} void dfs(int nowVisit) { tempPath.push_back(nowVisit); if(nowVisit == S){ count++; int tempTeams = 0; for(int i = 0; i &lt; tempPath.size(); i++){ tempTeams += teams[tempPath[i]]; } if(tempTeams &gt; maxTeams){ maxTeams = tempTeams; path = tempPath; } tempPath.pop_back(); return; } for(set&lt;int&gt;::iterator it = pre[nowVisit].begin(); it != pre[nowVisit].end(); it++){ dfs(*it); } tempPath.pop_back();}","link":"/2018/05/06/shujiujiegou7-35/"},{"title":"7-32 哥尼斯堡的“七桥问题” (25 分)","text":"7-32 哥尼斯堡的“七桥问题” (25 分)哥尼斯堡是位于普累格河上的一座城市，它包含两个岛屿及连接它们的七座桥，如下图所示。 可否走过这样的七座桥，而且每桥只走过一次？瑞士数学家欧拉(Leonhard Euler，1707—1783)最终解决了这个问题，并由此创立了拓扑学。 这个问题如今可以描述为判断欧拉回路是否存在的问题。欧拉回路是指不令笔离开纸面，可画过图中每条边仅一次，且可以回到起点的一条回路。现给定一个无向图，问是否存在欧拉回路？ 输入格式:输入第一行给出两个正整数，分别是节点数$N$ (1≤$N$≤1000)和边数$M$；随后的$M$行对应$M$条边，每行给出一对正整数，分别是该条边直接连通的两个节点的编号（节点从1到$N$编号）。 输出格式:若欧拉回路存在则输出1，否则输出0。 输入样例1:12345678910116 101 22 33 14 55 66 41 41 63 43 6 输出样例1:11 输入样例2:1234567895 81 21 32 32 42 55 35 43 4 输出样例2:10 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758include&lt;iostream&gt;#include&lt;vector&gt; using namespace std; struct node{ int v;}; int N, M;vector&lt;int&gt; graph[1001];bool visited[1001];int degree[1001]; void dfs(int nowVisit); int main(){ std::ios::sync_with_stdio(false); cin &gt;&gt; N &gt;&gt; M; fill(degree + 1, degree + N + 1, 0); for(int i = 0; i &lt; M; i++){ int v1, v2; cin &gt;&gt; v1 &gt;&gt; v2; graph[v1].push_back(v2); graph[v2].push_back(v1); degree[v1]++; degree[v2]++; } int blocks = 0; for(int i = 1; i &lt;= N; i++){ if(!visited[i]){ dfs(i); blocks++; } } if(blocks != 1){ //如果不是一个连通图 printf(\"0\\n\"); return 0; } for(int i = 1; i &lt;= N; i++){ if(degree[i] % 2 != 0){ printf(\"0\\n\"); return 0; } } printf(\"1\\n\"); return 0;} void dfs(int nowVisit){ visited[nowVisit] = true; for(int i = 0; i &lt; graph[nowVisit].size(); i++){ int u = graph[nowVisit][i]; if(!visited[u]){ dfs(u); } }}","link":"/2018/05/06/shujiujiegou7-32/"},{"title":"7-36 社交网络图中结点的“重要性”计算 (30 分)","text":"7-36 社交网络图中结点的“重要性”计算 (30 分)在社交网络中，个人或单位（结点）之间通过某些关系（边）联系起来。他们受到这些关系的影响，这种影响可以理解为网络中相互连接的结点之间蔓延的一种相互作用，可以增强也可以减弱。而结点根据其所处的位置不同，其在网络中体现的重要性也不尽相同。 “紧密度中心性”是用来衡量一个结点到达其它结点的“快慢”的指标，即一个有较高中心性的结点比有较低中心性的结点能够更快地（平均意义下）到达网络中的其它结点，因而在该网络的传播过程中有更重要的价值。在有$N$个结点的网络中，结点$v_i$的“紧密度中心性”$C_c(v_i)$数学上定义为$v_i$到其余所有结点$v_j$ ($j ≠ i$) 的最短距离$d$($v_i$,$v_j$)的平均值的倒数： 对于非连通图，所有结点的紧密度中心性都是0。 给定一个无权的无向图以及其中的一组结点，计算这组结点中每个结点的紧密度中心性。 输入格式:输入第一行给出两个正整数$N$和$M$，其中$N$（≤104）是图中结点个数，顺便假设结点从1到$N$编号；$M$（≤105）是边的条数。随后的$M$行中，每行给出一条边的信息，即该边连接的两个结点编号，中间用空格分隔。最后一行给出需要计算紧密度中心性的这组结点的个数$K$（≤100）以及$K$个结点编号，用空格分隔。 输出格式:按照Cc(i)=x.xx的格式输出$K$个给定结点的紧密度中心性，每个输出占一行，结果保留到小数点后2位。 输入样例:123456789101112131415169 141 21 31 42 33 44 54 65 65 75 86 76 87 87 93 3 4 9 输出样例:123Cc(3)=0.47Cc(4)=0.62Cc(9)=0.35 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;vector&gt; using namespace std; int N, M, INF = 1000000000;vector&lt;int&gt; graph[10001];int d[10001], countInq[10001];bool inq[10001]; bool spfa(int s); int main(){ scanf(\"%d %d\", &amp;N, &amp;M); for(int i = 0; i &lt; M; i++){ int v1, v2; scanf(\"%d %d\", &amp;v1, &amp;v2); graph[v1].push_back(v2); graph[v2].push_back(v1); } int K; scanf(\"%d\", &amp;K); for(int i = 0; i &lt; K; i++){ int query; scanf(\"%d\", &amp;query); bool flag = spfa(query); if(!flag){ printf(\"Cc(%d)=0.00\\n\", query); }else{ int total = 0; for(int i = 1; i &lt;= N; i++){ total += d[i]; } printf(\"Cc(%d)=%.2f\\n\", query, (N - 1) * 1.0 / total); } } return 0;} bool spfa(int s){ fill(d + 1, d + N + 1, INF); fill(countInq + 1, countInq + N + 1, 0); fill(inq + 1, inq + N + 1, false); d[s] = 0; queue&lt;int&gt; q; q.push(s); countInq[s]++; inq[s] = true; while(!q.empty()){ int u = q.front(); q.pop(); inq[u] = false; for(int i = 0; i &lt; graph[u].size(); i++){ int v = graph[u][i]; int len = 1; if(d[u] + len &lt; d[v]){ d[v] = d[u] + len; if(!inq[v]){ q.push(v); countInq[v]++; inq[v] = true; if(countInq[v] &gt; N - 1){ return false; } } } } } return true;}","link":"/2018/05/06/shujiujiegou7-36/"},{"title":"7-38 寻找大富翁 (25 分)","text":"7-38 寻找大富翁 (25 分)胡润研究院的调查显示，截至2017年底，中国个人资产超过1亿元的高净值人群达15万人。假设给出N个人的个人资产值，请快速找出资产排前M位的大富翁。 输入格式:输入首先给出两个正整数$N$（≤106）和$M$（≤10），其中$N$为总人数，$M$为需要找出的大富翁数；接下来一行给出$N$个人的个人资产值，以百万元为单位，为不超过长整型范围的整数。数字间以空格分隔。 输出格式:在一行内按非递增顺序输出资产排前$M$位的大富翁的个人资产值。数字间以空格分隔，但结尾不得有多余空格。 输入样例:128 38 12 7 3 20 9 5 18 输出样例:120 18 12 123456789101112131415161718192021222324252627282930313233343536#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;vector&gt; using namespace std; int N, M; int main(){ scanf(\"%d %d\", &amp;N, &amp;M); priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; q; for(int i = 0; i &lt; N; i++){ int num; scanf(\"%d\", &amp;num); if(q.size() &lt; M){ q.push(num); }else if(q.top() &lt; num){ q.pop(); q.push(num); } } vector&lt;int&gt; result; while(!q.empty()){ result.push_back(q.top()); q.pop(); } for(int i = result.size() - 1; i &gt;= 0; i--){ printf(\"%d\", result[i]); if(i != 0){ printf(\" \"); }else{ printf(\"\\n\"); } } return 0;}","link":"/2018/05/06/shujiujiegou7-38/"},{"title":"7-37 模拟EXCEL排序 (25 分)","text":"7-37 模拟EXCEL排序 (25 分)Excel可以对一组纪录按任意指定列排序。现请编写程序实现类似功能。 输入格式:输入的第一行包含两个正整数N(≤105) 和C，其中N是纪录的条数，C是指定排序的列号。之后有 N行，每行包含一条学生纪录。每条学生纪录由学号（6位数字，保证没有重复的学号）、姓名（不超过8位且不包含空格的字符串）、成绩（[0, 100]内的整数）组成，相邻属性用1个空格隔开。 输出格式:在N行中输出按要求排序后的结果，即：当C=1时，按学号递增排序；当C=2时，按姓名的非递减字典序排序；当C=3时，按成绩的非递减排序。当若干学生具有相同姓名或者相同成绩时，则按他们的学号递增排序。 输入样例:12343 1000007 James 85000010 Amy 90000001 Zoe 60 输出样例:123000001 Zoe 60000007 James 85000010 Amy 90 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;vector&gt; using namespace std; struct student{ int number; char name[9]; int score;}; int N, C;vector&lt;student&gt; students; bool cmp(student s1, student s2); int main(){ scanf(\"%d %d\", &amp;N, &amp;C); for(int i = 0; i &lt; N; i++){ int number; char name[9]; int score; scanf(\"%d %s %d\", &amp;number, name, &amp;score); student stu; stu.number = number; strcpy(stu.name, name); stu.score = score; students.push_back(stu); } sort(students.begin(), students.end(), cmp); for(int i = 0; i &lt; N; i++){ printf(\"%06d %s %d\\n\", students[i].number, students[i].name, students[i].score); } return 0;} bool cmp(student s1, student s2){ if(C == 1){ return s1.number &lt; s2.number; }else if(C == 2){ int cmpName = strcmp(s1.name, s2.name); if(cmpName == 0){ return s1.number &lt; s2.number; }else{ return cmpName &lt; 0; } }else{ if(s1.score == s2.score){ return s1.number &lt; s2.number; }else{ return s1.score &lt; s2.score; } }}","link":"/2018/05/06/shujiujiegou7-37/"},{"title":"7-4 是否同一棵二叉搜索树 (25 分)","text":"7-4 是否同一棵二叉搜索树 (25 分)给定一个插入序列就可以唯一确定一棵二叉搜索树。然而，一棵给定的二叉搜索树却可以由多种不同的插入序列得到。例如分别按照序列{2, 1, 3}和{2, 3, 1}插入初始为空的二叉搜索树，都得到一样的结果。于是对于输入的各种插入序列，你需要判断它们是否能生成一样的二叉搜索树。 输入格式:输入包含若干组测试数据。每组数据的第1行给出两个正整数$N (\\leq 10)$和$L$，分别是每个序列插入元素的个数和需要检查的序列个数。第2行给出$N$个以空格分隔的正整数，作为初始插入序列。最后L行，每行给出$N$个插入的元素，属于$L$个需要检查的序列。 简单起见，我们保证每个插入序列都是1到$N$的一个排列。当读到$N$为0时，标志输入结束，这组数据不要处理。 输出格式:对每一组需要检查的序列，如果其生成的二叉搜索树跟对应的初始序列生成的一样，输出“Yes”，否则输出“No”。 输入样例:123456784 23 1 4 23 4 1 23 2 4 12 12 11 20 输出样例:123YesNoNo 鸣谢青岛大学周强老师补充测试数据！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef int ElemType;/* ElemType类型根据实际情况而定，这里假设为int */typedef struct TreeNode *Tree;struct TreeNode{ ElemType data; Tree left,right; int flag; //被访问过为1 否则0};Tree NewNode(ElemType data);Tree Insert(Tree T,ElemType data);Tree MakeTree(int N);int check (Tree T,ElemType data);int Judge(Tree T,int N);void ResetT(Tree T);void FreeTree(Tree T);int main(){ int N,L; Tree T; int i; scanf(\"%d\",&amp;N); while( N ) { scanf(\"%d\",&amp;L); T = MakeTree( N ); for( i=0; i&lt;L; i++) { if( Judge(T,N)) { printf(\"Yes\\n\"); } else { printf(\"No\\n\"); } ResetT( T ); //清除flag标记 } FreeTree( T ); scanf(\"%d\",&amp;N); } return 0;}Tree NewNode(ElemType data){ //创建一个新的结点 Tree T = (Tree) malloc(sizeof(struct TreeNode)); T-&gt;data = data; T-&gt;flag = 0; T-&gt;left = T-&gt;right =NULL; return T;}Tree Insert(Tree T,ElemType data){ //插入一个新的结点 if( !T ){ T = NewNode(data); } else{ if( data &gt; T-&gt;data) { T-&gt;right = Insert( T-&gt;right,data); } else if( data &lt; T-&gt;data ) { T-&gt;left = Insert( T-&gt;left,data); } //相等则不插入 } return T;}Tree MakeTree(int N){ Tree T; ElemType data; int i; scanf(\"%d\",&amp;data); T = NewNode( data ); for( i=1; i&lt;N; i++) { scanf(\"%d\",&amp;data); T = Insert( T,data); } return T;}int check (Tree T,ElemType data){ if( T-&gt;flag ) { if( data &lt; T-&gt;data) { return check( T-&gt;left,data ); } else if( data &gt; T-&gt;data) { return check( T-&gt;right,data); } } else { if( data == T-&gt;data) { T-&gt;flag = 1; return 1; } else return 0; }}int Judge(Tree T,int N){ //检验需验证的树是否跟已经构建的树一致 ElemType data; int flag = 0; int i ; scanf(\"%d\",&amp;data); if( data != T-&gt;data) { flag = 1; //根节点不一致 } else { T-&gt;flag = 1; } for( i=1; i&lt;N; i++) { scanf(\"%d\",&amp;data); if( (!flag) &amp;&amp; (!check(T,data))) { flag = 1; } } if(flag) return 0; else return 1;}void ResetT(Tree T){ if(T-&gt;left) { ResetT(T-&gt;left); } if(T-&gt;right) { ResetT(T-&gt;right); } T-&gt;flag = 0;}void FreeTree(Tree T){ if(T-&gt;left) { FreeTree(T-&gt;left); } if(T-&gt;right) { FreeTree(T-&gt;right); } free(T);}","link":"/2018/05/06/shujiujiegou7-4/"},{"title":"7-40 奥运排行榜 (25 分)","text":"7-40 奥运排行榜 (25 分)每年奥运会各大媒体都会公布一个排行榜，但是细心的读者发现，不同国家的排行榜略有不同。比如中国金牌总数列第一的时候，中国媒体就公布“金牌榜”；而美国的奖牌总数第一，于是美国媒体就公布“奖牌榜”。如果人口少的国家公布一个“国民人均奖牌榜”，说不定非洲的国家会成为榜魁…… 现在就请你写一个程序，对每个前来咨询的国家按照对其最有利的方式计算它的排名。 输入格式:输入的第一行给出两个正整数$N$和$M$（≤224，因为世界上共有224个国家和地区），分别是参与排名的国家和地区的总个数、以及前来咨询的国家的个数。为简单起见，我们把国家从0 ~ $N$−1编号。之后有$N$行输入，第i行给出编号为i−1的国家的金牌数、奖牌数、国民人口数（单位为百万），数字均为[0,1000]区间内的整数，用空格分隔。最后面一行给出$M$个前来咨询的国家的编号，用空格分隔。 输出格式:在一行里顺序输出前来咨询的国家的排名:计算方式编号。其排名按照对该国家最有利的方式计算；计算方式编号为：金牌榜=1，奖牌榜=2，国民人均金牌榜=3，国民人均奖牌榜=4。输出间以空格分隔，输出结尾不能有多余空格。 若某国在不同排名方式下有相同名次，则输出编号最小的计算方式。 输入样例:1234564 451 100 100036 110 3006 14 325 18 400 1 2 3 输出样例:11:1 1:2 1:3 1:4 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;vector&gt; using namespace std; struct country { int number; //国家编号 int prizes[3]; //prizes[0]代表金牌数量，prizes[1]代表奖牌数量，prizes[2]代表国民人口数量 int rank;}; int N, M;//countries1按金牌排名，countries2按奖牌排名，countries3按国民人均金牌排名，countries4按人均奖牌排名vector&lt;country&gt; countries1, countries2, countries3, countries4; bool cmp1(country c1, country c2);bool cmp2(country c1, country c2);bool cmp3(country c1, country c2);bool cmp4(country c1, country c2);void generateRank(int condition);int findRank(int condition, int number); int main() { scanf(\"%d %d\", &amp;N, &amp;M); for(int i = 0; i &lt; N; i++) { country tempCountry; scanf(\"%d %d %d\", &amp;tempCountry.prizes[0], &amp;tempCountry.prizes[1], &amp;tempCountry.prizes[2]); tempCountry.number = i; countries1.push_back(tempCountry); countries2.push_back(tempCountry); countries3.push_back(tempCountry); countries4.push_back(tempCountry); } sort(countries1.begin(), countries1.end(), cmp1); sort(countries2.begin(), countries2.end(), cmp2); sort(countries3.begin(), countries3.end(), cmp3); sort(countries4.begin(), countries4.end(), cmp4); for(int i = 0; i &lt; 4; i++){ generateRank(i); } for(int i = 0; i &lt; M; i++) { int query; scanf(\"%d\", &amp;query); int ranks[4]; for(int j = 0; j &lt; 4; j++) { ranks[j] = findRank(j + 1, query); } int minIndex = 0; for(int j = 1; j &lt; 4; j++) { if(ranks[j] &lt; ranks[minIndex]) { minIndex = j; } } printf(\"%d:%d\", ranks[minIndex], minIndex + 1); if(i == M - 1) { printf(\"\\n\"); } else { printf(\" \"); } } return 0;} bool cmp1(country c1, country c2) { return c1.prizes[0] &gt; c2.prizes[0];} bool cmp2(country c1, country c2) { return c1.prizes[1] &gt; c2.prizes[1];} bool cmp3(country c1, country c2) { return c1.prizes[0] * 1.0 / c1.prizes[2] &gt; c2.prizes[0] * 1.0 / c2.prizes[2];} bool cmp4(country c1, country c2) { return c1.prizes[1] * 1.0 / c1.prizes[2] &gt; c2.prizes[1] * 1.0 / c2.prizes[2];} void generateRank(int condition) { if(condition == 0) { for(int i = 0; i &lt; countries1.size(); i++) { if(i &gt; 0 &amp;&amp; countries1[i].prizes[0] == countries1[i - 1].prizes[0]) { countries1[i].rank = countries1[i - 1].rank; } else { countries1[i].rank = i; } } } else if(condition == 1) { for(int i = 0; i &lt; countries2.size(); i++) { if(i &gt; 0 &amp;&amp; countries2[i].prizes[1] == countries2[i - 1].prizes[1]) { countries2[i].rank = countries2[i - 1].rank; } else { countries2[i].rank = i; } } } else if(condition == 2) { for(int i = 0; i &lt; countries3.size(); i++) { if(i &gt; 0 &amp;&amp; countries3[i].prizes[0] * 1.0 / countries3[i].prizes[2] == countries3[i - 1].prizes[0] * 1.0 / countries3[i - 1].prizes[2]) { countries3[i].rank = countries3[i - 1].rank; } else { countries3[i].rank = i; } } } else { for(int i = 0; i &lt; countries4.size(); i++) { if(i &gt; 0 &amp;&amp; countries4[i].prizes[0] * 1.0 / countries4[i].prizes[2] == countries4[i - 1].prizes[0] * 1.0 / countries4[i - 1].prizes[2]) { countries4[i].rank = countries4[i - 1].rank; } else { countries4[i].rank = i; } } }} int findRank(int condition, int number) { if(condition == 1) { for(int i = 0; i &lt; countries1.size(); i++) { if(number == countries1[i].number) { return countries1[i].rank + 1; } } } else if(condition == 2) { for(int i = 0; i &lt; countries2.size(); i++) { if(number == countries2[i].number) { return countries2[i].rank + 1; } } } else if(condition == 3) { for(int i = 0; i &lt; countries3.size(); i++) { if(number == countries3[i].number) { return countries3[i].rank + 1; } } } else { for(int i = 0; i &lt; countries4.size(); i++) { if(number == countries4[i].number) { return countries4[i].rank + 1; } } }}","link":"/2018/05/06/shujiujiegou7-40/"},{"title":"7-41 PAT排名汇总 (25 分)","text":"7-41 PAT排名汇总 (25 分)计算机程序设计能力考试（Programming Ability Test，简称PAT）旨在通过统一组织的在线考试及自动评测方法客观地评判考生的算法设计与程序设计实现能力，科学的评价计算机程序设计人才，为企业选拔人才提供参考标准（网址http://www.patest.cn）。./) 每次考试会在若干个不同的考点同时举行，每个考点用局域网，产生本考点的成绩。考试结束后，各个考点的成绩将即刻汇总成一张总的排名表。 现在就请你写一个程序自动归并各个考点的成绩并生成总排名表。 输入格式:输入的第一行给出一个正整数N（≤100），代表考点总数。随后给出N个考点的成绩，格式为：首先一行给出正整数K（≤300），代表该考点的考生总数；随后K行，每行给出1个考生的信息，包括考号（由13位整数字组成）和得分（为[0,100]区间内的整数），中间用空格分隔。 输出格式:首先在第一行里输出考生总数。随后输出汇总的排名表，每个考生的信息占一行，顺序为：考号、最终排名、考点编号、在该考点的排名。其中考点按输入给出的顺序从1到N编号。考生的输出须按最终排名的非递减顺序输出，获得相同分数的考生应有相同名次，并按考号的递增顺序输出。 输入样例:123456789101112251234567890001 951234567890005 1001234567890003 951234567890002 771234567890004 8541234567890013 651234567890011 251234567890014 1001234567890012 85 输出样例:1234567891091234567890005 1 1 11234567890014 1 2 11234567890001 3 1 21234567890003 3 1 21234567890004 5 1 41234567890012 5 2 21234567890002 7 1 51234567890013 8 2 31234567890011 9 2 4 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include&lt;bits/stdc++.h&gt;using namespace std; struct student{ char name[14]; int chengji; int zuhao; int znpm; int ztpm; }stu[30003]; bool cmp(student a,student b){ if(a.chengji!=b.chengji) return a.chengji&gt;b.chengji; return strcmp(a.name,b.name)&lt;0;}int main(){ int i,n,j;int m,t,p;int sum; int temp,temp1; scanf(\"%d\",&amp;n); t=1; int arr[30003]; arr[0]=0;// int q;int sub=0; q=0; for(i=1;i&lt;=n;i++) { scanf(\"%d\",&amp;m); arr[t++]=m; sub+=m; for(q;q&lt;sub;q++) { scanf(\"%s %d\",stu[q].name,&amp;stu[q].chengji); stu[q].zuhao=i; stu[q].znpm=0; stu[q].ztpm=0; } } for(i=0;i&lt;n;i++) { temp=arr[i]; arr[i+1]+=temp; temp1=arr[i+1]; sort(stu+temp,stu+temp1,cmp); p=1; for(j=temp;j&lt;temp1;j++) { stu[j].znpm=p++; } for(j=temp;j&lt;temp1;j++) { if(stu[j].chengji==stu[j+1].chengji) stu[j+1].znpm=stu[j].znpm; } } sort(stu,stu+sub,cmp); for(j=0;j&lt;sub;j++) stu[j].ztpm=j+1; p=1; for(j=0;j&lt;sub;j++) { if(stu[j].chengji==stu[j+1].chengji) stu[j+1].ztpm=stu[j].ztpm; } printf(\"%d\\n\",sub); for(j=0;j&lt;sub;j++) { if(j!=sub-1) printf(\"%s %d %d %d\\n\",stu[j].name,stu[j].ztpm,stu[j].zuhao,stu[j].znpm); else printf(\"%s %d %d %d\",stu[j].name,stu[j].ztpm,stu[j].zuhao,stu[j].znpm); } return 0;}","link":"/2018/05/06/shujiujiegou7-41/"},{"title":"7-39 魔法优惠券 (25 分)","text":"7-39 魔法优惠券 (25 分)在火星上有个魔法商店，提供魔法优惠券。每个优惠劵上印有一个整数面值K，表示若你在购买某商品时使用这张优惠劵，可以得到K倍该商品价值的回报！该商店还免费赠送一些有价值的商品，但是如果你在领取免费赠品的时候使用面值为正的优惠劵，则必须倒贴给商店K倍该商品价值的金额…… 但是不要紧，还有面值为负的优惠劵可以用！（真是神奇的火星） 例如，给定一组优惠劵，面值分别为1、2、4、-1；对应一组商品，价值为火星币M$7、6、-2、-3，其中负的价值表示该商品是免费赠品。我们可以将优惠劵3用在商品1上，得到M$28的回报；优惠劵2用在商品2上，得到M$12的回报；优惠劵4用在商品4上，得到M$3的回报。但是如果一不小心把优惠劵3用在商品4上，你必须倒贴给商店M$12。同样，当你一不小心把优惠劵4用在商品1上，你必须倒贴给商店M$7。 规定每张优惠券和每件商品都只能最多被使用一次，求你可以得到的最大回报。 输入格式:输入有两行。第一行首先给出优惠劵的个数N，随后给出N个优惠劵的整数面值。第二行首先给出商品的个数M，随后给出M个商品的整数价值。N和M在[1, 106]之间，所有的数据大小不超过230，数字间以空格分隔。 输出格式:输出可以得到的最大回报。 输入样例:124 1 2 4 -14 7 6 -2 -3 输出样例:143 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;bits/stdc++.h&gt; using namespace std; int main(){ int i,j,n,m;int azheng,bzheng;int bfu,afu; int sum1,sum2;int sum;int jieguo1;int jieguo2; int arr[1000001];int brr[1000001]; scanf(\"%d\",&amp;n); azheng=0;afu=0; for(i=0;i&lt;n;i++) { scanf(\"%d\",&amp;arr[i]); if(arr[i]&gt;0) azheng++; else afu++; } scanf(\"%d\",&amp;m); bzheng=0;bfu=0; for(i=0;i&lt;m;i++) { scanf(\"%d\",&amp;brr[i]); if(brr[i]&gt;0) bzheng++; else bfu++; } sort(arr,arr+n); sort(brr,brr+m); jieguo1=min(bfu,afu); sum1=0; for(i=0;i&lt;jieguo1;i++) { sum1+=arr[i]*brr[i]; } jieguo2=min(azheng,bzheng); sum2=0; for(j=n-jieguo2;j&lt;n;j++) { sum2+=arr[j]*brr[m-jieguo2]; m++; } sum=sum1+sum2; printf(\"%d\",sum); return 0;}","link":"/2018/05/06/shujiujiegou7-39/"},{"title":"7-42 整型关键字的散列映射 (25 分)","text":"7-42 整型关键字的散列映射 (25 分)给定一系列整型关键字和素数$P$，用除留余数法定义的散列函数将关键字映射到长度为$P$的散列表中。用线性探测法解决冲突。 输入格式:输入第一行首先给出两个正整数$N$（≤1000）和$P$（≥$N$的最小素数），分别为待插入的关键字总数、以及散列表的长度。第二行给出$N$个整型关键字。数字间以空格分隔。 输出格式:在一行内输出每个整型关键字在散列表中的位置。数字间以空格分隔，但行末尾不得有多余空格。 输入样例:124 524 15 61 88 输出样例:14 0 1 3 123456789101112131415161718192021222324252627282930思路：用一个bool类型的数组filled标记某个位置是否有值，用一个int型数组nums标记存储数字#include&lt;iostream&gt; using namespace std; int main(){ int N, P; scanf(\"%d %d\", &amp;N, &amp;P); bool filled[P]; fill(filled, filled + P, false); int nums[P]; for(int i = 0; i &lt; N; i++){ int num; scanf(\"%d\", &amp;num); for(int j = 0; j &lt; P; j++){ if(!filled[(num + j) % P] || nums[(num + j) % P] == num){ filled[(num + j) % P] = true; nums[(num + j) % P] = num printf(\"%d\", (num + j) % P); break; } } if(i == N - 1){ printf(\"\\n\"); }else{ printf(\" \"); } } return 0;}","link":"/2018/05/06/shujiujiegou7-42/"},{"title":"7-43 字符串关键字的散列映射 (25 分)","text":"7-43 字符串关键字的散列映射 (25 分)给定一系列由大写英文字母组成的字符串关键字和素数$P$，用移位法定义的散列函数$H$($K$$e$$y$)将关键字$K$$e$$y$中的最后3个字符映射为整数，每个字符占5位；再用除留余数法将整数映射到长度为$P$的散列表中。例如将字符串AZDEG插入长度为1009的散列表中，我们首先将26个大写英文字母顺序映射到整数0~25；再通过移位将其映射为$3×32^2+4×32+6=3206$；然后根据表长得到，即是该字符串的散列映射位置。 发生冲突时请用平方探测法解决。 输入格式:输入第一行首先给出两个正整数$N$（≤500）和$P$（≥2$N$的最小素数），分别为待插入的关键字总数、以及散列表的长度。第二行给出$N$个字符串关键字，每个长度不超过8位，其间以空格分隔。 输出格式:在一行内输出每个字符串关键字在散列表中的位置。数字间以空格分隔，但行末尾不得有多余空格。 输入样例1:124 11HELLO ANNK ZOE LOLI 输出样例1:13 10 4 0 输入样例2:126 11LLO ANNA NNK ZOJ INNK AAA 输出样例2:13 0 10 9 6 1 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;iostream&gt;#include&lt;cstring&gt; using namespace std; int changeToInt(char* str); int main() { int N, P; scanf(\"%d %d\", &amp;N, &amp;P); char strs[P][9]; bool filled[P]; fill(filled, filled + P, false); for(int i = 0; i &lt; N; i++){ char input[9]; scanf(\"%s\", input); int num = changeToInt(input); for(int j = 0; j &lt; P; j++){ int index1 = (num + j * j) % P; if(!filled[index1] || strcmp(strs[index1], input) == 0){ filled[index1] = true; strcpy(strs[index1], input); printf(\"%d\", index1); break; } int index2 = (num - j * j) % P; while(index2 &lt; 0){ index2 += P; } if(!filled[index2] || strcmp(strs[index2], input) == 0){ filled[index2] = true; strcpy(strs[index2], input); printf(\"%d\", index2); break; } } if(i == N - 1){ printf(\"\\n\"); }else{ printf(\" \"); } } return 0;} int changeToInt(char* str) { int result = 0; int len = strlen(str); for(int i = max(len - 3, 0); i &lt; len; i++) { result = result * 32 + str[i] - 'A'; } return result;}","link":"/2018/05/06/shujiujiegou7-43/"},{"title":"7-44 基于词频的文件相似度 (30 分)","text":"7-44 基于词频的文件相似度 (30 分)实现一种简单原始的文件相似度计算，即以两文件的公共词汇占总词汇的比例来定义相似度。为简化问题，这里不考虑中文（因为分词太难了），只考虑长度不小于3、且不超过10的英文单词，长度超过10的只考虑前10个字母。 输入格式:输入首先给出正整数$N$（≤100），为文件总数。随后按以下格式给出每个文件的内容：首先给出文件正文，最后在一行中只给出一个字符#，表示文件结束。在$N$个文件内容结束之后，给出查询总数$M$（≤104），随后$M$行，每行给出一对文件编号，其间以空格分隔。这里假设文件按给出的顺序从1到$N$编号。 输出格式:针对每一条查询，在一行中输出两文件的相似度，即两文件的公共词汇量占两文件总词汇量的百分比，精确到小数点后1位。注意这里的一个“单词”只包括仅由英文字母组成的、长度不小于3、且不超过10的英文单词，长度超过10的只考虑前10个字母。单词间以任何非英文字母隔开。另外，大小写不同的同一单词被认为是相同的单词，例如“You”和“you”是同一个单词。 输入样例:12345678910113Aaa Bbb Ccc#Bbb Ccc Ddd#Aaa2 ccc Eeeis at Ddd@Fff#21 21 3 输出样例:1250.0%33.3% 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;set&gt; using namespace std; set&lt;string&gt; sets[100]; int main() { int N; scanf(\"%d\", &amp;N); getchar(); for(int i = 0; i &lt; N; i++) { string str = \"\"; while(true) { char c = getchar(); if(c == '#') { break; } else if((c &gt;= 'a' &amp;&amp; c &lt;= 'z') || (c &gt;= 'A' &amp;&amp; c &lt;= 'Z')) { if(c &gt;= 'a' &amp;&amp; c &lt;= 'z') { c = c - 'a' + 'A'; } str += c; } else { if(str.length() &gt;= 3) { if(str.length() &gt; 10){ str = str.substr(0, 10); } sets[i].insert(str); } str = \"\"; } } } int M; scanf(\"%d\", &amp;M); for(int i = 0; i &lt; M; i++) { int num1, num2; scanf(\"%d %d\", &amp;num1, &amp;num2); int common = 0; for(set&lt;string&gt;::iterator it = sets[num1 - 1].begin(); it != sets[num1 - 1].end(); it++){ if(sets[num2 - 1].find(*it) != sets[num2 - 1].end()){ common++; } } int total = sets[num1 - 1].size() + sets[num2 - 1].size() - common; printf(\"%.1f%\\n\", common * 100.0 / total); } return 0;}","link":"/2018/05/06/shujiujiegou7-44/"},{"title":"7-46 新浪微博热门话题 (30 分)","text":"7-46 新浪微博热门话题 (30 分)新浪微博可以在发言中嵌入“话题”，即将发言中的话题文字写在一对“#”之间，就可以生成话题链接，点击链接可以看到有多少人在跟自己讨论相同或者相似的话题。新浪微博还会随时更新热门话题列表，并将最热门的话题放在醒目的位置推荐大家关注。 本题目要求实现一个简化的热门话题推荐功能，从大量英文（因为中文分词处理比较麻烦）微博中解析出话题，找出被最多条微博提到的话题。 输入格式:输入说明：输入首先给出一个正整数$N$（≤105），随后$N$行，每行给出一条英文微博，其长度不超过140个字符。任何包含在一对最近的#中的内容均被认为是一个话题，输入保证#成对出现。 输出格式:第一行输出被最多条微博提到的话题，第二行输出其被提到的微博条数。如果这样的话题不唯一，则输出按字母序最小的话题，并在第三行输出And k more ...，其中k是另外几条热门话题的条数。输入保证至少存在一条话题。 注意：两条话题被认为是相同的，如果在去掉所有非英文字母和数字的符号、并忽略大小写区别后，它们是相同的字符串；同时它们有完全相同的分词。输出时除首字母大写外，只保留小写英文字母和数字，并用一个空格分隔原文中的单词。 输入样例:123454This is a #test of topic#.Another #Test of topic.#This is a #Hot# #Hot# topicAnother #hot!# #Hot# topic 输出样例:123Hot2And 1 more ... 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;map&gt;#include&lt;set&gt; using namespace std; int N;map&lt;string, set&lt;int&gt; &gt; belongs; int main() { scanf(\"%d\", &amp;N); getchar(); for(int i = 0; i &lt; N; i++) { char input[141]; scanf(\"%[^\\n]\", input); getchar(); string str = \"\"; int flag = 0; for(int j = 0; j &lt; strlen(input); j++) { if(input[j] == '#') { flag++; if(flag == 2) { flag = 0; if(str.length() != 0) { belongs[str].insert(i); } str = \"\"; } continue; } if(flag == 1) { if(input[j] &gt;= 'A' &amp;&amp; input[j] &lt;= 'Z') { //将大写字母转变成小写字母 input[j] = input[j] - 'A' + 'a'; } if((input[j] &gt;= 'a' &amp;&amp; input[j] &lt;= 'z') || (input[j] &gt;= '0' &amp;&amp; input[j] &lt;= '9') || input[j] == ' ') { //如果是字母或数字或空格，就加入字符串中 str += input[j]; }else if(j + 1 &lt; strlen(input) &amp;&amp; ((input[j + 1] &gt;= 'a' &amp;&amp; input[j + 1] &lt;= 'z') || (input[j + 1] &gt;= 'A' &amp;&amp; input[j + 1] &lt;= 'Z') || (input[j + 1] &gt;= '0' &amp;&amp; input[j + 1] &lt;= '9'))){ //如果下一个字符是字母或数字且下一个字符不超出input的长度范围，则将其替换为空格 str += ' '; } } } } int maxTimes = 0; //记录最热门的词出现话题数量 string tempResult; //记录最热门的词 for(map&lt;string, set&lt;int&gt; &gt;::iterator it = belongs.begin(); it != belongs.end(); it++) { if(it-&gt;second.size() &gt; maxTimes) { tempResult = it-&gt;first; maxTimes = it-&gt;second.size(); } } int other = 0; //计算与最热门词对应话题数量有着相同数量的话题总数 for(map&lt;string, set&lt;int&gt; &gt;::iterator it = belongs.begin(); it != belongs.end(); it++) { if(it-&gt;second.size() == maxTimes) { other++; } } string result = \"\"; while(tempResult.length() &gt; 0 &amp;&amp; tempResult[0] == ' '){ //去除前导空格 tempResult.erase(tempResult.begin()); } while(tempResult.length() &gt; 0 &amp;&amp; tempResult[tempResult.length() - 1] == ' '){ //去除后导空格 tempResult.erase(tempResult.end()); } for(int i = 0; i &lt; tempResult.length(); i++) { //去除单词之间多余的空格 if(i &gt; 0 &amp;&amp; tempResult[i - 1] == ' ' &amp;&amp; tempResult[i] == ' ') { continue; } result += tempResult[i]; } int count = belongs[result].size(); if(result[0] &gt;= 'a' &amp;&amp; result[0] &lt;= 'z') { result[0] = result[0] - 'a' + 'A'; } printf(\"%s\\n%d\\n\", result.c_str(), count); if(other &gt; 1) { printf(\"And %d more ...\\n\", other - 1); } return 0;}","link":"/2018/05/06/shujiujiegou7-46/"},{"title":"7-48 银行排队问题之单窗口“夹塞”版 (30 分)","text":"7-48 银行排队问题之单窗口“夹塞”版 (30 分)排队“夹塞”是引起大家强烈不满的行为，但是这种现象时常存在。在银行的单窗口排队问题中，假设银行只有1个窗口提供服务，所有顾客按到达时间排成一条长龙。当窗口空闲时，下一位顾客即去该窗口处理事务。此时如果已知第$i$位顾客与排在后面的第$j$位顾客是好朋友，并且愿意替朋友办理事务的话，那么第$i$位顾客的事务处理时间就是自己的事务加朋友的事务所耗时间的总和。在这种情况下，顾客的等待时间就可能被影响。假设所有人到达银行时，若没有空窗口，都会请求排在最前面的朋友帮忙（包括正在窗口接受服务的朋友）；当有不止一位朋友请求某位顾客帮忙时，该顾客会根据自己朋友请求的顺序来依次处理事务。试编写程序模拟这种现象，并计算顾客的平均等待时间。 输入格式:输入的第一行是两个整数：1≤$N$≤10000，为顾客总数；0≤$M$≤100，为彼此不相交的朋友圈子个数。若$M$非0，则此后$M$行，每行先给出正整数2≤$L$≤100，代表该圈子里朋友的总数，随后给出该朋友圈里的$L$位朋友的名字。名字由3个大写英文字母组成，名字间用1个空格分隔。最后$N$行给出$N$位顾客的姓名、到达时间$T$和事务处理时间$P$（以分钟为单位），之间用1个空格分隔。简单起见，这里假设顾客信息是按照到达时间先后顺序给出的（有并列时间的按照给出顺序排队），并且假设每个事务最多占用窗口服务60分钟（如果超过则按60分钟计算）。 输出格式:按顾客接受服务的顺序输出顾客名字，每个名字占1行。最后一行输出所有顾客的平均等待时间，保留到小数点后1位。 输入样例:1234567896 23 ANN BOB JOE2 JIM ZOEJIM 0 20BOB 0 15ANN 0 30AMY 0 2ZOE 1 61JOE 3 10 输出样例:1234567JIMZOEBOBANNJOEAMY75.2 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;unordered_map&gt;#include&lt;vector&gt;#include&lt;algorithm&gt; using namespace std; struct customer { //定义顾客结构体 char name[4]; int arriveTime, processTime;}; int N, M;unordered_map&lt;string, int&gt; friendMap, customerId; //friendMap存储每个人所属的朋友圈编号，customerId存储每个人名的到达顺序 bool visited[10000]; //visited[]数组标记第i个到达的人是否已经被处理过 vector&lt;string&gt; friends[100], result; //friends[i]存储朋友圈编号为i的朋友名，result存储结果 bool cmp(string s1, string s2); int main() { scanf(\"%d %d\", &amp;N, &amp;M); fill(visited, visited + N, false); for(int i = 0; i &lt; M; i++) { int L; scanf(\"%d\", &amp;L); for(int j = 0; j &lt; L; j++) { char name[4]; scanf(\"%s\", name); friendMap[name] = i; friends[i].push_back(name); } } customer customers[N]; for(int i = 0; i &lt; N; i++) { char name[4]; scanf(\"%s %d %d\", name, &amp;customers[i].arriveTime, &amp;customers[i].processTime); if(customers[i].processTime &gt; 60) { //如果单次处理时间超过60，当作60处理 customers[i].processTime = 60; } strcpy(customers[i].name, name); customerId[name] = i; } int totalTime = 0; //总等待时间 int window = customers[0].arriveTime; //一开始的窗口时间应该设置为最先到达的顾客的到达时间 for(int i = 0; i &lt; N; i++) { if(visited[i]) { //如果该顾客已经被处理过了，则跳过本次循环 continue; } if(friendMap.find(customers[i].name) == friendMap.end()) { //如果该顾客不属于任何一个朋友圈 if(window &gt; customers[i].arriveTime) { //如果窗口时间大于顾客的到达时间 totalTime += window - customers[i].arriveTime; //总等待时间增加 window += customers[i].processTime; //窗口时间加上该顾客的处理时间 }else{ window = customers[i].arriveTime + customers[i].processTime; //窗口时间更新为顾客的到达时间加上该顾客的处理时间 } visited[i] = true; result.push_back(customers[i].name); continue; //跳过本次循环 } int friendID = friendMap[customers[i].name]; sort(friends[friendID].begin(), friends[friendID].end(), cmp); //对该顾客所属朋友圈的朋友按到达顺序进行排序 for(int j = 0; j &lt; friends[friendID].size(); j++) { int id = customerId[friends[friendID][j]]; if(j &gt; 0 &amp;&amp; customers[id].arriveTime &gt; window){ //如果下一个朋友的在window的空闲时间之前没有到达，则无法插队 break; } if(visited[id]){ continue; } if(window &gt; customers[id].arriveTime) { totalTime += window - customers[id].arriveTime; window += customers[id].processTime; } else { window = customers[id].arriveTime + customers[id].processTime; } visited[id] = true; result.push_back(friends[friendID][j]); } } for(int i = 0; i &lt; result.size(); i++) { //输出结果 printf(\"%s\\n\", result[i].c_str()); } printf(\"%.1f\\n\", totalTime * 1.0 / N); return 0;} bool cmp(string s1, string s2) { return customerId[s1] &lt; customerId[s2];}","link":"/2018/05/06/shujiujiegou7-48/"},{"title":"7-47 打印选课学生名单 (25 分)","text":"7-47 打印选课学生名单 (25 分)假设全校有最多40000名学生和最多2500门课程。现给出每个学生的选课清单，要求输出每门课的选课学生名单。 输入格式:输入的第一行是两个正整数：N（≤40000），为全校学生总数；K（≤2500），为总课程数。此后N行，每行包括一个学生姓名（3个大写英文字母+1位数字）、一个正整数C（≤20）代表该生所选的课程门数、随后是C个课程编号。简单起见，课程从1到K编号。 输出格式:顺序输出课程1到K的选课学生名单。格式为：对每一门课，首先在一行中输出课程编号和选课学生总数（之间用空格分隔），之后在第二行按字典序输出学生名单，每个学生名字占一行。 输入样例:123456789101110 5ZOE1 2 4 5ANN0 3 5 2 1BOB5 5 3 4 2 1 5JOE4 1 2JAY9 4 1 2 5 4FRA8 3 4 2 5DON2 2 4 5AMY7 1 5KAT3 3 5 4 2LOR6 4 2 4 1 5 输出样例:1234567891011121314151617181920212223242526272829303132331 4ANN0BOB5JAY9LOR62 7ANN0BOB5FRA8JAY9JOE4KAT3LOR63 1BOB54 7BOB5DON2FRA8JAY9KAT3LOR6ZOE15 9AMY7ANN0BOB5DON2FRA8JAY9KAT3LOR6ZOE1 12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;vector&gt; using namespace std; int N, K;vector&lt;string&gt; course[2501]; int main(){ scanf(\"%d %d\", &amp;N, &amp;K); for(int i = 0; i &lt; N; i++){ char name[5]; scanf(\"%s\", name); int C; scanf(\"%d\", &amp;C); for(int j = 0; j &lt; C; j++){ int num; scanf(\"%d\", &amp;num); course[num].push_back(name); } } for(int i = 1; i &lt;= K; i++){ printf(\"%d %d\\n\", i, course[i].size()); sort(course[i].begin(), course[i].end()); for(int j = 0; j &lt; course[i].size(); j++){ printf(\"%s\\n\", course[i][j].c_str()); } } return 0;}","link":"/2018/05/06/shujiujiegou7-47/"},{"title":"7-45 航空公司VIP客户查询 (25 分)","text":"7-45 航空公司VIP客户查询 (25 分)不少航空公司都会提供优惠的会员服务，当某顾客飞行里程累积达到一定数量后，可以使用里程积分直接兑换奖励机票或奖励升舱等服务。现给定某航空公司全体会员的飞行记录，要求实现根据身份证号码快速查询会员里程积分的功能。 输入格式:输入首先给出两个正整数$N$（≤105）和$K$（≤500）。其中$K$是最低里程，即为照顾乘坐短程航班的会员,航空公司还会将航程低于$K$公里的航班也按$K$公里累积。随后$N$行，每行给出一条飞行记录。飞行记录的输入格式为：18位身份证号码（空格）飞行里程。其中身份证号码由17位数字加最后一位校验码组成，校验码的取值范围为0~9和x共11个符号；飞行里程单位为公里，是(0, 15 000]区间内的整数。然后给出一个正整数$M$（≤105），随后给出$M$行查询人的身份证号码。 输出格式:对每个查询人，给出其当前的里程累积值。如果该人不是会员，则输出No Info。每个查询结果占一行。 输入样例:123456789104 500330106199010080419 499110108198403100012 15000120104195510156021 800330106199010080419 1412010419551015602111010819840310001233010619901008041933010619901008041x 输出样例:1234800150001000No Info 123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt;#include&lt;unordered_map&gt;#include&lt;string&gt; using namespace std; int N, K;unordered_map&lt;string, int&gt; members; int main(){ std::ios::sync_with_stdio(false); cin &gt;&gt; N &gt;&gt; K; for(int i = 0; i &lt; N; i++){ string str; int miles; cin &gt;&gt; str &gt;&gt; miles; miles = max(miles, K); members[str] += miles; } int M; cin &gt;&gt; M; for(int i = 0; i &lt; M; i++){ string str; cin &gt;&gt; str; unordered_map&lt;string, int&gt;::iterator it = members.find(str); if(it == members.end()){ cout &lt;&lt; \"No Info\" &lt;&lt; endl; }else{ cout &lt;&lt; it-&gt;second &lt;&lt; endl; } } return 0;}","link":"/2018/05/06/shujiujiegou7-45/"},{"title":"7-49 打印学生选课清单 (25 分)","text":"7-49 打印学生选课清单 (25 分)假设全校有最多40000名学生和最多2500门课程。现给出每门课的选课学生名单，要求输出每个前来查询的学生的选课清单。 输入格式:输入的第一行是两个正整数：N（≤40000），为前来查询课表的学生总数；K（≤2500），为总课程数。此后顺序给出课程1到K的选课学生名单。格式为：对每一门课，首先在一行中输出课程编号（简单起见，课程从1到K编号）和选课学生总数（之间用空格分隔），之后在第二行给出学生名单，相邻两个学生名字用1个空格分隔。学生姓名由3个大写英文字母+1位数字组成。选课信息之后，在一行内给出了N个前来查询课表的学生的名字，相邻两个学生名字用1个空格分隔。 输出格式:对每位前来查询课表的学生，首先输出其名字，随后在同一行中输出一个正整数C，代表该生所选的课程门数，随后按递增顺序输出C个课程的编号。相邻数据用1个空格分隔，注意行末不能输出多余空格。 输入样例:12345678910111210 51 4ANN0 BOB5 JAY9 LOR62 7ANN0 BOB5 FRA8 JAY9 JOE4 KAT3 LOR63 1BOB54 7BOB5 DON2 FRA8 JAY9 KAT3 LOR6 ZOE15 9AMY7 ANN0 BOB5 DON2 FRA8 JAY9 KAT3 LOR6 ZOE1ZOE1 ANN0 BOB5 JOE4 JAY9 FRA8 DON2 AMY7 KAT3 LOR6 输出样例:12345678910ZOE1 2 4 5ANN0 3 1 2 5BOB5 5 1 2 3 4 5JOE4 1 2JAY9 4 1 2 4 5FRA8 3 2 4 5DON2 2 4 5AMY7 1 5KAT3 3 2 4 5LOR6 4 1 2 4 5 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;bits/stdc++.h&gt;#include&lt;cmath&gt; #define mem(a,b) memset(a,b,sizeof a);#define INF 0x3f3f3f3f using namespace std; typedef long long ll; struct cmp{ bool operator()(int a,int b) { return a&gt;b; }}; priority_queue&lt;int,vector&lt;int&gt;,cmp&gt; pq,tpq;map&lt;string,priority_queue&lt;int,vector&lt;int&gt;,cmp&gt; &gt; mp; int main(){ int n,m; while(~scanf(\"%d%d\",&amp;n,&amp;m)) { mp.clear(); int id,k; char name[7]; for(int i=0;i&lt;m;i++) { scanf(\"%d%d\",&amp;id,&amp;k); for(int j=0;j&lt;k;j++) { scanf(\"%s\",name); mp[name].push(id); } } for(int i=0;i&lt;n;i++) { scanf(\"%s\",name); tpq=mp[name]; printf(\"%s\",name); printf(\" %d\",tpq.size()); while(!tpq.empty()) { printf(\" %d\",tpq.top()); tpq.pop(); } puts(\"\"); } } return 0;}","link":"/2018/05/06/shujiujiegou7-49/"},{"title":"7-5 堆中的路径 (25 分)","text":"7-5 堆中的路径 (25 分)将一系列给定数字插入一个初始为空的小顶堆H[]。随后对任意给定的下标i，打印从H[i]到根结点的路径。 输入格式:每组测试第1行包含2个正整数$N$和$M(\\leq 1000)$，分别是插入元素的个数、以及需要打印的路径条数。下一行给出区间[-10000, 10000]内的$N$个要被插入一个初始为空的小顶堆的整数。最后一行给出$M$个下标。 输出格式:对输入中给出的每个下标i，在一行中输出从H[i]到根结点的路径上的数据。数字间以1个空格分隔，行末不得有多余空格。 输入样例:1235 346 23 26 24 105 4 3 输出样例:12324 23 1046 23 1026 10 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#define max 1005#define min -10001void Create();void Insert( int temp);int h[max],size;int main(){ int n,m; int temp; int i,j; scanf(\"%d %d\",&amp;n,&amp;m); Create(); for( i=0; i&lt;n; i++){ scanf(\"%d\",&amp;temp); Insert(temp); } for( i=0; i&lt;m; i++){ scanf(\"%d\",&amp;j); printf(\"%d\",h[j]); while( j&gt;1 ){ j /= 2; printf(\" %d\",h[j]); } printf(\"\\n\"); } return 0;}void Create(){ //初始化堆 size = 0; h[0] = min; //0位置不存数据，设置岗哨}void Insert( int temp){ //插入结点形成小顶堆 int i; for( i=++size; h[i/2]&gt;temp;i/=2){ //小顶堆，如果父节点大于插入结点则二者交换 h[i] = h[i/2]; } h[i] =temp;}","link":"/2018/05/06/shujiujiegou7-5/"},{"title":"7-50 畅通工程之局部最小花费问题 (35 分)","text":"7-50 畅通工程之局部最小花费问题 (35 分)某地区经过对城镇交通状况的调查，得到现有城镇间快速道路的统计数据，并提出“畅通工程”的目标：使整个地区任何两个城镇间都可以实现快速交通（但不一定有直接的快速道路相连，只要互相间接通过快速路可达即可）。现得到城镇道路统计表，表中列出了任意两城镇间修建快速路的费用，以及该道路是否已经修通的状态。现请你编写程序，计算出全地区畅通需要的最低成本。 输入格式:输入的第一行给出村庄数目$N$ (1≤$N$≤100)；随后的$N$($N$−1)/2行对应村庄间道路的成本及修建状态：每行给出4个正整数，分别是两个村庄的编号（从1编号到$N$），此两村庄间道路的成本，以及修建状态 — 1表示已建，0表示未建。 输出格式:输出全省畅通需要的最低成本。 输入样例:123456741 2 1 11 3 4 01 4 1 12 3 3 02 4 2 13 4 5 0 输出样例:13 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;const int maxn=105;const int INF=0x3f3f3f3f;int n;int d[maxn];int vis[maxn];struct edge{ int e,sp;};vector &lt;edge&gt; ve[maxn];void init (){ for (int i=2;i&lt;maxn;i++) d[i]=INF; d[1]=0; memset (vis,0,sizeof(vis));}void prim(){ while (1) { int maxx=INF; int u=-1; for (int i=1;i&lt;=n;i++) { if(!vis[i]&amp;&amp;maxx&gt;d[i]) { maxx=d[i]; u=i; } } if(u==-1) break; vis[u]=1; for (int i=0;i&lt;ve[u].size();i++) { int v=ve[u][i].e; if(!vis[v]&amp;&amp;d[v]&gt;ve[u][i].sp) { d[v]=ve[u][i].sp; } } } int sum=0; for (int i=1;i&lt;=n;i++) sum+=d[i]; printf(\"%d\\n\",sum); return ;}int main(){ scanf(\"%d\",&amp;n); init(); for (int i=0;i&lt;n*(n-1)/2;i++) { int x,y,sp,is; scanf(\"%d%d%d%d\",&amp;x,&amp;y,&amp;sp,&amp;is); edge temp1,temp2; temp1.e=y; temp2.e=x; //判断是否已将建造，根据情况进行修改 if(is) temp1.sp=temp2.sp=0; else temp1.sp=temp2.sp=sp; ve[x].push_back(temp1); ve[y].push_back(temp2); } prim(); return 0;}","link":"/2018/05/06/shujiujiegou7-50/"},{"title":"7-51 两个有序链表序列的合并 (20 分)","text":"7-51 两个有序链表序列的合并 (20 分)已知两个非降序链表序列S1与S2，设计函数构造出S1与S2合并后的新的非降序链表S3。 输入格式:输入分两行，分别在每行给出由若干个正整数构成的非降序序列，用−1表示序列的结尾（−1不属于这个序列）。数字用空格间隔。 输出格式:在一行中输出合并后新的非降序链表，数字间用空格分开，结尾不能有多余空格；若新链表为空，输出NULL。 输入样例:121 3 5 -12 4 6 8 10 -1 输出样例:11 2 3 4 5 6 8 10 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef int ElemType;typedef struct LNode{ ElemType Data; /* 存储结点数据 */ struct LNode *Next; /* 指向下一个结点的指针 */}LNode, *LinkList; /* 定义单链表类型 */LinkList Read(void);LinkList Merge(LinkList La, LinkList Lb);void Print(LinkList L);int main(){ LinkList La, Lb, Lc; La = Read(); Lb = Read(); Lc = Merge(La, Lb); Print(Lc); return 0;}LinkList Read(void){ /* 读入链表元素，以-1位结束标志*/ LinkList L,rear, temp; ElemType data; L = (LinkList)malloc(sizeof(LNode)); /* 链表头空结点*/ L-&gt;Data = -1; L-&gt;Next = NULL; rear = L; scanf(\"%d\", &amp;data); while(data!=-1){ temp = (LinkList)malloc(sizeof(LNode)); temp-&gt;Data = data; //printf(\"Write:%d\\n\", temp-&gt;Data); temp-&gt;Next = NULL; rear-&gt;Next = temp; rear = rear-&gt;Next; scanf(\"%d\", &amp;data); } return L; /* 返回带头空结点的链表 */}LinkList Merge(LinkList La, LinkList Lb){ /* 输入两个有序链表的头指针，返回合并后有序链表的头指针*/ LinkList L, pa, pb, rear; L = (LinkList)malloc(sizeof(LNode)); L-&gt;Data = -1; L-&gt;Next = NULL; rear = L; /* 尾插法，rear初始指向头结点*/ pa = La-&gt;Next; pb = Lb-&gt;Next; //printf(\"Start Merging...\\n\"); while(pa&amp;&amp;pb){ if(pa-&gt;Data &lt; pb-&gt;Data){ rear-&gt;Next = pa; //printf(\"Get:%d\\n\", pa-&gt;Data); pa = pa-&gt;Next; } else{ rear-&gt;Next = pb; //printf(\"Get:%d\\n\", pb-&gt;Data); pb = pb-&gt;Next; } rear = rear-&gt;Next; } while(pa){ rear-&gt;Next = pa; //printf(\"Get:%d\\n\", pa-&gt;Data); pa = pa-&gt;Next; rear = rear-&gt;Next; } while(pb){ rear-&gt;Next = pb; //printf(\"Get:%d\\n\", pb-&gt;Data); pb = pb-&gt;Next; rear = rear-&gt;Next; } rear-&gt;Next = NULL; /* 不删除原链表的头结点*/ return L;}void Print(LinkList L){ LinkList p; int tag = 1; p = L-&gt;Next; while(p){ if(tag){ /* 第一个元素前面不带空格*/ printf(\"%d\", p-&gt;Data); tag = 0; p = p-&gt;Next; } else{ printf(\" %d\", p-&gt;Data); p = p-&gt;Next; } } if(tag){ printf(\"NULL\"); }}","link":"/2018/05/06/shujiujiegou7-51/"},{"title":"7-6 列出连通集 (25 分)","text":"7-6 列出连通集 (25 分)给定一个有$N$个顶点和$E$条边的无向图，请用DFS和BFS分别列出其所有的连通集。假设顶点从0到$N$−1编号。进行搜索时，假设我们总是从编号最小的顶点出发，按编号递增的顺序访问邻接点。 输入格式:输入第1行给出2个整数$N(0&lt;N \\leq 10)$和$E$，分别是图的顶点数和边数。随后$E$行，每行给出一条边的两个端点。每行中的数字之间用1空格分隔。 输出格式:按照”{$ v_1 v_2 \\dots v_k $}”的格式，每行输出一个连通集。先输出DFS的结果，再输出BFS的结果。 输入样例:12345678 60 70 12 04 12 43 5 输出样例:123456{ 0 1 4 2 7 }{ 3 5 }{ 6 }{ 0 1 2 7 4 }{ 3 5 }{ 6 } 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#define MAXVEX 15void CreateGraph( );void DFS( int i);void DFSTraverse();void BFSTraverse();int G[MAXVEX][MAXVEX],Nv,Ne;int visited[MAXVEX];int main(){ CreateGraph(); DFSTraverse(); BFSTraverse(); return 0;}void CreateGraph(){ //用邻接矩阵表示图 int i,j; int v1,v2; scanf(\"%d %d\",&amp;Nv,&amp;Ne); for( i=0; i&lt;Nv; i++) { for( j=0; j&lt;Nv; j++) { G[i][j] = 0; //初始化 } } for( i=0; i&lt;Ne; i++) //注意这里是读入边 { scanf(\"%d %d\",&amp;v1,&amp;v2); G[v1][v2] = 1; G[v2][v1]= G[v1][v2]; //无向图对称 }}void DFS( int i){ int j; visited[i] = 1; printf(\"%d \",i); for( j=0; j&lt;Nv; j++) { if( G[i][j] &amp;&amp; !visited[j]) { //如果存在ij之间的连线且j并未被访问过 DFS (j); } }}void DFSTraverse( ){ int i; for( i=0; i&lt;Nv; i++) { visited[i] = 0; //初始化访问矩阵 } for ( i=0; i&lt;Nv; i++) { if( !visited[i]) { printf(\"{ \"); DFS(i); printf(\"}\\n\"); } }}void BFSTraverse( ){ int q[MAXVEX]={0}; //用数组表示队列 int rear=-1,front=-1; int i,j; int temp; for( i=0; i&lt;Nv; i++) { visited[i] = 0; } for( i=0; i&lt;Nv; i++){ if( !visited[i]){ printf(\"{ \"); visited[i] =1; q[++rear] = i; //入队 while( front&lt;rear ){ //判断队列是否为空 temp =q[++front]; //出队 printf(\"%d \",temp); for( j=0; j&lt;Nv;j++){ if( G[temp][j] &amp;&amp; !visited[j]){ visited[j] = 1; q[++rear] = j; } } } printf(\"}\\n\"); } }}","link":"/2018/05/06/shujiujiegou7-6/"},{"title":"7-52 两个有序链表序列的交集 (20 分)","text":"7-52 两个有序链表序列的交集 (20 分)已知两个非降序链表序列S1与S2，设计函数构造出S1与S2的交集新链表S3。 输入格式:输入分两行，分别在每行给出由若干个正整数构成的非降序序列，用−1表示序列的结尾（−1不属于这个序列）。数字用空格间隔。 输出格式:在一行中输出两个输入序列的交集序列，数字间用空格分开，结尾不能有多余空格；若新链表为空，输出NULL。 输入样例:121 2 5 -12 4 5 8 10 -1 输出样例:12 5 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;bits/stdc++.h&gt;using namespace std;vector&lt;int&gt; A,B;int flag=0;void SameSet(){ int i=0,j=0; while(i&lt;A.size()&amp;&amp;j&lt;B.size()){ if(A[i]&lt;B[j]) i++; else if(A[i]&gt;B[j]) j++; else { if(flag==0){ printf(\"%d\",A[i]); flag=1; }else{ printf(\" %d\",A[i]); } i++,j++; } }}int main(){ int num; while(1){ scanf(\"%d\",&amp;num); if(num==-1) break; A.push_back(num); } while(1){ scanf(\"%d\",&amp;num); if(num==-1) break; B.push_back(num); } if(A.size()==0||B.size()==0) { printf(\"NULL\"); return 0; } SameSet(); if(flag==0) printf(\"NULL\"); return 0;}","link":"/2018/05/06/shujiujiegou7-52/"},{"title":"7-53 两个有序序列的中位数 (25 分)","text":"7-53 两个有序序列的中位数 (25 分)已知有两个等长的非降序序列S1, S2, 设计函数求S1与S2并集的中位数。有序序列A0,A1,⋯,A**N−1的中位数指A(N−1)/2的值,即第⌊(N+1)/2⌋个数（A0为第1个数）。 输入格式:输入分三行。第一行给出序列的公共长度N（0&lt;N≤100000），随后每行输入一个序列的信息，即N个非降序排列的整数。数字用空格间隔。 输出格式:在一行中输出两个输入序列的并集序列的中位数。 输入样例1:12351 3 5 7 92 3 4 5 6 输出样例1:14 输入样例2:1236-100 -10 1 1 1 1-50 0 2 3 4 5 输出样例2:11 123456789101112131415161718192021222324252627282930313233343536#include &lt;stdio.h&gt;void f(int a[],int left,int right);int a[200020];int main(){ int n,m; scanf(\"%d\",&amp;n); int x=0; for (int i=0;i&lt;n;i++){ scanf(\"%d\",&amp;m); a[x++]=m; } for (int i=0;i&lt;n;i++){ scanf(\"%d\",&amp;m); a[x++]=m; } f(a,0,x-1); printf(\"%d\\n\",a[(2*n-1)/2]);}void f(int a[],int left,int right){ int x=a[left],i=left,j=right; if (i&gt;=j) {return;} while (i&lt;j) { while (i&lt;j&amp;&amp;a[j]&gt;=x) j--; a[i]=a[j]; while (i&lt;j&amp;&amp;a[i]&lt;=x) i++; a[j]=a[i]; } a[i]=x; f(a,left,i-1); f(a,i+1,right);}","link":"/2018/05/06/shujiujiegou7-53/"},{"title":"7-7 六度空间 (30 分)","text":"7-7 六度空间 (30 分)“六度空间”理论又称作“六度分隔（Six Degrees of Separation）”理论。这个理论可以通俗地阐述为：“你和任何一个陌生人之间所间隔的人不会超过六个，也就是说，最多通过五个人你就能够认识任何一个陌生人。”如图1所示。 图1 六度空间示意图 “六度空间”理论虽然得到广泛的认同，并且正在得到越来越多的应用。但是数十年来，试图验证这个理论始终是许多社会学家努力追求的目标。然而由于历史的原因，这样的研究具有太大的局限性和困难。随着当代人的联络主要依赖于电话、短信、微信以及因特网上即时通信等工具，能够体现社交网络关系的一手数据已经逐渐使得“六度空间”理论的验证成为可能。 假如给你一个社交网络图，请你对每个节点计算符合“六度空间”理论的结点占结点总数的百分比。 输入格式:输入第1行给出两个正整数，分别表示社交网络图的结点数N（1&lt;$N$≤104，表示人数）、边数$M$（≤33×$N$，表示社交关系数）。随后的$M$行对应$M$条边，每行给出一对正整数，分别是该条边直接连通的两个结点的编号（节点从1到$N$编号）。 输出格式:对每个结点输出与该结点距离不超过6的结点数占结点总数的百分比，精确到小数点后2位。每个结节点输出一行，格式为“结点编号:（空格）百分比%”。 输入样例:1234567891010 91 22 33 44 55 66 77 88 99 10 输出样例:123456789101: 70.00%2: 80.00%3: 90.00%4: 100.00%5: 100.00%6: 100.00%7: 100.00%8: 90.00%9: 80.00%10: 70.00% 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#define MAXVEX 10005void CreateGraph( );int BFSTraverse(int i);int G[MAXVEX][MAXVEX],Nv,Ne;int visited[MAXVEX];int main(){ int i,j; int count; double b; CreateGraph(); for( i=1; i&lt;=Nv; i++) { count = BFSTraverse(i); b = 100.0*count/Nv; printf(\"%d: %.2f%%\\n\",i,b); } return 0;}void CreateGraph(){ //用邻接矩阵表示图 int i,j; int v1,v2; scanf(\"%d %d\",&amp;Nv,&amp;Ne); for( i=0; i&lt;=Nv; i++) { for( j=0; j&lt;=Nv; j++) { G[i][j] = 0; //初始化 } } for( i=0; i&lt;Ne; i++) //注意这里是读入边 { scanf(\"%d %d\",&amp;v1,&amp;v2); G[v1][v2] = 1; G[v2][v1]= G[v1][v2]; //无向图对称 }}int BFSTraverse( int i){ int q[MAXVEX]= {0}; //用数组表示队列 int rear=-1,front=-1; int j; int temp; int cnt ; int level; //当前结点所在的层数 int last; //该层的最后一个结点 int tail; //最后一个进入队列的结点 for( j=0; j&lt;=Nv; j++) { visited[j] = 0; } visited[i] =1; cnt = 1; level = 0; //本结点不算在层数里 last = i; q[++rear] = i; //入队 while( front&lt;rear ) //判断队列是否为空 { temp =q[++front]; //出队 for( j=1; j&lt;=Nv; j++) { if( G[temp][j] &amp;&amp; !visited[j]) { visited[j] = 1; q[++rear] = j; cnt ++; tail = j; } } if( temp==last) { level ++; last = tail; } if( level==6 ) { break; } } return cnt;}","link":"/2018/05/06/shujiujiegou7-7/"},{"title":"7-9 旅游规划 (25 分)","text":"7-9 旅游规划 (25 分)有了一张自驾旅游路线图，你会知道城市间的高速公路长度、以及该公路要收取的过路费。现在需要你写一个程序，帮助前来咨询的游客找一条出发地和目的地之间的最短路径。如果有若干条路径都是最短的，那么需要输出最便宜的一条路径。 输入格式:输入说明：输入数据的第1行给出4个正整数$N$、$M$、$S$、$D$，其中$N$（2≤$N$≤500）是城市的个数，顺便假设城市的编号为0~($N$−1)；$M$是高速公路的条数；$S$是出发地的城市编号；$D$是目的地的城市编号。随后的$M$行中，每行给出一条高速公路的信息，分别是：城市1、城市2、高速公路长度、收费额，中间用空格分开，数字均为整数且不超过500。输入保证解的存在。 输出格式:在一行里输出路径的长度和收费总额，数字间以空格分隔，输出结尾不能有多余空格。 输入样例:1234564 5 0 30 1 1 201 3 2 300 3 4 100 2 2 202 3 1 20 输出样例:13 40 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#define MAXVEX 505#define INFINITY 65535void CreateGraph( );void Dijkstra( int v);int G[MAXVEX][MAXVEX][2],Nv,Ne;int know[MAXVEX]; //know[]=1表示求得最短路径int distance[MAXVEX]; //表示求的最短距离int pay[MAXVEX]; //表示最少费用//int P[MAXVEX]; //存储最短路径的下标int main(){ int s,d; scanf(\"%d %d %d %d\",&amp;Nv,&amp;Ne,&amp;s,&amp;d); CreateGraph(); Dijkstra(s); if( distance[d]&lt;INFINITY ){ printf(\"%d %d\",distance[d],pay[d]); } return 0;}void CreateGraph(){ //用邻接矩阵表示图 int i,j; int v1,v2; int dn,f; //dn表示距离，f表示费用 for( i=0; i&lt;Nv; i++) { for( j=0; j&lt;Nv; j++) { G[i][j][0] = INFINITY; //初始化 G[i][j][1] = INFINITY; } } for( i=0; i&lt;Ne; i++) //注意这里是读入边 { scanf(\"%d %d %d %d\",&amp;v1,&amp;v2,&amp;dn,&amp;f); G[v1][v2][0] = G[v2][v1][0]=dn; G[v1][v2][1] = G[v2][v1][1]=f; }}void Dijkstra( int v){ //求从v结点到其他各结点的最短距离 int i,j,k; int min,cost; for( i=0; i&lt;Nv; i++) { know[i] =0; distance[i] =G[v][i][0]; //将与v点有连接的结点加上距离 pay[i] =G[v][i][1]; } know[v] = 1; distance[v] =0; //V到V距离为0 pay[v] = 0; for( i=1; i&lt;Nv; i++) { min = INFINITY; //当前所知离v结点的最近距离 for( j=0; j&lt;Nv; j++) { //寻找离v结点的最近距离 if( !know[j] &amp;&amp; distance[j]&lt;min) { k = j; min = distance[j]; cost = pay[j]; } } know[k] = 1; for( j=0; j&lt;Nv; j++) { //修正最短路径和距离 if( !know[j] &amp;&amp; (min+G[k][j][0]&lt;distance[j])) { distance[j] = min+G[k][j][0]; pay[j] = cost + G[k][j][1]; } else if( !know[j] &amp;&amp; (min+G[k][j][0]==distance[j]) &amp;&amp; (cost+G[k][j][1] &lt; pay[j])) { pay[j] = cost + G[k][j][1]; } } }}","link":"/2018/05/06/shujiujiegou7-9/"},{"title":"习题10-2 递归求阶乘和（15 分）","text":"习题10-2 递归求阶乘和（15 分）本题要求实现一个计算非负整数阶乘的简单函数，并利用该函数求 $1 !+2 !+3 !+\\ldots+n !$的值。 函数接口定义：12double fact( int n );double factsum( int n ); 函数fact应返回n的阶乘，建议用递归实现。函数factsum应返回 1!+2!+…+n! 的值。题目保证输入输出在双精度范围内。 裁判测试程序样例：1234567891011121314151617#include &lt;stdio.h&gt;double fact( int n );double factsum( int n );int main(){ int n; scanf(\"%d\",&amp;n); printf(\"fact(%d) = %.0f\\n\", n, fact(n)); printf(\"sum = %.0f\\n\", factsum(n)); return 0;}/* 你的代码将被嵌在这里 */ 输入样例1：110 输出样例1：12fact(10) = 3628800sum = 4037913 输入样例2：10 输出样例2：12fact(0) = 1sum = 0 123456789101112131415161718192021222324252627282930313233343536#include &lt;stdio.h&gt;double fact( int n );double factsum( int n );int main(){ int n; scanf(\"%d\",&amp;n); printf(\"fact(%d) = %.0f\\n\", n, fact(n)); printf(\"sum = %.0f\\n\", factsum(n)); return 0;}double fact(int n){ double result; if (n == 0 || n == 1) result = 1; else result = n*fact(n-1); return result;}double factsum(int n){ int i; double sum; sum=0; for (i=1; i&lt;=n; i++) sum = sum+fact(i); return sum;}","link":"/2018/02/08/siti10-2/"},{"title":"7-8 哈利·波特的考试 (25 分)","text":"7-8 哈利·波特的考试 (25 分)哈利·波特要考试了，他需要你的帮助。这门课学的是用魔咒将一种动物变成另一种动物的本事。例如将猫变成老鼠的魔咒是haha，将老鼠变成鱼的魔咒是hehe等等。反方向变化的魔咒就是简单地将原来的魔咒倒过来念，例如ahah可以将老鼠变成猫。另外，如果想把猫变成鱼，可以通过念一个直接魔咒lalala，也可以将猫变老鼠、老鼠变鱼的魔咒连起来念：hahahehe。 现在哈利·波特的手里有一本教材，里面列出了所有的变形魔咒和能变的动物。老师允许他自己带一只动物去考场，要考察他把这只动物变成任意一只指定动物的本事。于是他来问你：带什么动物去可以让最难变的那种动物（即该动物变为哈利·波特自己带去的动物所需要的魔咒最长）需要的魔咒最短？例如：如果只有猫、鼠、鱼，则显然哈利·波特应该带鼠去，因为鼠变成另外两种动物都只需要念4个字符；而如果带猫去，则至少需要念6个字符才能把猫变成鱼；同理，带鱼去也不是最好的选择。 输入格式:输入说明：输入第1行给出两个正整数$N$ (≤100)和$M$，其中$N$是考试涉及的动物总数，$M$是用于直接变形的魔咒条数。为简单起见，我们将动物按1~$N$编号。随后$M$行，每行给出了3个正整数，分别是两种动物的编号、以及它们之间变形需要的魔咒的长度(≤100)，数字之间用空格分隔。 输出格式:输出哈利·波特应该带去考场的动物的编号、以及最长的变形魔咒的长度，中间以空格分隔。如果只带1只动物是不可能完成所有变形要求的，则输出0。如果有若干只动物都可以备选，则输出编号最小的那只。 输入样例:1234567891011126 113 4 701 2 15 4 502 6 505 6 601 3 704 6 603 6 805 1 1002 4 605 2 80 输出样例:14 70 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#define MAXVEX 105#define INFINITY 65535void CreateGraph( );void Floyd();void FindAnimal();int FindMax( int i);int G[MAXVEX][MAXVEX],Nv,Ne;int D[MAXVEX][MAXVEX]; //存储最短路径矩阵int main(){ CreateGraph(); FindAnimal(); return 0;}void CreateGraph(){ //用邻接矩阵表示图 int i,j; int v1,v2,w; scanf(\"%d %d\",&amp;Nv,&amp;Ne); for( i=1; i&lt;=Nv; i++) { for( j=1; j&lt;=Nv; j++) { if( i==j){ G[i][j] = 0; } else G[i][j] = INFINITY; //初始化 } } for( i=0; i&lt;Ne; i++) //注意这里是读入边 { scanf(\"%d %d %d\",&amp;v1,&amp;v2,&amp;w); G[v1][v2] = w; //读入权值 G[v2][v1]= G[v1][v2]; //无向图对称 }}void FindAnimal(){ int max,min; int animal; int i; Floyd(); min = INFINITY; for( i=1; i&lt;=Nv; i++) { //比较每行最大距离，寻找其中最小值 max = FindMax( i ); if( max == INFINITY) { //判断图是否连同通 printf(\"0\\n\"); return; } if( min&gt;max ) { min = max; animal = i; } } printf(\"%d %d\\n\",animal,min);}int FindMax( int i){ int max; int j; max = 0; for( j=1; j&lt;=Nv; j++) { if( i!=j &amp;&amp; D[i][j]&gt;max) { max = D[i][j]; } } return max;}void Floyd(){ int i,j,k; for( i=1; i&lt;=Nv; i++) { for( j=1; j&lt;=Nv; j++) { D[i][j] = G[i][j]; } } //注意动物是从下标1开始编号 for ( k=1; k&lt;=Nv; k++) { for( i=1; i&lt;=Nv; i++) { for( j=1; j&lt;=Nv; j++) { if( D[i][k]+D[k][j] &lt; D[i][j]) { D[i][j] = D[i][k]+D[k][j]; } } } }}","link":"/2018/05/06/shujiujiegou7-8/"},{"title":"习题10-1 判断满足条件的三位数（15 分）","text":"练习10-1 使用递归函数计算1到n之和（10 分）本题要求实现一个用递归计算$1+2+3+\\ldots+n$的和的简单函数。 函数接口定义：1int sum( int n ); 该函数对于传入的正整数n返回1+2+3+…+n的和；若n不是正整数则返回0。题目保证输入输出在长整型范围内。建议尝试写成递归函数。 裁判测试程序样例：123456789101112131415#include &lt;stdio.h&gt;int sum( int n );int main(){ int n; scanf(\"%d\", &amp;n); printf (\"%d\\n\", sum(n)); return 0;}/* 你的代码将被嵌在这里 */ 输入样例1：110 输出样例1：155 输入样例2：10 输出样例2：10 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;stdio.h&gt;#include &lt;math.h&gt;int search( int n );int main(){ int number; scanf(\"%d\",&amp;number); printf(\"count=%d\\n\",search(number)); return 0;}int search(int n){ int i, count, min, max, square, first, second, third; if (n &lt; 121) { count = 0; return count; } min = sqrt(121); max = sqrt(n); for (i = min, count = 0; i &lt;= max; i++) { square = i*i; first = square % 10; second = square / 10 % 10; third = square / 100; if (first == second || first == third || second == third) count++; } return count;}","link":"/2018/02/08/siti10-1/"},{"title":"习题10-4 递归求简单交错幂级数的部分和（15 分）","text":"习题10-4 递归求简单交错幂级数的部分和（15 分）本题要求实现一个函数，计算下列简单交错幂级数的部分和： $f(x, n)=x-x^{2}+x^{3}-x^{4}+\\cdots+(-1)^{n-1} x^{n}$ 函数接口定义：1double fn( double x, int n ); 其中题目保证传入的n是正整数，并且输入输出都在双精度范围内。函数fn应返回上述级数的部分和。建议尝试用递归实现。 裁判测试程序样例：12345678910111213141516#include &lt;stdio.h&gt;double fn( double x, int n );int main(){ double x; int n; scanf(\"%lf %d\", &amp;x, &amp;n); printf(\"%.2f\\n\", fn(x,n)); return 0;}/* 你的代码将被嵌在这里 */ 输入样例：10.5 12 输出样例：10.33 123456789101112131415161718192021222324#include &lt;stdio.h&gt;double fn( double x, int n );int main(){ double x; int n; scanf(\"%lf %d\", &amp;x, &amp;n); printf(\"%.2f\\n\", fn(x,n)); return 0;}double fn(double x, int n){ double result; if (n == 0 || n == 1) result = x; else result = x - x*fn(x, n-1); return result;}","link":"/2018/02/08/siti10-4/"},{"title":"习题10-3 递归实现指数函数（15 分）","text":"习题10-3 递归实现指数函数（15 分）本题要求实现一个计算$x^n（n \\geq 1）$的函数。 函数接口定义：1double calc_pow( double x, int n ); 函数calc_pow应返回x的n次幂的值。建议用递归实现。题目保证结果在双精度范围内。 裁判测试程序样例：12345678910111213141516#include &lt;stdio.h&gt;double calc_pow( double x, int n );int main(){ double x; int n; scanf(\"%lf %d\", &amp;x, &amp;n); printf(\"%.0f\\n\", calc_pow(x, n)); return 0;}/* 你的代码将被嵌在这里 */ 输入样例：12 3 输出样例：18 1234567891011121314151617181920212223242526#include &lt;stdio.h&gt;double calc_pow( double x, int n );int main(){ double x; int n; scanf(\"%lf %d\", &amp;x, &amp;n); printf(\"%.0f\\n\", calc_pow(x, n)); return 0;}double calc_pow(double x, int n){ double result; if (n == 0) result = 1; else result = x*calc_pow(x, n-1); return result;}","link":"/2018/02/08/siti10-3/"},{"title":"习题10-6 递归求Fabonacci数列（10 分）","text":"习题10-6 递归求Fabonacci数列（10 分）本题要求实现求Fabonacci数列项的函数。Fabonacci数列的定义如下： $f(n)=f(n−2)+f(n−1) (n\\ge2)$，其中$f(0)=0，f(1)=1$。 函数接口定义：1int f( int n ); 函数f应返回第n个Fabonacci数。题目保证输入输出在长整型范围内。建议用递归实现。 裁判测试程序样例：123456789101112131415#include &lt;stdio.h&gt;int f( int n );int main(){ int n; scanf(\"%d\", &amp;n); printf(\"%d\\n\", f(n)); return 0;}/* 你的代码将被嵌在这里 */ 输入样例：16 输出样例：18 12345678910111213141516171819202122232425#include &lt;stdio.h&gt;int f( int n );int main(){ int n; scanf(\"%d\", &amp;n); printf(\"%d\\n\", f(n)); return 0;}int f(int n){ int result; if (n == 0) result = 0; else if (n == 1) result = 1; else result = f(n-2) + f(n-1); return result;}","link":"/2018/02/08/siti10-6/"},{"title":"习题10-5 递归计算Ackermenn函数（15 分）","text":"习题10-5 递归计算Ackermenn函数（15 分）本题要求实现Ackermenn函数的计算，其函数定义如下：$$\\operatorname{ack}(m, n)=\\begin{cases}n+1, &amp; m = 0 \\\\\\\\\\operatorname{ack}(m-1, 1), &amp; n=0 \\&amp; \\&amp; m\\gt0 \\\\\\\\\\operatorname{ack}(m-1, \\operatorname{ack}(m, n-1)),&amp; m \\gt0 \\&amp; \\&amp; n\\gt 0\\end{cases}$$ 函数接口定义：1int Ack( int m, int n ); 其中m和n是用户传入的非负整数。函数Ack返回Ackermenn函数的相应值。题目保证输入输出都在长整型 范围内。 裁判测试程序样例：123456789101112131415#include &lt;stdio.h&gt;int Ack( int m, int n );int main(){ int m, n; scanf(\"%d %d\", &amp;m, &amp;n); printf(\"%d\\n\", Ack(m, n)); return 0;}/* 你的代码将被嵌在这里 */ 输入样例：12 3 输出样例：19 12345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;int Ack( int m, int n );int main(){ int m, n; scanf(\"%d %d\", &amp;m, &amp;n); printf(\"%d\\n\", Ack(m, n)); return 0;}int Ack(int m, int n){ int result; if (m == 0) result = n+1; else { if (n == 0) result = Ack(m - 1, 1); else result = Ack(m-1, Ack(m, n-1)); } return result;}","link":"/2018/02/08/siti10-5/"},{"title":"习题10-7 十进制转换二进制（15 分）","text":"习题10-7 十进制转换二进制（15 分）本题要求实现一个函数，将正整数n转换为二进制后输出。 函数接口定义：1void dectobin( int n ); 函数dectobin应在一行中打印出二进制的n。建议用递归实现。 裁判测试程序样例：123456789101112131415#include &lt;stdio.h&gt;void dectobin( int n );int main(){ int n; scanf(\"%d\", &amp;n); dectobin(n); return 0;}/* 你的代码将被嵌在这里 */ 输入样例：110 输出样例：11010 1234567891011121314151617181920212223242526#include &lt;stdio.h&gt;void dectobin( int n );int main(){ int n; scanf(\"%d\", &amp;n); dectobin(n); return 0;}void dectobin(int n){ if (n == 0) printf(\"0\"); else if (n == 1) printf(\"1\"); else { dectobin(n/2); printf(\"%d\", n%2); }}","link":"/2018/02/08/siti10-7/"},{"title":"习题10-8 递归实现顺序输出整数（15 分）","text":"习题10-8 递归实现顺序输出整数（15 分）本题要求实现一个函数，对一个整数进行按位顺序输出。 函数接口定义：1void printdigits( int n ); 函数printdigits应将n的每一位数字从高位到低位顺序打印出来，每位数字占一行。 裁判测试程序样例：123456789101112131415#include &lt;stdio.h&gt;void printdigits( int n );int main(){ int n; scanf(\"%d\", &amp;n); printdigits(n); return 0;}/* 你的代码将被嵌在这里 */ 输入样例：112345 输出样例：1234512345 123456789101112131415161718192021222324#include &lt;stdio.h&gt;void printdigits( int n );int main(){ int n; scanf(\"%d\", &amp;n); printdigits(n); return 0;} void printdigits(int num){ if (num &lt;= 9) printf(\"%d\\n\", num); else { printdigits(num / 10); printf(\"%d\\n\", num % 10); }}","link":"/2018/02/08/siti10-8/"},{"title":"习题11-1 输出月份英文名（15 分）","text":"习题11-1 输出月份英文名（15 分）本题要求实现函数，可以返回一个给定月份的英文名称。 函数接口定义：1char *getmonth( int n ); 函数getmonth应返回存储了n对应的月份英文名称的字符串头指针。如果传入的参数n不是一个代表月份的数字，则返回空指针NULL。 裁判测试程序样例：123456789101112131415161718#include &lt;stdio.h&gt;char *getmonth( int n );int main(){ int n; char *s; scanf(\"%d\", &amp;n); s = getmonth(n); if ( s==NULL ) printf(\"wrong input!\\n\"); else printf(\"%s\\n\", s); return 0;}/* 你的代码将被嵌在这里 */ 输入样例1：15 输出样例1：1May 输入样例2：115 输出样例2：1wrong input! 123456789101112131415161718192021222324#include &lt;stdio.h&gt;char *getmonth( int n );int main(){ int n; char *s; scanf(\"%d\", &amp;n); s = getmonth(n); if ( s==NULL ) printf(\"wrong input!\\n\"); else printf(\"%s\\n\", s); return 0;}char *getmonth(int n){ char *s[] = {\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"}; if(n&lt;=0||n&gt;12) return NULL; else return(s[n-1]) }","link":"/2018/02/09/siti11-1/"},{"title":"习题11-3 计算最长的字符串长度（15 分）","text":"习题11-3 计算最长的字符串长度（15 分）本题要求实现一个函数，用于计算有n个元素的指针数组s中最长的字符串的长度。 函数接口定义：1int max_len( char *s[], int n ); 其中n个字符串存储在s[]中，函数max_len应返回其中最长字符串的长度。 裁判测试程序样例：12345678910111213141516171819202122232425#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#define MAXN 10#define MAXS 20int max_len( char *s[], int n );int main(){ int i, n; char *string[MAXN] = {NULL}; scanf(\"%d\", &amp;n); for(i = 0; i &lt; n; i++) { string[i] = (char *)malloc(sizeof(char)*MAXS); scanf(\"%s\", string[i]); } printf(\"%d\\n\", max_len(string, n)); return 0;}/* 你的代码将被嵌在这里 */ 输入样例：123454blueyellowredgreen 输出样例：16 12345678910111213141516171819202122232425262728293031323334#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#define MAXN 10#define MAXS 20int max_len( char *s[], int n );int main(){ int i, n; char *string[MAXN] = {NULL}; scanf(\"%d\", &amp;n); for(i = 0; i &lt; n; i++) { string[i] = (char *)malloc(sizeof(char)*MAXS); scanf(\"%s\", string[i]); } printf(\"%d\\n\", max_len(string, n)); return 0;}int max_len(char *s[], int n){ int m=0,i,l; for (i=0; i&lt;n; i++) { l=strlen(s[i]); if(m&lt;l) m=l; } return m;}","link":"/2018/02/09/siti11-3/"},{"title":"习题11-2 查找星期（15 分）","text":"习题11-2 查找星期（15 分）本题要求实现函数，可以根据下表查找到星期，返回对应的序号。 序号 星期 0 Sunday 1 Monday 2 Tuesday 3 Wednesday 4 Thursday 5 Friday 6 Saturday 函数接口定义：1int getindex( char *s ); 函数getindex应返回字符串s序号。如果传入的参数s不是一个代表星期的字符串，则返回-1。 裁判测试程序样例：123456789101112131415161718192021#include &lt;stdio.h&gt;#include &lt;string.h&gt;#define MAXS 80int getindex( char *s );int main(){ int n; char s[MAXS]; scanf(\"%s\", s); n = getindex(s); if ( n==-1 ) printf(\"wrong input!\\n\"); else printf(\"%d\\n\", n); return 0;}/* 你的代码将被嵌在这里 */ 输入样例1：1Tuesday 输出样例1：12 输入样例2：1today 输出样例2：1wrong input! 1234567891011121314151617181920212223242526272829303132333435#include &lt;stdio.h&gt;#include &lt;string.h&gt;#define MAXS 80int getindex( char *s );int main(){ int n; char s[MAXS]; scanf(\"%s\", s); n = getindex(s); if ( n==-1 ) printf(\"wrong input!\\n\"); else printf(\"%d\\n\", n); return 0;}int getindex(char *s){ char a[7][MAXS] = {\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"}; int i; for (i=0; i&lt;7; i++) { if (strcmp(a[i],s) == 0) { return i; } } if(i=7) return -1;}","link":"/2018/02/09/siti11-2/"},{"title":"习题11-8 单链表结点删除（20 分）","text":"习题11-8 单链表结点删除（20 分）本题要求实现两个函数，分别将读入的数据存储为单链表、将链表中所有存储了某给定值的结点删除。链表结点定义如下： 1234struct ListNode { int data; ListNode *next;}; 函数接口定义：12struct ListNode *readlist();struct ListNode *deletem( struct ListNode *L, int m ); 函数readlist从标准输入读入一系列正整数，按照读入顺序建立单链表。当读到−1时表示输入结束，函数应返回指向单链表头结点的指针。 函数deletem将单链表L中所有存储了m的结点删除。返回指向结果链表头结点的指针。 裁判测试程序样例：1234567891011121314151617181920212223242526272829303132#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;struct ListNode { int data; struct ListNode *next;};struct ListNode *readlist();struct ListNode *deletem( struct ListNode *L, int m );void printlist( struct ListNode *L ){ struct ListNode *p = L; while (p) { printf(\"%d \", p-&gt;data); p = p-&gt;next; } printf(\"\\n\");}int main(){ int m; struct ListNode *L = readlist(); scanf(\"%d\", &amp;m); L = deletem(L, m); printlist(L); return 0;}/* 你的代码将被嵌在这里 */ 输入样例：1210 11 10 12 10 -110 输出样例：111 12 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;struct ListNode { int data; struct ListNode *next;};struct ListNode *readlist();struct ListNode *deletem( struct ListNode *L, int m );void printlist( struct ListNode *L ){ struct ListNode *p = L; while (p) { printf(\"%d \", p-&gt;data); p = p-&gt;next; } printf(\"\\n\");}int main(){ int m; struct ListNode *L = readlist(); scanf(\"%d\", &amp;m); L = deletem(L, m); printlist(L); return 0;}void PushBack(int X, struct ListNode **rear){ struct ListNode *TmpCell; TmpCell = malloc(sizeof(struct ListNode)); TmpCell-&gt;data = X; TmpCell-&gt;next = NULL; (*rear)-&gt;next = TmpCell; *rear = TmpCell;}struct ListNode *readlist(){ struct ListNode *TmpCell, *head, *tail; int data; head = tail = malloc(sizeof(struct ListNode)); head-&gt;next = NULL; scanf(\"%d\", &amp;data); while (data != -1) { PushBack(data, &amp;tail); scanf(\"%d\", &amp;data); } TmpCell = head; head = head-&gt;next; free(TmpCell); return head;}struct ListNode *deletem(struct ListNode *L, int m){ struct ListNode *head, *p, *TmpCell; p = head = malloc(sizeof(struct ListNode)); head-&gt;next = NULL; p-&gt;next = L; while (p-&gt;next != NULL) { if (p-&gt;next-&gt;data == m) { TmpCell = p-&gt;next; p-&gt;next = TmpCell-&gt;next; free(TmpCell); } else p = p-&gt;next; } TmpCell = head; head = head-&gt;next; free(TmpCell); return head;}","link":"/2018/02/09/siti11-8/"},{"title":"习题11-6 查找子串（20 分）","text":"习题11-6 查找子串（20 分）本题要求实现一个字符串查找的简单函数。 函数接口定义：1char *search( char *s, char *t ); 函数search在字符串s中查找子串t，返回子串t在s中的首地址。若未找到，则返回NULL。 裁判测试程序样例：12345678910111213141516171819202122#include &lt;stdio.h&gt;#define MAXS 30char *search(char *s, char *t);void ReadString( char s[] ); /* 裁判提供，细节不表 */int main(){ char s[MAXS], t[MAXS], *pos; ReadString(s); ReadString(t); pos = search(s, t); if ( pos != NULL ) printf(\"%d\\n\", pos - s); else printf(\"-1\\n\"); return 0;}/* 你的代码将被嵌在这里 */ 输入样例1：12The C Programming Languageram 输出样例1：110 输入样例2：12The C Programming Languagebored 输出样例2：1-1 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;stdio.h&gt;#define MAXS 30char *search(char *s, char *t);void ReadString( char s[] ); /* 裁判提供，细节不表 */int main(){ char s[MAXS], t[MAXS], *pos; ReadString(s); ReadString(t); pos = search(s, t); if ( pos != NULL ) printf(\"%d\\n\", pos - s); else printf(\"-1\\n\"); return 0;}void ReadString(char s[]){ gets(s);}char *search(char *s, char *t){ int i, j, sLen, tLen; for (i=0; s[i]!='\\0'; i++); sLen=i; for (j=0; t[j]!='\\0'; j++); tLen=j; i=j=0; while (i &lt; sLen &amp;&amp; j &lt; tLen) { if (s[i] == t[j]) { i++; j++; } else { i = i - j + 1; j = 0; } } if (j == tLen) return &amp;s[i - j]; else return NULL;}","link":"/2018/02/09/siti11-6/"},{"title":"习题11-7 奇数值结点链表（20 分）","text":"习题11-7 奇数值结点链表（20 分）本题要求实现两个函数，分别将读入的数据存储为单链表、将链表中奇数值的结点重新组成一个新的链表。链表结点定义如下： 1234struct ListNode { int data; ListNode *next;}; 函数接口定义：12struct ListNode *readlist();struct ListNode *getodd( struct ListNode **L ); 函数readlist从标准输入读入一系列正整数，按照读入顺序建立单链表。当读到−1时表示输入结束，函数应返回指向单链表头结点的指针。 函数getodd将单链表L中奇数值的结点分离出来，重新组成一个新的链表。返回指向新链表头结点的指针，同时将L中存储的地址改为删除了奇数值结点后的链表的头结点地址（所以要传入L的指针）。 裁判测试程序样例：1234567891011121314151617181920212223242526272829303132#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;struct ListNode { int data; struct ListNode *next;};struct ListNode *readlist();struct ListNode *getodd( struct ListNode **L );void printlist( struct ListNode *L ){ struct ListNode *p = L; while (p) { printf(\"%d \", p-&gt;data); p = p-&gt;next; } printf(\"\\n\");}int main(){ struct ListNode *L, *Odd; L = readlist(); Odd = getodd(&amp;L); printlist(Odd); printlist(L); return 0;}/* 你的代码将被嵌在这里 */ 输入样例：11 2 2 3 4 5 6 7 -1 输出样例：121 3 5 7 2 2 4 6 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;struct ListNode { int data; struct ListNode *next;};struct ListNode *readlist();struct ListNode *getodd( struct ListNode **L );void printlist( struct ListNode *L ){ struct ListNode *p = L; while (p) { printf(\"%d \", p-&gt;data); p = p-&gt;next; } printf(\"\\n\");}int main(){ struct ListNode *L, *Odd; L = readlist(); Odd = getodd(&amp;L); printlist(Odd); printlist(L); return 0;}void PushBack(int X, struct ListNode **rear){ struct ListNode *TmpCell; TmpCell = malloc(sizeof(struct ListNode)); TmpCell-&gt;data = X; TmpCell-&gt;next = NULL; (*rear)-&gt;next = TmpCell; *rear = TmpCell;}struct ListNode *readlist(){ struct ListNode *TmpCell, *head, *tail; int data; head = tail = malloc(sizeof(struct ListNode)); head-&gt;next = NULL; scanf(\"%d\", &amp;data); while (data != -1) { PushBack(data, &amp;tail); scanf(\"%d\", &amp;data); } TmpCell = head; head = head-&gt;next; free(TmpCell); return head;}struct ListNode *getodd(struct ListNode **L){ struct ListNode *head, *p, *oddhead, *oddtail, *TmpCell; p = head = malloc(sizeof(struct ListNode)); head-&gt;next = NULL; oddhead = oddtail = malloc(sizeof(struct ListNode)); oddhead-&gt;next = NULL; p-&gt;next = *L; while (p-&gt;next != NULL) { if (p-&gt;next-&gt;data % 2 != 0) { PushBack(p-&gt;next-&gt;data, &amp;oddtail); TmpCell = p-&gt;next; p-&gt;next = TmpCell-&gt;next; free(TmpCell); } else p = p-&gt;next; } TmpCell = head; head = head-&gt;next; free(TmpCell); *L = head; TmpCell = oddhead; oddhead = oddhead-&gt;next; free(TmpCell); return oddhead;}","link":"/2018/02/09/siti11-7/"},{"title":"习题2-1 求整数均值（10 分）","text":"习题2-1 求整数均值（10 分）本题要求编写程序，计算4个整数的和与平均值。题目保证输入与输出均在整型范围内。 输入格式:输入在一行中给出4个整数，其间以空格分隔。 输出格式:在一行中按照格式“Sum = 和; Average = 平均值”顺序输出和与平均值，其中平均值精确到小数点后一位。 输入样例:11 2 3 4 输出样例:1Sum = 10; Average = 2.5 1234567891011#include&lt;stdio.h&gt; int main(void) { int a,b,c,d,S; float A; scanf(\"%d%d%d%d\",&amp;a,&amp;b,&amp;c,&amp;d); S=(a+b+c+d); A=(a+b+c+d)/4.0; printf(\"Sum = %d; Average = %.1f\",S,A); return 0; }","link":"/2018/01/16/siti2-1/"},{"title":"习题2-4 求交错序列前N项和（15 分）","text":"习题2-4 求交错序列前N项和（15 分）本题要求编写程序，计算交错序列 $1-\\frac{2}{3}+\\frac{3}{5}-\\frac{4}{7}+\\frac{5}{9}-\\frac{6}{11}+\\cdots$ 的前N项之和。 输入格式:输入在一行中给出一个正整数N。 输出格式:在一行中输出部分和的值，结果保留三位小数。 输入样例:15 输出样例:10.917 1234567891011121314#include&lt;stdio.h&gt; int main(void) { int N,i,fm,flag; double s=0,item; scanf(\"%d\",&amp;N); fm=1; flag=1; for(i=1;i&lt;=N;i++) { item=flag*i*1.0/fm; s=s+item; flag=-flag; fm=fm+2; } printf(\"%.3lf\",s); return 0; }","link":"/2018/01/19/siti2-4/"},{"title":"习题11-5 指定位置输出字符串（20 分）","text":"习题11-5 指定位置输出字符串（20 分）本题要求实现一个函数，对给定的一个字符串和两个字符，打印出给定字符串中从与第一个字符匹配的位置开始到与第二个字符匹配的位置之间的所有字符。 函数接口定义：1char *match( char *s, char ch1, char ch2 ); 函数match应打印s中从ch1到ch2之间的所有字符，并且返回ch1的地址。 裁判测试程序样例：12345678910111213141516171819#include &lt;stdio.h&gt;#define MAXS 10char *match( char *s, char ch1, char ch2 );int main(){ char str[MAXS], ch_start, ch_end, *p; scanf(\"%s\\n\", str); scanf(\"%c %c\", &amp;ch_start, &amp;ch_end); p = match(str, ch_start, ch_end); printf(\"%s\\n\", p); return 0;}/* 你的代码将被嵌在这里 */ 输入样例1：12programr g 输出样例1：12rogrogram 输入样例2：12programz o 输出样例2：12(空行)(空行) 输入样例3：12programg z 输出样例3：12gramgram 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;stdio.h&gt;#define MAXS 10char *match( char *s, char ch1, char ch2 );int main(){ char str[MAXS], ch_start, ch_end, *p; scanf(\"%s\\n\", str); scanf(\"%c %c\", &amp;ch_start, &amp;ch_end); p = match(str, ch_start, ch_end); printf(\"%s\\n\", p); return 0;}char *match(char *s, char ch1, char ch2){ int i, ch1index, ch2index, flag; char *p, ch = '\\0'; flag = 0; ch1index = ch2index = 0; for (i=0; s[i] != '\\0'; i++) { if (s[i] == ch1) { ch1index = i; flag = 1; break; } } if (!flag) { printf(\"\\n\"); p = &amp;ch; return p; } for (; s[i] != '\\0'; i++) { if (s[i] == ch2) { ch2index = i; flag = 0; break; } } for (i=ch1index; i&lt;=ch2index; i++) printf(\"%c\", s[i]); if(flag) { for (i=ch1index; s[i] != '\\0'; i++) printf(\"%c\", s[i]); } printf(\"\\n\"); p = &amp;s[ch1index]; return p;}","link":"/2018/02/09/siti11-5/"},{"title":"习题2-5 求平方根序列前N项和（15 分）","text":"习题2-5 求平方根序列前N项和（15 分）本题要求编写程序，计算平方根序列$\\sqrt1+\\sqrt2+\\sqrt3+\\cdots$的前N项之和。可包含头文件math.h，并调用sqrt函数求平方根。 输入格式:输入在一行中给出一个正整数N。 输出格式:在一行中按照“sum = S”的格式输出部分和的值S，精确到小数点后两位。题目保证计算结果不超过双精度范围。 输入样例:110 输出样例:1sum = 22.47 12345678910111213#include&lt;stdio.h&gt; #include&lt;math.h&gt; int main(void) { int N,i; double s=0,a; scanf(\"%d\",&amp;N); for(i=1;i&lt;=N;i++) { a=sqrt(i); s=s+a; } printf(\"sum = %.2f\",s); return 0; }","link":"/2018/01/19/siti2-5/"},{"title":"习题11-4 字符串的连接（15 分）","text":"习题11-4 字符串的连接（15 分）本题要求实现一个函数，将两个字符串连接起来。 函数接口定义：1char *str_cat( char *s, char *t ); 函数str_cat应将字符串t复制到字符串s的末端，并且返回字符串s的首地址。 裁判测试程序样例：1234567891011121314151617181920#include &lt;stdio.h&gt;#include &lt;string.h&gt;#define MAXS 10char *str_cat( char *s, char *t );int main(){ char *p; char str1[MAXS+MAXS] = {'\\0'}, str2[MAXS] = {'\\0'}; scanf(\"%s%s\", str1, str2); p = str_cat(str1, str2); printf(\"%s\\n%s\\n\", p, str1); return 0;}/* 你的代码将被嵌在这里 */ 输入样例：12abcdef 输出样例：12abcdefabcdef 12345678910111213141516171819202122232425#include &lt;stdio.h&gt;#include &lt;string.h&gt;#define MAXS 10char *str_cat( char *s, char *t );int main(){ char *p; char str1[MAXS+MAXS] = {'\\0'}, str2[MAXS] = {'\\0'}; scanf(\"%s%s\", str1, str2); p = str_cat(str1, str2); printf(\"%s\\n%s\\n\", p, str1); return 0;}char *str_cat( char *s, char *t ){ char *p; p=strcat(s,t); return p;}","link":"/2018/02/09/siti11-4/"},{"title":"习题2-2 阶梯电价（15 分）","text":"习题2-2 阶梯电价（15 分）为了提倡居民节约用电，某省电力公司执行“阶梯电价”，安装一户一表的居民用户电价分为两个“阶梯”：月用电量50千瓦时（含50千瓦时）以内的，电价为0.53元/千瓦时；超过50千瓦时的，超出部分的用电量，电价上调0.05元/千瓦时。请编写程序计算电费。 输入格式:输入在一行中给出某用户的月用电量（单位：千瓦时）。 输出格式:在一行中输出该用户应支付的电费（元），结果保留两位小数，格式如：“cost = 应付电费值”；若用电量小于0，则输出”Invalid Value!”。 输入样例1:110 输出样例1:1cost = 5.30 输入样例2:1100 输出样例2:1cost = 55.50 12345678910111213141516#include&lt;stdio.h&gt; int main(void) { float x,c; scanf(\"%f\",&amp;x); if(x&gt;=0){ if(x&lt;=50){ c=0.53*x; }else{ c=0.53*50+(x-50)*0.58; printf(\"cost = %.2f\",c); } }else{ printf(\"Invalid Value!\"); } return 0; }","link":"/2018/01/16/siti2-2/"},{"title":"习题2-3 求平方与倒数序列的部分和（15 分）","text":"习题2-3 求平方与倒数序列的部分和（15 分）本题要求对两个正整数m和n$（m \\le n）$编写程序，计算序列和$m^2+\\frac{1}{m}+(m+1)^2+\\frac{1}{(m+1)}+\\cdots+n^2+\\frac{1}{n}$。 输入格式:输入在一行中给出两个正整数$m$和$n（m \\leq n）$，其间以空格分开。 输出格式:在一行中按照“sum = S”的格式输出部分和的值S，精确到小数点后六位。题目保证计算结果不超过双精度范围。 输入样例:15 10 输出样例:1sum = 355.845635 123456789101112131415#include&lt;stdio.h&gt; int main(void) { int N,i,fm,M; double s=0,item; scanf(\"%d%d\",&amp;M,&amp;N); fm=M; for(i=M;i&lt;=N;i++) { item=fm*fm+1.0/fm; s=s+item; fm=fm+1; } printf(\"sum = %.6lf\",s); return 0; }","link":"/2018/01/16/siti2-3/"},{"title":"习题2-6 求阶乘序列前N项和（15 分）","text":"习题2-6 求阶乘序列前N项和（15 分）本题要求编写程序，计算序列 $1!+2!+3!+\\cdots $的前N项之和。 输入格式:输入在一行中给出一个不超过12的正整数N。 输出格式:在一行中输出整数结果。 输入样例:15 输出样例:1153 1234567891011121314151617181920212223#include&lt;stdio.h&gt; double fact(int n);int main(void) { double result,s=0; int n,i; scanf(\"%d\",&amp;n); for(i=1;i&lt;=n;i++){ result=fact(i); s=s+result; }printf(\"%.0f\",s); return 0;}double fact(int n){ double total = 0; if (n == 0){ total = 1; }else{ total = n * fact(n - 1); } return total;}","link":"/2018/01/21/siti2-6/"},{"title":"习题3-1 比较大小（10 分）","text":"习题3-1 比较大小（10 分）本题要求将输入的任意3个整数从小到大输出。 输入格式:输入在一行中给出3个整数，其间以空格分隔。 输出格式:在一行中将3个整数从小到大输出，其间以“-&gt;”相连。 输入样例:14 2 8 输出样例:12-&gt;4-&gt;8 1234567891011121314151617#include&lt;stdio.h&gt;int main(void){ int a,b,c,t; scanf(\"%d %d %d\",&amp;a,&amp;b,&amp;c); if(a&lt;b){ t=b;b=a;a=t; }; if(a&lt;c){ t=c;c=a;a=t; }; if(b&lt;c){ t=c;c=b;b=t; }; printf(\"%d-&gt;%d-&gt;%d\",c,b,a); return 0;}","link":"/2018/01/22/siti3-1/"},{"title":"习题3-3 出租车计价（15 分）","text":"习题3-3 出租车计价（15 分）本题要求根据某城市普通出租车收费标准编写程序进行车费计算。具体标准如下： 起步里程为3公里，起步费10元； 超起步里程后10公里内，每公里2元； 超过10公里以上的部分加收50%的回空补贴费，即每公里3元； 营运过程中，因路阻及乘客要求临时停车的，按每5分钟2元计收（不足5分钟则不收费）。 输入格式:输入在一行中给出输入行驶里程（单位为公里，精确到小数点后1位）与等待时间（整数，单位为分钟），其间以空格分隔。 输出格式:在一行中输出乘客应支付的车费（单位为元），结果四舍五入，保留到元。 输入样例1:12.6 2 输出样例1:110 输入样例2:15.1 4 输出样例2:114 输入样例3:112.5 9 输出样例3:134 12345678910111213#include&lt;stdio.h&gt;int main(){ int time; double mileage,fee; scanf(\"%lf %d\",&amp;mileage,&amp;time); if(mileage&lt;=3) fee=10; else if(mileage&gt;3&amp;&amp;mileage&lt;=10) fee=10+(mileage-3)*2; else fee=24+(mileage-10)*3; fee=fee+(time/5)*2; printf(\"%.0f\",fee); return 0;}","link":"/2018/01/22/siti3-3/"},{"title":"习题3-4 统计学生成绩（15 分）","text":"习题3-4 统计学生成绩（15 分）本题要求编写程序读入N个学生的百分制成绩，统计五分制成绩的分布。百分制成绩到五分制成绩的转换规则： 大于等于90分为A； 小于90且大于等于80为B； 小于80且大于等于70为C； 小于70且大于等于60为D； 小于60为E。 输入格式:输入在第一行中给出一个正整数N（≤1000），即学生人数；第二行中给出N个学生的百分制成绩，其间以空格分隔。 输出格式:在一行中输出A、B、C、D、E对应的五分制成绩的人数分布，数字间以空格分隔，行末不得有多余空格。 输入样例:12777 54 92 73 60 65 69 输出样例:11 0 2 3 1 123456789101112131415161718192021222324252627#include&lt;stdio.h&gt; int main(){ int n,i,A,B,C,D,N,E; scanf(\"%d\\n\",&amp;n); A=B=C=D=E=0; for(i=1;i&lt;=n;i++){ scanf(\"%d\",&amp;N); if(N&gt;=90){ A++; } else if(N&gt;=80){ B++; } else if(N&gt;=70){ C++; } else if (N&gt;=60){ D++; } else{ E++; } } printf(\"%d %d %d %d %d\",A,B,C,D,E); return 0; } }","link":"/2018/01/22/siti3-4/"},{"title":"习题3-2 高速公路超速处罚（15 分）","text":"习题3-2 高速公路超速处罚（15 分）按照规定，在高速公路上行使的机动车，达到或超出本车道限速的10%则处200元罚款；若达到或超出50%，就要吊销驾驶证。请编写程序根据车速和限速自动判别对该机动车的处理。 输入格式:输入在一行中给出2个正整数，分别对应车速和限速，其间以空格分隔。 输出格式:在一行中输出处理意见：若属于正常行驶，则输出“OK”；若应处罚款，则输出“Exceed x%. Ticket 200”；若应吊销驾驶证，则输出“Exceed x%. License Revoked”。其中x是超速的百分比，精确到整数。 输入样例1:165 60 输出样例1:1OK 输入样例2:1110 100 输出样例2:1Exceed 10%. Ticket 200 输入样例3:1200 120 输出样例3:1Exceed 67%. License Revoked 12345678910111213#include &lt;stdio.h&gt; int main(void) { int m,n; double z; scanf(\"%d%d\",&amp;m,&amp;n); z=(m-n)*100.0/n; if(z&lt;10) printf(\"OK\\n\"); else if(z&lt;50) printf(\"Exceed %.0f%%. Ticket 200\\n\",z); else printf(\"Exceed %.0f%%. License Revoked\\n\",z); return 0;}","link":"/2018/01/22/siti3-2/"},{"title":"习题3-5 三角形判断（15 分）","text":"习题3-5 三角形判断（15 分）给定平面上任意三个点的坐标$(x_1,y_1)、(x_2,y_2)、(x_3,y_3)$，检验它们能否构成三角形。 输入格式:输入在一行中顺序给出六个[−100,100]范围内的数字，即三个点的坐标$x_1、y_1、x_2、y_2、x_3、y_3$。 输出格式:若这3个点不能构成三角形，则在一行中输出“Impossible”；若可以，则在一行中输出该三角形的周长和面积，格式为“L = 周长, A = 面积”，输出到小数点后2位。 输入样例1:14 5 6 9 7 8 输出样例1:1L = 10.13, A = 3.00 输入样例2:14 6 8 12 12 18 输出样例2:1Impossible 12345678910111213141516171819#include &lt;stdio.h&gt; int main(void) { double x1, y1, x2, y2, x3, y3; double side1, side2, side3; double p, perimeter, area; scanf(\"%lf%lf%lf%lf%lf%lf\", &amp;x1, &amp;y1, &amp;x2, &amp;y2, &amp;x3, &amp;y3); side1 = sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1)); side2 = sqrt((x3 - x1) * (x3 - x1) + (y3 - y1) * (y3 - y1)); side3 = sqrt((x3 - x2) * (x3 - x2) + (y3 - y2) * (y3 - y2)); if(side1 + side2 &gt; side3 &amp;&amp; side1 + side3 &gt; side2 &amp;&amp; side2 + side3 &gt; side1) { perimeter = side1 + side2 + side3; p = 0.5 * perimeter; area = sqrt(p * (p - side1) * (p - side2) * (p - side3)); printf(\"L = %.2f, A = %.2f\\n\", perimeter, area); } else printf(\"Impossible\"); return 0; }","link":"/2018/01/22/siti3-5/"},{"title":"习题4-1 求奇数和（15 分）","text":"习题4-1 求奇数和（15 分）本题要求计算给定的一系列正整数中奇数的和。 输入格式:输入在一行中给出一系列正整数，其间以空格分隔。当读到零或负整数时，表示输入结束，该数字不要处理。 输出格式:在一行中输出正整数序列中奇数的和。 输入样例:18 7 4 3 70 5 6 101 -1 输出样例:1116 123456789101112#include &lt;stdio.h&gt; int main(void) { int n,z; z=0; scanf(\"%d\",&amp;n); while(n&gt;0) { if(n%2!=0) z=z+n; scanf(\"%d\",&amp;n); } printf(\"%d\",z);return 0; }","link":"/2018/01/22/siti4-1/"},{"title":"习题4-10 猴子吃桃问题（15 分）","text":"习题4-10 猴子吃桃问题（15 分）一只猴子第一天摘下若干个桃子，当即吃了一半，还不过瘾，又多吃了一个；第二天早上又将剩下的桃子吃掉一半，又多吃了一个。以后每天早上都吃了前一天剩下的一半加一个。到第$N$天早上想再吃时，见只剩下一个桃子了。问：第一天共摘了多少个桃子？ 输入格式:输入在一行中给出正整数$N（1\\lt N \\leq 10）$。 输出格式:在一行中输出第一天共摘了多少个桃子。 输入样例:13 输出样例:110 123456789101112131415161718#include &lt;stdio.h&gt; int main(){ int n, sum=1; scanf(\"%d\", &amp;n); while(n&gt;1){//共吃了n-1天，还有一天没吃 // printf(\"第 %d 天， 还剩 %d 桃\\n\", n, sum); sum = (sum+1)*2; n--; } printf(\"%d\",sum); return 0; }","link":"/2018/01/22/siti4-10/"},{"title":"习题4-11 兔子繁衍问题（15 分）","text":"习题4-11 兔子繁衍问题（15 分）一对兔子，从出生后第3个月起每个月都生一对兔子。小兔子长到第3个月后每个月又生一对兔子。假如兔子都不死，请问第1个月出生的一对兔子，至少需要繁衍到第几个月时兔子总数才可以达到N对？ 输入格式:输入在一行中给出一个不超过10000的正整数N。 输出格式:在一行中输出兔子总数达到N最少需要的月数。 输入样例:130 输出样例:19 123456789101112131415161718192021222324#include&lt;stdio.h&gt;int main(void){ int N; int month=1; int sum=1; int now=0,pre=0; scanf(\"%d\",&amp;N); if(N==sum){ printf(\"%d\\n\",month); }else{ month++; now=pre+sum; while(now&lt;N){ month++; pre=sum; sum=now; now=pre+sum; } printf(\"%d\\n\",month); } return 0;}","link":"/2018/01/22/siti4-11/"},{"title":"习题4-3 求分数序列前N项和（15 分）","text":"习题4-3 求分数序列前N项和（15 分）本题要求编写程序，计算序列$ \\frac{2}{1}+\\frac{3}{2}+\\frac{5}{3}+\\frac{8}{5}+\\cdots$ 的前N项之和。注意该序列从第2项起，每一项的分子是前一项分子与分母的和，分母是前一项的分子。 输入格式:输入在一行中给出一个正整数N。 输出格式:在一行中输出部分和的值，精确到小数点后两位。题目保证计算结果不超过双精度范围。 输入样例:120 输出样例:132.66 12345678910111213141516#include&lt;stdio.h&gt; int main() { double n,z,m,i,t; double item,sum; sum=0;m=1;z=2; scanf(\"%lf\",&amp;n); for(i=1;i&lt;=n;i++){ item=1.0*z/m; sum=sum+item; t=z; z=z+m; m=t; } printf(\"%.2f\",sum); return 0; }","link":"/2018/01/22/siti4-3/"},{"title":"习题4-2 求幂级数展开的部分和（20 分）","text":"习题4-2 求幂级数展开的部分和（20 分）已知函数ex可以展开为幂级数$1+x+\\frac{x^2}{2!}+\\frac{x^3}{3!}+\\cdots+\\frac{x^k}{k!}+\\cdots$。现给定一个实数x，要求利用此幂级数部分和求ex的近似值，求和一直继续到最后一项的绝对值小于0.00001。 输入格式:输入在一行中给出一个实数$x \\in(0,5)$。 输出格式:在一行中输出满足条件的幂级数部分和，保留小数点后四位。 输入样例:11.2 输出样例:13.3201 1234567891011121314151617181920#include &lt;stdio.h&gt;#include &lt;math.h&gt;#define eps 1e-5 //0.00001int main(){ double x, sum = 1.0; scanf(\"%lf\", &amp;x); double result = 1.0; int i; for (i = 1; ; i++) { result = (result * x) / i; sum += result; if (result &lt; eps) { break; } } printf(\"%.4f\", sum); return 0;}","link":"/2018/01/22/siti4-2/"},{"title":"习题4-5 换硬币（20 分）","text":"习题4-5 换硬币（20 分）将一笔零钱换成5分、2分和1分的硬币，要求每种硬币至少有一枚，有几种不同的换法？ 输入格式:输入在一行中给出待换的零钱数额$x \\in(8,100)$。 输出格式:要求按5分、2分和1分硬币的数量依次从大到小的顺序，输出各种换法。每行输出一种换法，格式为：“fen5:5分硬币数量, fen2:2分硬币数量, fen1:1分硬币数量, total:硬币总数量”。最后一行输出“count = 换法个数”。 输入样例:113 输出样例:12345fen5:2, fen2:1, fen1:1, total:4fen5:1, fen2:3, fen1:2, total:6fen5:1, fen2:2, fen1:4, total:7fen5:1, fen2:1, fen1:6, total:8count = 4 1234567891011121314151617#include&lt;stdio.h&gt; int main(){ int x,i,j,k,a,b,c,count=0; scanf(\"%d\",&amp;x); for(i=x/5;i&gt;=1;i--){ for(j=x/2;j&gt;=1;j--){ for(k=x;k&gt;=1;k--){ if(5*i+2*j+k==x){ printf(\"fen5:%d, fen2:%d, fen1:%d, total:%d\\n\",i,j,k,i+j+k); count++; } } } } printf(\"count = %d\",count); return 0;}","link":"/2018/01/22/siti4-5/"},{"title":"习题4-4 特殊a串数列求和（20 分）","text":"习题4-4 特殊a串数列求和（20 分）给定两个均不超过9的正整数a和n，要求编写程序求$a+aa+aaa++⋯+aa⋯a$（n个a）之和。 输入格式：输入在一行中给出不超过9的正整数a和n。 输出格式：在一行中按照“s = 对应的和”的格式输出。 输入样例：12 3 输出样例：1s = 246 123456789101112#include&lt;stdio.h&gt; int main() { int a,n,sum,i,t; t=sum=0; scanf(\"%d%d\",&amp;a,&amp;n); for(i=1;i&lt;=n;i++){ t=t*10+a; sum+=t; } printf(\"s = %d\",sum); return 0; }","link":"/2018/01/22/siti4-4/"},{"title":"习题4-7 最大公约数和最小公倍数（15 分）","text":"习题4-7 最大公约数和最小公倍数（15 分）本题要求两个给定正整数的最大公约数和最小公倍数。 输入格式:输入在一行中给出两个正整数$M$和$N（\\leq 1000）$。 输出格式:在一行中顺序输出M和N的最大公约数和最小公倍数，两数字间以1空格分隔。 输入样例:1511 292 输出样例:173 2044 12345678910111213#include &lt;stdio.h&gt;#include&lt;math.h&gt; int main() { int m,n,gb,gy; scanf(\"%d%d\",&amp;m,&amp;n); gb=m; while(gb%n!=0){ gb=gb+m; } gy=(m*n)/gb; printf(\"%d %d\",gy,gb); return 0; }","link":"/2018/01/22/siti4-7/"},{"title":"习题4-8 高空坠球（20 分）","text":"习题4-8 高空坠球（20 分）皮球从某给定高度自由落下，触地后反弹到原高度的一半，再落下，再反弹，……，如此反复。问皮球在第n次落地时，在空中一共经过多少距离？第n次反弹的高度是多少？ 输入格式:输入在一行中给出两个非负整数，分别是皮球的初始高度和n，均在长整型范围内。 输出格式:在一行中顺序输出皮球第n次落地时在空中经过的距离、以及第n次反弹的高度，其间以一个空格分隔，保留一位小数。题目保证计算结果不超过双精度范围。 输入样例:133 5 输出样例:194.9 1.0 12345678910111213141516171819#include&lt;stdio.h&gt; int main() { int m,n,i; double x,y,z; scanf(\"%d%d\",&amp;m,&amp;n); y=0,z=m;i=1; while(i&lt;=n){ x=0.5*z; y=y+x+z; z=x; i++; } y=y-z; if(n==0) printf(\"0.0 0.0\"); else printf(\"%.1f %.1f\",y,z); return 0; }","link":"/2018/01/22/siti4-8/"},{"title":"习题4-6 水仙花数（20 分）","text":"习题4-6 水仙花数（20 分）水仙花数是指一个N位正整数$（N \\geq 3）$，它的每个位上的数字的N次幂之和等于它本身。例如：$153=13+53+33$。 本题要求编写程序,计算所有N位水仙花数。 输入格式:输入在一行中给出一个正整数$N（3\\leq N\\leq 7）$。 输出格式:按递增顺序输出所有N位水仙花数，每个数字占一行。 输入样例:13 输出样例:1234153370371407 1234567891011121314151617181920212223242526#include&lt;stdio.h&gt; #include&lt;math.h&gt;int main(void) { int n, a, i, m, k, j; scanf(\"%d\", &amp;n); if(n==7){ printf(\"1741725\\n\"); printf(\"4210818\\n\"); printf(\"9800817\\n\"); printf(\"9926315\\n\"); }else{ for(i=pow(10,n-1); i&lt;pow(10,n);i++){ m=i; a=0; for(k=1;k&lt;=n;k++){ j=m%10; m=m/10; a=a+pow(j,n); } if(a==i){ printf(\"%d\\n\", a); } } } return 0; }","link":"/2018/01/22/siti4-6/"},{"title":"习题5-1 符号函数（10 分）","text":"习题5-1 符号函数（10 分）本题要求实现符号函数sign(x)。 函数接口定义：1int sign( int x ); 其中x是用户传入的整型参数。符号函数的定义为：若x大于0，sign(x) = 1；若x等于0，sign(x) = 0；否则，sign(x) = −1。 裁判测试程序样例：123456789101112131415#include &lt;stdio.h&gt;int sign( int x );int main(){ int x; scanf(\"%d\", &amp;x); printf(\"sign(%d) = %d\\n\", x, sign(x)); return 0;}/* 你的代码将被嵌在这里 */ 输入样例：110 输出样例：1sign(10) = 1 123456789101112131415161718192021222324#include &lt;stdio.h&gt;int sign( int x );int main(){ int x; scanf(\"%d\", &amp;x); printf(\"sign(%d) = %d\\n\", x, sign(x)); return 0;}int sign( int x ){ int f; if(x&gt;0){ f=1; } else if(x==0){ f=0; }else f=-1; return f; }","link":"/2018/01/24/siti5-1/"},{"title":"习题4-9 打印菱形图案（15 分）","text":"习题4-9 打印菱形图案（15 分）本题要求编写程序，打印一个高度为n的、由“*”组成的正菱形图案。 输入格式:输入在一行中给出一个正的奇数n。 输出格式:输出由n行星号“*”组成的菱形，如样例所示。每个星号后跟一个空格。 输入样例:17 输出样例:1234567 * * * * * * * * * * * * * * * * * * * * * * * * * 12345678910111213141516171819202122232425262728293031#include &lt;stdio.h&gt; int main(){ int i,j,k,l,n,m; printf(\"输入奇数：\\n\"); scanf(\"%d\", &amp;n); for(k=0,m=1,j=n;k&lt;=n/2;k++,j-=2,m+=2){ for(i=j;i&gt;0;i--) printf(\" \"); for(l=m;l&gt;0;l--) printf(\"* \"); printf(\"\\n\"); } for(k=n/2+1,j=3,m=n-2;k&lt;n;k++,j+=2,m-=2){ for(i=j;i&gt;0;i--) printf(\" \"); for(l=m;l&gt;0;l--) printf(\"* \"); printf(\"\\n\"); } return 0; }","link":"/2018/01/22/siti4-9/"},{"title":"习题5-3 使用函数计算两点间的距离（10 分）","text":"习题5-3 使用函数计算两点间的距离（10 分）本题要求实现一个函数，对给定平面任意两点坐标$(x_1,y_1)$和$(x_2,y_2)$，求这两点之间的距离。 函数接口定义：1double dist( double x1, double y1, double x2, double y2 ); 其中用户传入的参数为平面上两个点的坐标$(x_1, y_1)$和$(x_2, y_2)$，函数dist应返回两点间的距离。 裁判测试程序样例：12345678910111213141516#include &lt;stdio.h&gt;#include &lt;math.h&gt;double dist( double x1, double y1, double x2, double y2 );int main(){ double x1, y1, x2, y2; scanf(\"%lf %lf %lf %lf\", &amp;x1, &amp;y1, &amp;x2, &amp;y2); printf(\"dist = %.2f\\n\", dist(x1, y1, x2, y2)); return 0;}/* 你的代码将被嵌在这里 */ 输入样例：110 10 200 100 输出样例：1dist = 210.24 1234567891011121314151617181920#include &lt;stdio.h&gt;#include &lt;math.h&gt;double dist( double x1, double y1, double x2, double y2 );int main(){ double x1, y1, x2, y2; scanf(\"%lf %lf %lf %lf\", &amp;x1, &amp;y1, &amp;x2, &amp;y2); printf(\"dist = %.2f\\n\", dist(x1, y1, x2, y2)); return 0;}double dist( double x1, double y1, double x2, double y2 ){ double f; f=sqrt(pow(x2-x1,2)+pow(y2-y1,2)); return f; }","link":"/2018/01/24/siti5-3/"},{"title":"习题5-4 使用函数求素数和（20 分）","text":"习题5-4 使用函数求素数和（20 分）本题要求实现一个判断素数的简单函数、以及利用该函数计算给定区间内素数和的函数。 素数就是只能被1和自身整除的正整数。注意：1不是素数，2是素数。 函数接口定义：12int prime( int p );int PrimeSum( int m, int n ); 其中函数prime当用户传入参数p为素数时返回1，否则返回0；函数PrimeSum返回区间[m, n]内所有素数的和。题目保证用户传入的参数$m \\le n$。 裁判测试程序样例：12345678910111213141516171819202122#include &lt;stdio.h&gt;#include &lt;math.h&gt;int prime( int p );int PrimeSum( int m, int n );int main(){ int m, n, p; scanf(\"%d %d\", &amp;m, &amp;n); printf(\"Sum of ( \"); for( p=m; p&lt;=n; p++ ) { if( prime(p) != 0 ) printf(\"%d \", p); } printf(\") = %d\\n\", PrimeSum(m, n)); return 0;}/* 你的代码将被嵌在这里 */ 输入样例：1-1 10 输出样例：1Sum of ( 2 3 5 7 ) = 17 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;stdio.h&gt;#include &lt;math.h&gt;int prime( int p );int PrimeSum( int m, int n );int main(){ int m, n, p; scanf(\"%d %d\", &amp;m, &amp;n); printf(\"Sum of ( \"); for( p=m; p&lt;=n; p++ ) { if( prime(p) != 0 ) printf(\"%d \", p); } printf(\") = %d\\n\", PrimeSum(m, n)); return 0;}int prime( int p ) { int i; int k; if(p&gt;=2) { k=sqrt(p); for(i=2;i&lt;=k;i++) { if(p%i==0) break;} if(i&gt;k) return 1; else return 0; }else return 0; } int PrimeSum( int m, int n ) { int i,z,sum=0; int k; for(z=m;z&lt;=n;z++) if(prime(z)==1) sum=sum+z; return sum;}","link":"/2018/01/24/siti5-4/"},{"title":"习题5-2 使用函数求奇数和（15 分）","text":"习题5-2 使用函数求奇数和（15 分）本题要求实现一个函数，计算N个整数中所有奇数的和，同时实现一个判断奇偶性的函数。 函数接口定义：12int even( int n );int OddSum( int List[], int N ); 其中函数even将根据用户传入的参数n的奇偶性返回相应值：当n为偶数时返回1，否则返回0。函数OddSum负责计算并返回传入的N个整数List[]中所有奇数的和。 裁判测试程序样例：123456789101112131415161718192021222324#include &lt;stdio.h&gt;#define MAXN 10int even( int n );int OddSum( int List[], int N );int main(){ int List[MAXN], N, i; scanf(\"%d\", &amp;N); printf(\"Sum of ( \"); for ( i=0; i&lt;N; i++ ) { scanf(\"%d\", &amp;List[i]); if ( even(List[i])==0 ) printf(\"%d \", List[i]); } printf(\") = %d\\n\", OddSum(List, N)); return 0;}/* 你的代码将被嵌在这里 */ 输入样例：1262 -3 7 88 0 15 输出样例：1Sum of ( -3 7 15 ) = 19 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;stdio.h&gt;#define MAXN 10int even( int n );int OddSum( int List[], int N );int main(){ int List[MAXN], N, i; scanf(\"%d\", &amp;N); printf(\"Sum of ( \"); for ( i=0; i&lt;N; i++ ) { scanf(\"%d\", &amp;List[i]); if ( even(List[i])==0 ) printf(\"%d \", List[i]); } printf(\") = %d\\n\", OddSum(List, N)); return 0;}int even( int n ) { if(n%2==0) { return 1; }else { return 0; } } int OddSum( int List[], int N ) { int i,sum=0; for(i=0;i&lt;N;i++) { if(List[i]%2!=0) { sum=sum+List[i]; } } return sum; }","link":"/2018/01/24/siti5-2/"},{"title":"习题5-5 使用函数统计指定数字的个数（15 分）","text":"习题5-5 使用函数统计指定数字的个数（15 分）本题要求实现一个统计整数中指定数字的个数的简单函数。 函数接口定义：1int CountDigit( int number, int digit ); 其中number是不超过长整型的整数，digit为[0, 9]区间内的整数。函数CountDigit应返回number中digit出现的次数。 裁判测试程序样例：123456789101112131415#include &lt;stdio.h&gt;int CountDigit( int number, int digit );int main(){ int number, digit; scanf(\"%d %d\", &amp;number, &amp;digit); printf(\"Number of digit %d in %d: %d\\n\", digit, number, CountDigit(number, digit)); return 0;}/* 你的代码将被嵌在这里 */ 输入样例：1-21252 2 输出样例：1Number of digit 2 in -21252: 3 123456789101112131415161718192021222324252627282930#include &lt;stdio.h&gt;int CountDigit( int number, int digit );int main(){ int number, digit; scanf(\"%d %d\", &amp;number, &amp;digit); printf(\"Number of digit %d in %d: %d\\n\", digit, number, CountDigit(number, digit)); return 0;}int CountDigit( int number, int digit ) { int z, i= 0; if (number &lt; 0) number = -number; if (number == 0 &amp;&amp; digit == 0) i ++; else do{ z = number % 10; number=number/10; if (z==digit){ i ++; } } while(number!=0); return i; }","link":"/2018/01/24/siti5-5/"},{"title":"习题5-6 使用函数输出水仙花数（20 分）","text":"习题5-6 使用函数输出水仙花数（20 分）水仙花数是指一个N位正整数$（N \\geq 3）$，它的每个位上的数字的N次幂之和等于它本身。例如：$153=13+53+33$。 本题要求编写两个函数，一个判断给定整数是否水仙花数，另一个按从小到大的顺序打印出给定区间(m,n)内所有的水仙花数。 函数接口定义：12int narcissistic( int number );void PrintN( int m, int n ); 函数narcissistic判断number是否为水仙花数，是则返回1，否则返回0。 函数PrintN则打印开区间(m, n)内所有的水仙花数，每个数字占一行。题目保证100≤m≤n≤10000。 裁判测试程序样例：123456789101112131415161718#include &lt;stdio.h&gt;int narcissistic( int number );void PrintN( int m, int n );int main(){ int m, n; scanf(\"%d %d\", &amp;m, &amp;n); if ( narcissistic(m) ) printf(\"%d is a narcissistic number\\n\", m); PrintN(m, n); if ( narcissistic(n) ) printf(\"%d is a narcissistic number\\n\", n); return 0;}/* 你的代码将被嵌在这里 */ 输入样例：1153 400 输出样例：123153 is a narcissistic number370371 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;stdio.h&gt;#include&lt;math.h&gt;int narcissistic( int number );void PrintN( int m, int n );int main(){ int m, n; scanf(\"%d %d\", &amp;m, &amp;n); if ( narcissistic(m) ) printf(\"%d is a narcissistic number\\n\", m); PrintN(m, n); if ( narcissistic(n) ) printf(\"%d is a narcissistic number\\n\", n); return 0;}int narcissistic( int number ) { int i=0,k,sum=0,s; int a[999]; s=number; do { i++; a[i]=number%10; number=number/10; } while(number!=0); k=i; do { sum=sum+pow(a[i],k); i--; } while(i&gt;0); if(sum==s) return 1; else return 0; } void PrintN( int m, int n ) { int i,k,z; for(i=m+1;i&lt;n;i++) if(narcissistic(i)==1) printf(\"%d\\n\",i); }","link":"/2018/01/24/siti5-6/"},{"title":"习题5-7 使用函数求余弦函数的近似值（15 分）","text":"习题5-7 使用函数求余弦函数的近似值（15 分）本题要求实现一个函数，用下列公式求cos(x)的近似值，精确到最后一项的绝对值小于e： $cos(x)=\\frac{x^0}{0!}−\\frac{x^2}{2!}+\\frac{x^4}{4!}−\\frac{x^6}{6!}+\\cdots$ 函数接口定义：1double funcos( double e, double x ); 其中用户传入的参数为误差上限e和自变量x；函数funcos应返回用给定公式计算出来、并且满足误差要求的cos(x)的近似值。输入输出均在双精度范围内。 裁判测试程序样例：12345678910111213141516#include &lt;stdio.h&gt;#include &lt;math.h&gt;double funcos( double e, double x );int main(){ double e, x; scanf(\"%lf %lf\", &amp;e, &amp;x); printf(\"cos(%.2f) = %.6f\\n\", x, funcos(e, x)); return 0;}/* 你的代码将被嵌在这里 */ 输入样例：10.01 -3.14 输出样例：1cos(-3.14) = -0.999899 1234567891011121314151617181920212223242526272829#include &lt;stdio.h&gt;#include &lt;math.h&gt;double funcos( double e, double x );int main(){ double e, x; scanf(\"%lf %lf\", &amp;e, &amp;x); printf(\"cos(%.2f) = %.6f\\n\", x, funcos(e, x)); return 0;}double funcos( double e, double x ){ double i=0,m=0,k=1,n=1; double sum=0,d; do{ d=pow(x,i)/n; sum=sum+k*d; k=-k; i+=2; m=m+2; n=n*m*(m-1); } while(fabs(d)&gt;e); return sum; }","link":"/2018/01/24/siti5-7/"},{"title":"习题6-2 使用函数求特殊a串数列和（20 分）","text":"习题6-2 使用函数求特殊a串数列和（20 分）给定两个均不超过9的正整数a和n，要求编写函数求$a+aa+aaa++⋯+aa⋯a$（n个a）之和。 函数接口定义：12int fn( int a, int n );int SumA( int a, int n ); 其中函数fn须返回的是n个a组成的数字；SumA返回要求的和。 裁判测试程序样例：1234567891011121314151617#include &lt;stdio.h&gt;int fn( int a, int n );int SumA( int a, int n ); int main(){ int a, n; scanf(\"%d %d\", &amp;a, &amp;n); printf(\"fn(%d, %d) = %d\\n\", a, n, fn(a,n)); printf(\"s = %d\\n\", SumA(a,n)); return 0;}/* 你的代码将被嵌在这里 */ 输入样例：12 3 输出样例：12fn(2, 3) = 222s = 246 123456789101112131415161718192021222324252627282930313233343536#include &lt;stdio.h&gt;#include&lt;math.h&gt;int fn( int a, int n );int SumA( int a, int n );int main(){ int a, n; scanf(\"%d %d\", &amp;a, &amp;n); printf(\"fn(%d, %d) = %d\\n\", a, n, fn(a,n)); printf(\"s = %d\\n\", SumA(a,n)); return 0;}int fn( int a, int n ){int sum=0,i,b=1;for(i=0;i&lt;n;i++){//b=b*10;sum=sum+a*b;b=b*10;}return sum;}int SumA( int a, int n ){int sum1=0,sum2,i;for(i=1;i&lt;n+1;i++){sum2=fn(a,i);sum1=sum1+sum2;}return sum1;}","link":"/2018/01/24/siti6-2/"},{"title":"习题6-1 分类统计字符个数（15 分）","text":"习题6-1 分类统计字符个数（15 分）本题要求实现一个函数，统计给定字符串中英文字母、空格或回车、数字字符和其他字符的个数。 函数接口定义：1void StringCount( char s[] ); 其中 char s[] 是用户传入的字符串。函数StringCount须在一行内按照 1letter = 英文字母个数, blank = 空格或回车个数, digit = 数字字符个数, other = 其他字符个数 的格式输出。 裁判测试程序样例：1234567891011121314151617#include &lt;stdio.h&gt;#define MAXS 15void StringCount( char s[] );void ReadString( char s[] ); /* 由裁判实现，略去不表 */int main(){ char s[MAXS]; ReadString(s); StringCount(s); return 0;}/* Your function will be put here */ 输入样例：12aZ &amp;09 Az 输出样例：1letter = 4, blank = 3, digit = 2, other = 1 123456789101112131415161718192021222324252627282930313233#include &lt;stdio.h&gt;#define MAXS 15void StringCount( char s[] );void ReadString( char s[] ); /* 由裁判实现，略去不表 */int main(){ char s[MAXS]; ReadString(s); StringCount(s); return 0;}void ReadString(char s[]){ gets(s);}void StringCount(char s[]){ int letter=0,blank=0,digit=0,other=0; int i; for(i=0;s[i]!='\\0';i++){ if(s[i]&gt;='A'&amp;&amp;s[i]&lt;='Z'||s[i]&gt;='a'&amp;&amp;s[i]&lt;='z'){ letter++; }else if(s[i]==' '||s[i]=='\\n'){ blank++; }else if(s[i]&gt;='0'&amp;&amp;s[i]&lt;='9'){ digit++; }else other++; } printf(\"letter = %d,blank = %d,digit = %d, other = %d\\n\",letter,blank,digit,other);}","link":"/2018/01/24/siti6-1/"},{"title":"习题6-3 使用函数输出指定范围内的完数（20 分）","text":"习题6-3 使用函数输出指定范围内的完数（20 分）本题要求实现一个计算整数因子和的简单函数，并利用其实现另一个函数，输出两正整数$m$$和n（0&lt;m≤n≤10000）$之间的所有完数。所谓完数就是该数恰好等于除自身外的因子之和。例如：$6=1+2+3$，其中1、2、3为6的因子。 函数接口定义：12int factorsum( int number );void PrintPN( int m, int n ); 其中函数factorsum须返回int number的因子和；函数PrintPN要逐行输出给定范围[m, n]内每个完数的因子累加形式的分解式，每个完数占一行，格式为“完数 = 因子1 + 因子2 + … + 因子k”，其中完数和因子均按递增顺序给出。如果给定区间内没有完数，则输出一行“No perfect number”。 裁判测试程序样例：123456789101112131415161718#include &lt;stdio.h&gt;int factorsum( int number );void PrintPN( int m, int n ); int main(){ int i, m, n; scanf(\"%d %d\", &amp;m, &amp;n); if ( factorsum(m) == m ) printf(\"%d is a perfect number\\n\", m); if ( factorsum(n) == n ) printf(\"%d is a perfect number\\n\", n); PrintPN(m, n); return 0;}/* 你的代码将被嵌在这里 */ 输入样例1：11 30 输出样例1：12341 is a perfect number1 = 16 = 1 + 2 + 328 = 1 + 2 + 4 + 7 + 14 输入样例2：17 25 输出样例2：1No perfect number 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;stdio.h&gt;#define N 100int factorsum( int number );void PrintPN( int m, int n ); int main(){ int i, m, n; scanf(\"%d %d\", &amp;m, &amp;n); if ( factorsum(m) == m ) printf(\"%d is a perfect number\\n\", m); if ( factorsum(n) == n ) printf(\"%d is a perfect number\\n\", n); PrintPN(m, n); return 0;}int factorsum( int number ){ int a[N],i,j=0,n=0,sum=0; if(number == 1) return 1; for(i=1;i&lt;number;i++) if(number%i==0){ a[j++]=i; } for(i=0;i&lt;j;i++) sum+=a[i]; if(sum == number) return 1; return 0; } void PrintPN( int m, int n ){ int i,j,k=0,l,a[N]; if(m==1){ printf(\"%d = %d\\n\",m , m); m+=1; } for(i=m;i&lt;=n;i++){ if(factorsum(i)==1){ for(j=1;j&lt;i;j++){ if(i%j==0){ a[k++]=j; } } printf(\"%d = \", i); for(l=0;l&lt;k-1;l++) printf(\"%d + \", a[l]); printf(\"%d\\n\", a[l]); k=0; } } } }","link":"/2018/01/24/siti6-3/"},{"title":"习题6-5 使用函数验证哥德巴赫猜想（20 分）","text":"习题6-5 使用函数验证哥德巴赫猜想（20 分）本题要求实现一个判断素数的简单函数，并利用该函数验证哥德巴赫猜想：任何一个不小于6的偶数均可表示为两个奇素数之和。素数就是只能被1和自身整除的正整数。注意：1不是素数，2是素数。 函数接口定义：12int prime( int p );void Goldbach( int n ); 其中函数prime当用户传入参数p为素数时返回1，否则返回0；函数Goldbach按照格式“n=p+q”输出n的素数分解，其中p≤q均为素数。又因为这样的分解不唯一（例如24可以分解为5+19，还可以分解为7+17），要求必须输出所有解中p最小的解。 裁判测试程序样例：1234567891011121314151617181920212223242526#include &lt;stdio.h&gt;#include &lt;math.h&gt;int prime( int p );void Goldbach( int n );int main(){ int m, n, i, cnt; scanf(\"%d %d\", &amp;m, &amp;n); if ( prime(m) != 0 ) printf(\"%d is a prime number\\n\", m); if ( m &lt; 6 ) m = 6; if ( m%2 ) m++; cnt = 0; for( i=m; i&lt;=n; i+=2 ) { Goldbach(i); cnt++; if ( cnt%5 ) printf(\", \"); else printf(\"\\n\"); } return 0;}/* 你的代码将被嵌在这里 */ 输入样例：189 100 输出样例：12389 is a prime number90=7+83, 92=3+89, 94=5+89, 96=7+89, 98=19+79100=3+97, 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;stdio.h&gt;#include &lt;math.h&gt;int prime( int p );void Goldbach( int n );int main() { int m, n, i, cnt; scanf(\"%d %d\", &amp;m, &amp;n); if ( prime(m) != 0 ) printf(\"%d is a prime number\\n\", m); if ( m &lt; 6 ) m = 6; if ( m%2 ) m++; cnt = 0; for( i=m; i&lt;=n; i+=2 ) { Goldbach(i); cnt++; if ( cnt%5 ) printf(\", \"); else printf(\"\\n\"); } return 0;}int prime( int p ) { int i,count=0; for(i=2; i&lt;p; i++) { if(p%i==0) { count++; } } if(count==0&amp;&amp;p!=1) { return 1; } else { return 0; }}void Goldbach( int n ) { int i,k; if(prime(n) == 0) { for(i=2; i&lt;n; i++) { if(prime(i)!=0) { k=n-i; if(prime(k)!=0) { printf(\"%d=%d+%d\",n,i,k); break; } } } }}","link":"/2018/01/24/siti6-5/"},{"title":"习题6-4 使用函数输出指定范围内的Fibonacci数（20 分）","text":"习题6-4 使用函数输出指定范围内的Fibonacci数（20 分）本题要求实现一个计算Fibonacci数的简单函数，并利用其实现另一个函数，输出两正整数$m$和$n（0\\lt m \\leq n \\leq 10000）$之间的所有Fibonacci数。所谓Fibonacci数列就是满足任一项数字是前两项的和（最开始两项均定义为1）的数列。 函数接口定义：12int fib( int n );void PrintFN( int m, int n ); 其中函数fib须返回第n项Fibonacci数；函数PrintFN要在一行中输出给定范围[m, n]内的所有Fibonacci数，相邻数字间有一个空格，行末不得有多余空格。如果给定区间内没有Fibonacci数，则输出一行“No Fibonacci number”。 裁判测试程序样例：1234567891011121314151617#include &lt;stdio.h&gt;int fib( int n );void PrintFN( int m, int n ); int main(){ int m, n, t; scanf(\"%d %d %d\", &amp;m, &amp;n, &amp;t); printf(\"fib(%d) = %d\\n\", t, fib(t)); PrintFN(m, n); return 0;}/* 你的代码将被嵌在这里 */ 输入样例1：120 100 7 输出样例1：12fib(7) = 1321 34 55 89 输入样例2：12000 2500 8 输出样例2：12fib(8) = 21No Fibonacci number 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;stdio.h&gt;int fib( int n );void PrintFN( int m, int n );int main(){ int m, n, t; scanf(\"%d %d %d\", &amp;m, &amp;n, &amp;t); printf(\"fib(%d) = %d\\n\", t, fib(t)); PrintFN(m, n); return 0;}int fib( int n ){if(n==1||n==2){return 1;}if(n&gt;2){return fib(n-1)+fib(n-2);}}void PrintFN( int m, int n ){int i=0,j,k=1,count=0;for(j=0;j&lt;=21;j++){ i++; if(fib(i)&gt;=m&amp;&amp;fib(i)&lt;=n){ count++; printf(\"%d \",fib(i));} }if(count==0){ printf(\"No Fibonacci number\");}}","link":"/2018/01/24/siti6-4/"},{"title":"习题6-7 简单计算器（20 分）","text":"习题6-7 简单计算器（20 分）模拟简单运算器的工作。假设计算器只能进行加减乘除运算，运算数和结果都是整数，四种运算符的优先级相同，按从左到右的顺序计算。 输入格式:输入在一行中给出一个四则运算算式，没有空格，且至少有一个操作数。遇等号”=”说明输入结束。 输出格式:在一行中输出算式的运算结果，或者如果除法分母为0或有非法运算符，则输出错误信息“ERROR”。 输入样例:11+2*10-10/2= 输出样例:110 1234567891011121314151617181920#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main(){ char a[1000]; gets(a); int m,i,j; m=strlen(a); if(a[0]==' ') j=0; else j=1; for(i=0;i&lt;m-1;i++) { if(a[i]==' ' &amp;&amp; a[i+1]!=' ') j++; } printf(\"%d\\n\",j); return 0; }","link":"/2017/11/30/siti6-7/"},{"title":"习题6-8 统计一行文本的单词个数（15 分）","text":"习题6-8 统计一行文本的单词个数（15 分）本题目要求编写程序统计一行字符中单词的个数。所谓“单词”是指连续不含空格的字符串，各单词之间用空格分隔，空格数可以是多个。 输入格式:输入给出一行字符。 输出格式:在一行中输出单词个数。 输入样例:1Let&apos;s go to room 209. 输出样例:15 1234567891011121314151617181920#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main(){ char a[1000]; gets(a); int m,i,j; m=strlen(a); if(a[0]==' ') j=0; else j=1; for(i=0;i&lt;m-1;i++) { if(a[i]==' ' &amp;&amp; a[i+1]!=' ') j++; } printf(\"%d\\n\",j); return 0; }","link":"/2017/11/30/siti6-8/"},{"title":"习题6-6 使用函数输出一个整数的逆序数（20 分）","text":"习题6-6 使用函数输出一个整数的逆序数（20 分）本题要求实现一个求整数的逆序数的简单函数。 函数接口定义：1int reverse( int number ); 其中函数reverse须返回用户传入的整型number的逆序数。 裁判测试程序样例：123456789101112131415#include &lt;stdio.h&gt;int reverse( int number );int main(){ int n; scanf(\"%d\", &amp;n); printf(\"%d\\n\", reverse(n)); return 0;}/* 你的代码将被嵌在这里 */ 输入样例：1-12340 输出样例：1-4321 1234567891011121314151617181920212223242526272829303132#include &lt;stdio.h&gt;int reverse( int number );int main(){ int n; scanf(\"%d\", &amp;n); printf(\"%d\\n\", reverse(n)); return 0;}/* -12340 -&gt; -4321 */int reverse( int number ){ int i=1,a,sum=0; if(number&lt;0){ number=-number; i=-1; } while(number){ a = number%10; sum = sum * 10 +a; number/=10; } sum*=i; return sum;}","link":"/2018/01/24/siti6-6/"},{"title":"习题7-2 求一批整数中出现最多的个位数字（20 分）","text":"习题7-2 求一批整数中出现最多的个位数字（20 分）给定一批整数，分析每个整数的每一位数字，求出现次数最多的个位数字。例如给定3个整数1234、2345、3456，其中出现最多次数的数字是3和4，均出现了3次。 输入格式：输入在第1行中给出正整数$N（\\leq 1000）$，在第二行中给出N个不超过整型范围的非负整数，数字间以空格分隔。 输出格式：在一行中按格式“M: n1 n2 …”输出，其中M是最大次数，n1、n2、……为出现次数最多的个位数字，按从小到大的顺序排列。数字间以空格分隔，但末尾不得有多余空格。 输入样例：1231234 2345 3456 输出样例：13: 3 4 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;stdio.h&gt;int main(){ int num[1000]; //输入正整数N int n; scanf(\"%d\",&amp;n); //输入N个正整数存入数组Num int i; for(i=0;i&lt;n;i++){ scanf(\"%d\",&amp;num[i]); } int count[10]={0};//0-9计数 int a,temp,mask ; for(i=0;i&lt;n;i++){ temp = num[i]; mask = 1; while(temp &gt; 9){ temp /= 10; mask *= 10; } while(mask&gt;0){ a = num[i] / mask; count[a]++; num[i] %= mask; mask /= 10; } } int max[10],nmax=0; int numOfMax=0; //遍历count[]，找出最大值，并且存入max[] max[0] = -1; for(i=0;i&lt;10;i++){ if(count[i] &gt; numOfMax){ nmax = 0; numOfMax = count[i]; max[nmax] = i; } else if(count[i] == numOfMax){ nmax++; max[nmax] = i; } } //输出 printf(\"%d:\",numOfMax); for(i=0;i&lt;=nmax;i++){ printf(\" %d\",max[i]); } return 0;}","link":"/2018/01/24/siti7-2/"},{"title":"习题7-4 求矩阵各行元素之和（15 分）","text":"习题7-4 求矩阵各行元素之和（15 分）本题要求编写程序，求一个给定的m×n矩阵各行元素之和。 输入格式：输入第一行给出两个正整数m和$n（1\\leq m,n\\leq 6）$。随后m行，每行给出n个整数，其间 以空格分隔。 输出格式：每行输出对应矩阵行元素之和。 输入样例：12343 26 31 -83 12 输出样例：1239-715 123456789101112131415161718#include&lt;stdio.h&gt; main() { int i,j,m,n,sum; printf(\"输入正整数m和n（1&lt;=m,n&lt;=6）:\"); scanf(\"%d%d\",&amp;m,&amp;n); int a[m][n]; printf(\"输入数:\\n\"); for(i=0;i&lt;m;i++) for(j=0;j&lt;n;j++) scanf(\"%d\",&amp;a[i][j]); for(i=0;i&lt;m;i++){ sum=0; for(j=0;j&lt;n;j++){ sum+=a[i][j]; } printf(\"第%d行的和为：%d\\n\",i+1,sum); } return 0; }","link":"/2018/01/24/siti7-4/"},{"title":"习题7-3 判断上三角矩阵（15 分）","text":"习题7-3 判断上三角矩阵（15 分）上三角矩阵指主对角线以下的元素都为0的矩阵；主对角线为从矩阵的左上角至右下角的连线。 本题要求编写程序，判断一个给定的方阵是否上三角矩阵。 输入格式：输入第一行给出一个正整数T，为待测矩阵的个数。接下来给出T个矩阵的信息：每个矩阵信息的第一行给出一个不超过10的正整数n。随后n行，每行给出n个整数，其间以空格分隔。 输出格式：每个矩阵的判断结果占一行。如果输入的矩阵是上三角矩阵，输出“YES”，否则输出“NO”。 输入样例：12345678231 2 30 4 50 0 621 0-8 2 输出样例：12YESNO 1234567891011121314151617181920212223242526272829#include&lt;stdio.h&gt;int main(){ int n; scanf(\"%d\",&amp;n); while (n--) { int flag=1; int i=0; int size=0; int num=0; scanf(\"%d\",&amp;size); for (i=0;i&lt;size*size;i++) { scanf(\"%d\",&amp;num); if ((i/size&gt;i%size)&amp;&amp;num!=0) flag=0; } printf(flag?\"Yes\\n\":\"No\\n\"); } return 0;}","link":"/2018/01/24/siti7-3/"},{"title":"习题7-1 选择法排序（20 分）","text":"习题7-1 选择法排序（20 分）本题要求将给定的n个整数从大到小排序后输出。 输入格式：输入第一行给出一个不超过10的正整数n。第二行给出n个整数，其间以空格分隔。 输出格式：在一行中输出从大到小有序的数列，相邻数字间有一个空格，行末不得有多余空格。 输入样例：1245 1 7 6 输出样例：17 6 5 1 123456789101112131415161718192021222324252627282930#include&lt;stdio.h&gt;int main(void){ int i,index,k,n,temp; int a[10]; scanf(\"%d\",&amp;n); for(i=0;i&lt;n;i++) scanf(\"%d\",&amp;a[i]); for(k=0;k&lt;n-1;k++) { index=k; for(i=k+1;i&lt;n;i++) if(a[i]&gt;a[index]){ index=i; } temp=a[index]; a[index]=a[k]; a[k]=temp; } for(i=0;i&lt;n;i++) printf(\"%d \",a[i]); putchar('\\n'); }","link":"/2018/01/24/siti7-1/"},{"title":"习题7-5 找鞍点（20 分）","text":"习题7-5 找鞍点（20 分）一个矩阵元素的“鞍点”是指该位置上的元素值在该行上最大、在该列上最小。 本题要求编写程序，求一个给定的n阶方阵的鞍点。 输入格式：输入第一行给出一个正整数$n（1\\leq n\\leq 6）$。随后n行，每行给出n个整数，其间以空格分隔。 输出格式：输出在一行中按照“行下标 列下标”（下标从0开始）的格式输出鞍点的位置。如果鞍点不存在，则输出“NONE”。题目保证给出的矩阵至多存在一个鞍点。 输入样例1：1234541 7 4 14 8 3 61 6 1 20 7 8 9 输出样例1：12 1 输入样例2：12321 74 1 输出样例2：1NONE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;stdio.h&gt;int main(){ int a[6][6];//定义二维数组 int n; scanf(\"%d\",&amp;n); int i,j; for(i=0; i&lt;n; i++) for(j=0; j&lt;n; j++) { scanf(\"%d\",&amp;a[i][j]); } int k=0,y=0,flag=1,p=0; if(n==1) printf(\"0 0\");//只有一个点时，一定是鞍点 else { for(i=0; i&lt;n; i++) { y=i; for(p=0; p&lt;n; p++) //找行最大值 { if(a[i][k]&lt;=a[i][p])//数组元素之间比较，若比a[i][k]大，则将数组列标赋给k { k=p; } } for(j=0; j&lt;n; j++)//判断是否为列最小值 { if(a[y][k]&gt;a[j][k])//若此行最大值不是列所在最小值，把小的行标赋给y { y=j; break; } } if(i==y)//行最大且列最小，判断条件行标不改变 { flag=0; break; } } if(flag==0) printf(\"%d %d\",i,k); else printf(\"NONE\"); } return 0;}","link":"/2018/01/24/siti7-5/"},{"title":"习题7-7 字符串替换（15 分）","text":"习题7-7 字符串替换（15 分）本题要求编写程序，将给定字符串中的大写英文字母按以下对应规则替换： 原字母 对应字母 A Z B Y C X D W … … X C Y B Z A 输入格式：输入在一行中给出一个不超过80个字符、并以回车结束的字符串。 输出格式：输出在一行中给出替换完成后的字符串。 输入样例：1Only the 11 CAPItaL LeTtERS are replaced. 输出样例：1Lnly the 11 XZKRtaO OeGtVIH are replaced. 123456789101112131415161718192021222324//字符串替换#include&lt;stdio.h&gt;int main(void){ int i=0; char str[80]; printf(\"Enter a string:\"); while((str[i]=getchar())!='\\n') i++; str[i]='\\0'; for(i=0;str[i]!='\\0';i++) { if(str[i]&gt;='A'&amp;&amp;str[i]&lt;='Z') str[i]=155-str[i]; } printf(\"After change:\"); for(i=0;str[i]!='\\0';i++) putchar(str[i]); printf(\"\\n\"); return 0;}","link":"/2018/01/24/siti7-7/"},{"title":"习题7-8 字符串转换成十进制整数（15 分）","text":"习题7-8 字符串转换成十进制整数（15 分）输入一个以#结束的字符串，本题要求滤去所有的非十六进制字符（不分大小写），组成一个新的表示十六进制数字的字符串，然后将其转换为十进制数后输出。如果在第一个十六进制字符之前存在字符“-”，则代表该数是负数。 输入格式：输入在一行中给出一个以#结束的非空字符串。 输出格式：在一行中输出转换后的十进制数。题目保证输出在长整型范围内。 输入样例：1+-P-xf4+-1!# 输出样例：1-3905 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;stdio.h&gt;int main(){ int i, j, flag; char hexad[100], str[100]; long number; i = 0; while ((str[i] = getchar()) != '#') i++; str[i] = '\\0'; flag = 0; for (i = 0; str[i] != '\\0'; i++) { if (str[i] == '-') { flag = 1; break; } else if ((str[i] &gt;= '0' &amp;&amp; str[i] &lt;= '9')) break; } if (flag) { hexad[0] = '-'; j = 1; } else j = 0; for (i = 0; str[i] != '\\0'; i++) { if ((str[i] &gt;= '0' &amp;&amp; str[i] &lt;= '9') || (str[i] &gt;= 'a' &amp;&amp; str[i] &lt;= 'f') || (str[i] &gt;= 'A' &amp;&amp; str[i] &lt;= 'F')) { hexad[j] = str[i]; j++; } } hexad[j] = '\\0'; number = 0; for (i = 0; hexad[i] != '\\0'; i++) { if (hexad[i] &gt;= '0' &amp;&amp; hexad[i] &lt;= '9') number = number*16 + hexad[i]-'0'; else if (hexad[i] &gt;= 'A' &amp;&amp; hexad[i] &lt;= 'F') number = number*16+hexad[i]-'A'+10; else if (hexad[i] &gt;= 'a' &amp;&amp; hexad[i] &lt;= 'f') number = number*16 + hexad[i]-'a'+10; } if (hexad[0] == '-' &amp;&amp; number &lt; 0xabcdef) number = -1*number; printf(\"%ld\\n\", number); return 0;}","link":"/2018/01/24/siti7-8/"},{"title":"习题7-6 统计大写辅音字母（15 分）","text":"习题7-6 统计大写辅音字母（15 分）英文辅音字母是除A、E、I、O、U以外的字母。本题要求编写程序，统计给定字符串中大写辅音字母的个数。 输入格式：输入在一行中给出一个不超过80个字符、并以回车结束的字符串。 输出格式：输出在一行中给出字符串中大写辅音字母的个数。 输入样例：1HELLO World! 输出样例：14 12345678910111213141516171819202122//统计大写辅音字母#include&lt;stdio.h&gt;int main(){ int i=0; char str[80]; while((str[i]=getchar())!='\\n') i++; str[i]='\\0'; int count=0; for(i=0;str[i]!='\\0';i++) { if(str[i]&gt;='A'&amp;&amp;str[i]&lt;='Z'&amp;&amp;str[i]!='A'&amp;&amp;str[i]!='E'&amp;&amp;str[i]!='I'&amp;&amp;str[i]!='O'&amp;&amp;str[i]!='U') { count++; } } printf(\"%d\",count); return 0;}","link":"/2018/01/24/siti7-6/"},{"title":"习题8-10 输出学生成绩（20 分）","text":"习题8-10 输出学生成绩（20 分）本题要求编写程序，根据输入学生的成绩，统计并输出学生的平均成绩、最高成绩和最低成绩。建议使用动态内存分配来实现。 输入格式：输入第一行首先给出一个正整数N，表示学生的个数。接下来一行给出N个学生的成绩，数字间以空格分隔。 输出格式：按照以下格式输出： 123average = 平均成绩max = 最高成绩min = 最低成绩 结果均保留两位小数。 输入样例：12385 90 95 输出样例：123average = 90.00max = 95.00min = 85.00 1234567891011121314151617181920212223242526#include &lt;stdlib.h&gt;int main(){ int n, sum, i, max, min, *p; double average; scanf(\"%d\", &amp;n); p = (int *) calloc(n,sizeof(int)); sum = 0; max = 0; min = 100; for (i=0; i&lt;n; i++) { scanf(\"%d\", p+i); sum = sum + *(p+i); if (max &lt;= *(p+i)) max = *(p+i); if (min &gt;= *(p+i)) min = *(p+i); } average = (double) sum/n; printf(\"average = %.2f\\nmax = %.2f\\nmin = %.2f\\n\", average, (double) max, (double) min); free(p); return 0;}","link":"/2018/02/06/siti8-10/"},{"title":"习题8-1 拆分实数的整数与小数部分（15 分）","text":"习题8-1 拆分实数的整数与小数部分（15 分）本题要求实现一个拆分实数的整数与小数部分的简单函数。 函数接口定义：1void splitfloat( float x, int *intpart, float *fracpart ); 其中x是被拆分的实数（0≤x&lt;10000），*intpart和*fracpart分别是将实数x拆分出来的整数部分与小数部分。 裁判测试程序样例：123456789101112131415161718#include &lt;stdio.h&gt;void splitfloat( float x, int *intpart, float *fracpart );int main(){ float x, fracpart; int intpart; scanf(\"%f\", &amp;x); splitfloat(x, &amp;intpart, &amp;fracpart); printf(\"The integer part is %d\\n\", intpart); printf(\"The fractional part is %g\\n\", fracpart); return 0;}/* 你的代码将被嵌在这里 */ 输入样例：12.718 输出样例：12The integer part is 2The fractional part is 0.718 1234567891011121314151617181920212223242526#include &lt;stdio.h&gt;void splitfloat( float x, int *intpart, float *fracpart );int main(){float x, fracpart;int intpart;scanf(\"%f\", &amp;x);splitfloat(x, &amp;intpart, &amp;fracpart);printf(\"The integer part is %d\\n\", intpart);printf(\"The fractional part is %g\\n\", fracpart);return 0;}void splitfloat(float x, int *intpart, float *fracpart) {if(x&lt;0) x=-x;*intpart=(int)x;*fracpart=x-*intpart;}","link":"/2018/02/01/siti8-1/"},{"title":"习题8-2 在数组中查找指定元素（15 分）","text":"习题8-2 在数组中查找指定元素（15 分）本题要求实现一个在数组中查找指定元素的简单函数。 函数接口定义：1int search( int list[], int n, int x ); 其中list[]是用户传入的数组；n（≥0）是list[]中元素的个数；x是待查找的元素。如果找到 则函数search返回相应元素的最小下标（下标从0开始），否则返回−1。 裁判测试程序样例：123456789101112131415161718192021222324#include &lt;stdio.h&gt;#define MAXN 10int search( int list[], int n, int x );int main(){ int i, index, n, x; int a[MAXN]; scanf(\"%d\", &amp;n); for( i = 0; i &lt; n; i++ ) scanf(\"%d\", &amp;a[i]); scanf(\"%d\", &amp;x); index = search( a, n, x ); if( index != -1 ) printf(\"index = %d\\n\", index); else printf(\"Not found\\n\"); return 0;}/* 你的代码将被嵌在这里 */ 输入样例1：12351 2 2 5 42 输出样例1：1index = 1 输入样例2：12351 2 2 5 40 输出样例2：1Not found 123456789101112131415161718192021222324252627282930313233int search( int list[], int n, int x );#define MAXN 10int main(){int i, index, n, x;int a[MAXN];scanf(\"%d\", &amp;n);for( i = 0; i &lt; n; i++ )scanf(\"%d\", &amp;a[i]);scanf(\"%d\", &amp;x);index = search( a, n, x );if( index != -1 )printf(\"index = %d\\n\", index);elseprintf(\"Not found\\n\");return 0;}int search( int list[], int n, int x ){int i,*p=&amp;list[0];for(i=0;i&lt;n;i++){if(x==*p++){break;}}if(i==n){return -1;}return i;}","link":"/2018/02/01/siti8-2/"},{"title":"习题8-3 数组循环右移（20 分）","text":"习题8-3 数组循环右移（20 分）本题要求实现一个对数组进行循环右移的简单函数：一个数组a中存有$n（\\gt 0）$个整数，将每个整数循环向右移$m（\\geq 0）$个位置，即将a中的数据由$\\left(a_{0} a_{1} \\cdots a_{n-1}\\right)$变换为$\\left(a_{n-m} \\cdots a_{n-1} a_{0} a_{1} \\cdots a_{n-m-1}\\right)$（最后m个数循环移至最前面的m个位置）。 函数接口定义：1int ArrayShift( int a[], int n, int m ); 其中a[]是用户传入的数组；n是数组的大小；m是右移的位数。函数ArrayShift须将循环右移后的数组仍然存在a[]中。 裁判测试程序样例：12345678910111213141516171819202122232425#include &lt;stdio.h&gt;#define MAXN 10int ArrayShift( int a[], int n, int m );int main(){ int a[MAXN], n, m; int i; scanf(\"%d %d\", &amp;n, &amp;m); for ( i = 0; i &lt; n; i++ ) scanf(\"%d\", &amp;a[i]); ArrayShift(a, n, m); for ( i = 0; i &lt; n; i++ ) { if (i != 0) printf(\" \"); printf(\"%d\", a[i]); } printf(\"\\n\"); return 0;}/* 你的代码将被嵌在这里 */ 输入样例：126 21 2 3 4 5 6 输出样例：15 6 1 2 3 4 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;stdio.h&gt;#define MAXN 10int ArrayShift( int a[], int n, int m );int main(){int a[MAXN], n, m;int i;scanf(\"%d %d\", &amp;n, &amp;m);for ( i = 0; i &lt; n; i++ ) scanf(\"%d\", &amp;a[i]);ArrayShift(a, n, m);for ( i = 0; i &lt; n; i++ ) {if (i != 0) printf(\" \");printf(\"%d\", a[i]);}printf(\"\\n\");return 0;}Reverse(int* arr, int b, int e){ for(; b &lt; e; b++, e--) { int temp = arr[e]; arr[e] = arr[b]; arr[b] = temp; }}ArrayShift(int* arr, int N, int k){ k %= N; Reverse(arr, 0, N - k - 1); Reverse(arr, N - k, N - 1); Reverse(arr, 0, N - 1);}","link":"/2018/02/01/siti8-3/"},{"title":"习题8-5 使用函数实现字符串部分复制（20 分）","text":"习题8-5 使用函数实现字符串部分复制（20 分）本题要求编写函数，将输入字符串t中从第m个字符开始的全部字符复制到字符串s中。 函数接口定义：1void strmcpy( char *t, int m, char *s ); 函数strmcpy将输入字符串char *t中从第m个字符开始的全部字符复制到字符串char *s中。若m超过输入字符串的长度，则结果字符串应为空串。 裁判测试程序样例：1234567891011121314151617181920#include &lt;stdio.h&gt;#define MAXN 20void strmcpy( char *t, int m, char *s );void ReadString( char s[] ); /* 由裁判实现，略去不表 */int main(){ char t[MAXN], s[MAXN]; int m; scanf(\"%d\\n\", &amp;m); ReadString(t); strmcpy( t, m, s ); printf(\"%s\\n\", s); return 0;}/* 你的代码将被嵌在这里 */ 输入样例：127happy new year 输出样例：1new year 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;stdio.h&gt;#define MAXN 20void strmcpy( char *t, int m, char *s );void ReadString( char s[] ); /* 由裁判实现，略去不表 */int main(){ char t[MAXN], s[MAXN]; int m; scanf(\"%d\\n\", &amp;m); ReadString(t); strmcpy( t, m, s ); printf(\"%s\\n\", s); return 0;}void ReadString(char s[]){gets(s);}void strmcpy(char *t, int m, char *s){ int i, j, length; length=0; while (t[length] != '\\0') length++; j = 0;if (m&gt;0 &amp;&amp; m&lt;=length){for (i=m-1; t[i] !='\\0'; i++){ s[j] = t[i]; j++;} s[j] = '\\0';}else s[0] = '\\0';}","link":"/2018/02/04/siti8-5/"},{"title":"习题8-6 删除字符（20 分）","text":"习题8-6 删除字符（20 分）本题要求实现一个删除字符串中的指定字符的简单函数。 函数接口定义：1void delchar( char *str, char c ); 其中char *str是传入的字符串，c是待删除的字符。函数delchar的功能是将字符串str中出现的所有c字符删除。 裁判测试程序样例：12345678910111213141516171819#include &lt;stdio.h&gt;#define MAXN 20void delchar( char *str, char c );void ReadString( char s[] ); /* 由裁判实现，略去不表 */int main(){ char str[MAXN], c; scanf(\"%c\\n\", &amp;c); ReadString(str); delchar(str, c); printf(\"%s\\n\", str); return 0;}/* 你的代码将被嵌在这里 */ 输入样例：12ahappy new year 输出样例：1hppy new yer 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;stdio.h&gt;#define MAXN 20void delchar( char *str, char c );int main(){ char str[MAXN], c; scanf(\"%c\\n\", &amp;c); gets(str); delchar(str, c); printf(\"%s\\n\", str); return 0;}void delchar( char *str, char c ){ int i=0,count=0,j=0,coun=0,q=0; char a [100],b[100]; while(str[i++]!='\\0'){count++;} for(i=0;i&lt;count;i++){ if(str[i]==c){continue;}else{ a[j++]=str[i]; coun++;}}j=0;for(i=0;i&lt;coun;i++){ str[q++]=a[j++];}//注意此处加终止符表示结束 str[q]='\\0';}","link":"/2018/02/06/siti8-6/"},{"title":"习题8-4 报数（20 分）","text":"习题8-4 报数（20 分）报数游戏是这样的：有n个人围成一圈，按顺序从1到n编好号。从第一个人开始报数，报到$m（\\lt n）$的人退出圈子；下一个人从1开始报数，报到m的人退出圈子。如此下去，直到留下最后一个人。 本题要求编写函数，给出每个人的退出顺序编号。 函数接口定义：1void CountOff( int n, int m, int out[] ); 其中n是初始人数；m是游戏规定的退出位次（保证为小于n的正整数）。函数CountOff将每个人的退出顺序编号存在数组out[]中。因为C语言数组下标是从0开始的，所以第i个位置上的人是第out[i-1]个退出的。 裁判测试程序样例：1234567891011121314151617181920#include &lt;stdio.h&gt;#define MAXN 20void CountOff( int n, int m, int out[] );int main(){ int out[MAXN], n, m; int i; scanf(\"%d %d\", &amp;n, &amp;m); CountOff( n, m, out ); for ( i = 0; i &lt; n; i++ ) printf(\"%d \", out[i]); printf(\"\\n\"); return 0;}/* 你的代码将被嵌在这里 */ 输入样例：111 3 输出样例：14 10 1 7 5 2 11 9 3 6 8 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;stdio.h&gt;#define MAXN 20void CountOff( int n, int m, int out[] );int main(){ int out[MAXN], n, m; int i; scanf(\"%d %d\", &amp;n, &amp;m); CountOff( n, m, out ); for ( i = 0; i &lt; n; i++ ) printf(\"%d \", out[i]); printf(\"\\n\"); return 0;}void CountOff( int n, int m, int out[] ){ int i=0,j=0,k=0,cnt=0,a[MAXN]; for(i=0;i&lt;n;i++) a[i] = i+1; i=0; while(cnt &lt; n){ if(a[i]!=0) k++; if(k==m){ j++; out[i]=j; k=0; cnt++; a[i]=0; } i++; if(i==n) i=0;}}","link":"/2018/02/04/siti8-4/"},{"title":"习题8-7 字符串排序（20 分）","text":"习题8-7 字符串排序（20 分）本题要求编写程序，读入5个字符串，按由小到大的顺序输出。 输入格式：输入为由空格分隔的5个非空字符串，每个字符串不包括空格、制表符、换行符等空白字符，长度小于80。 输出格式：按照以下格式输出排序后的结果： 12After sorted:每行一个字符串 输入样例：1red yellow blue green white 输出样例：123456After sorted:bluegreenredwhiteyellow 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;void bubble(char *color[], int n);int main(){ int i; char *pcolor[5], str[80]; for (i=0; i&lt;5; i++) { scanf(\"%s\", str); pcolor[i] = malloc(sizeof(char)*(strlen(str)+1)); strcpy(pcolor[i], str); } bubble(pcolor, 5); printf(\"After sorted:\\n\"); for (i=0; i&lt;5; i++) { printf(\"%s\\n\", pcolor[i]); free(pcolor[i]); } return 0;}void bubble(char *color[], int n){ int k, j; char *temp; for (k=1; k&lt;n; k++) { for (j=0; j&lt;n-k; j++) { if (strcmp(color[j], color[j+1]) &gt; 0) { temp = color[j]; color[j] = color[j+1]; color[j+1] = temp; } } }}","link":"/2018/02/06/siti8-7/"},{"title":"习题8-8 判断回文字符串（20 分）","text":"习题8-8 判断回文字符串（20 分）本题要求编写函数，判断给定的一串字符是否为“回文”。所谓“回文”是指顺读和倒读都一样的字符串。如“XYZYX”和“xyzzyx”都是回文。 函数接口定义：1bool palindrome( char *s ); 函数palindrome判断输入字符串char *s是否为回文。若是则返回true，否则返回false。 裁判测试程序样例：1234567891011121314151617181920212223#include &lt;stdio.h&gt;#include &lt;string.h&gt;#define MAXN 20typedef enum {false, true} bool;bool palindrome( char *s );int main(){ char s[MAXN]; scanf(\"%s\", s); if ( palindrome(s)==true ) printf(\"Yes\\n\"); else printf(\"No\\n\"); printf(\"%s\\n\", s); return 0;}/* 你的代码将被嵌在这里 */ 输入样例1：1thisistrueurtsisiht 输出样例1：12Yesthisistrueurtsisiht 输入样例2：1thisisnottrue 输出样例2：12Nothisisnottrue 12345678910111213141516171819202122232425262728293031323334353637#include &lt;stdio.h&gt;#include &lt;string.h&gt;#define MAXN 20typedef enum {false, true} bool;bool palindrome( char *s );int main(){ char s[MAXN]; scanf(\"%s\", s); if ( palindrome(s)==true ) printf(\"Yes\\n\"); else printf(\"No\\n\"); printf(\"%s\\n\", s); return 0;}bool palindrome( char *s ){ int len; len=strlen(s); int i,j; for(i=0,j=len-1;i&lt;=j;i++,j--){ if(*(s+i)!=*(s+j)){ break; } } if(i&gt;j){ return true; }else{ return false; }}","link":"/2018/02/06/siti8-8/"},{"title":"习题9-2 计算两个复数之积（15 分）","text":"习题9-2 计算两个复数之积（15 分）本题要求实现一个计算复数之积的简单函数。 函数接口定义：1struct complex multiply(struct complex x, struct complex y); 其中struct complex是复数结构体，其定义如下： 1234struct complex{ int real; int imag;}; 裁判测试程序样例：12345678910111213141516171819202122#include &lt;stdio.h&gt;struct complex{ int real; int imag;};struct complex multiply(struct complex x, struct complex y);int main(){ struct complex product, x, y; scanf(&quot;%d%d%d%d&quot;, &amp;x.real, &amp;x.imag, &amp;y.real, &amp;y.imag); product = multiply(x, y); printf(&quot;(%d+%di) * (%d+%di) = %d + %di\\n&quot;, x.real, x.imag, y.real, y.imag, product.real, product.imag); return 0;}/* 你的代码将被嵌在这里 */ 输入样例：13 4 5 6 输出样例：1(3+4i) * (5+6i) = -9 + 38i 123456789101112131415161718192021222324252627#include &lt;stdio.h&gt;struct complex{ int real; int imag;};struct complex multiply(struct complex x, struct complex y);int main(){ struct complex product, x, y; scanf(\"%d%d%d%d\", &amp;x.real, &amp;x.imag, &amp;y.real, &amp;y.imag); product = multiply(x, y); printf(\"(%d+%di) * (%d+%di) = %d + %di\\n\", x.real, x.imag, y.real, y.imag, product.real, product.imag); return 0;}struct complex multiply(struct complex x, struct complex y){ struct complex result; result.real = x.real*y.real - x.imag*y.imag; result.imag = x.imag*y.real + x.real*y.imag; return result;}","link":"/2018/02/06/siti9-2/"},{"title":"习题8-9 分类统计各类字符个数（15 分）","text":"习题8-9 分类统计各类字符个数（15 分）本题要求实现一个函数，统计给定字符串中的大写字母、小写字母、空格、数字以及其它字符各有多少。 函数接口定义：1void StringCount( char *s ); 其中 char *s 是用户传入的字符串。函数StringCount须在一行内按照 1大写字母个数 小写字母个数 空格个数 数字个数 其它字符个数 的格式输出。 裁判测试程序样例：1234567891011121314151617#include &lt;stdio.h&gt;#define MAXS 15void StringCount( char *s );void ReadString( char *s ); /* 由裁判实现，略去不表 */int main(){ char s[MAXS]; ReadString(s); StringCount(s); return 0;}/* Your function will be put here */ 输入样例：12aZ&amp;*?093 Az 输出样例：12 2 1 3 4 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;stdio.h&gt;#define MAXS 15void StringCount( char *s );void ReadString( char *s ); /* 由裁判实现，略去不表 */int main(){ char s[MAXS]; ReadString(s); StringCount(s); return 0;}void ReadString(char s[]){ gets(s);}void StringCount(char s[]){ int i, uppercase, lowercase, blank, digit, other; uppercase = lowercase = blank = digit = other =0; i = 0; while(s[i] != '\\0') { if (s[i] &gt;= 'A'&amp;&amp; s[i] &lt;= 'Z') uppercase++; else if (s[i] &gt;= 'a' &amp;&amp; s[i] &lt;= 'z') lowercase++; else if (s[i] == ' ') blank++; else if (s[i] &gt;= '0' &amp;&amp; s[i] &lt;= '9') digit++; else other++; i++; } printf(\"%d %d %d %d %d\\n\", uppercase, lowercase, blank, digit, other);}","link":"/2018/02/06/siti8-9/"},{"title":"习题9-3 平面向量加法（15 分）","text":"习题9-3 平面向量加法（15 分）本题要求编写程序，计算两个二维平面向量的和向量。 输入格式:输入在一行中按照 “$ x_{1} y_{1} x_{2} y_{2}$ ”的格式给出两个二维平面向量$v_{1}=\\left(x_{1}, y_{1}\\right)$和$v_{2}=\\left(x_{2}, y_{2}\\right)$的分量。 输出格式:在一行中按照(x, y)的格式输出和向量，坐标输出小数点后一位（注意不能输出−0.0）。 输入样例:13.5 -2.7 -13.9 8.7 输出样例:1(-10.4, 6.0) 1234567891011121314151617#include&lt;stdio.h&gt;int main(){ struct xy{ double x; double y; }; struct xy a,b,c; int i,j; scanf(\"%lf%lf%lf%lf\",&amp;a.x,&amp;a.y,&amp;b.x,&amp;b.y); c.x=a.x+b.x; c.y=a.y+b.y; if(c.x&lt;0&amp;&amp;c.x&gt;-0.05) c.x=0.0; if(c.y&lt;0&amp;&amp;c.y&gt;-0.05) c.y=0.0; printf(\"(%.1lf, %.1lf)\\n\",c.x,c.y); return 0;}","link":"/2018/02/08/siti9-3/"},{"title":"习题9-1 时间换算（15 分）","text":"习题9-1 时间换算（15 分）本题要求编写程序，以hh:mm:ss的格式输出某给定时间再过n秒后的时间值（超过23:59:59就从0点开始计时）。 输入格式：输入在第一行中以hh:mm:ss的格式给出起始时间，第二行给出整秒数n（&lt;60）。 输出格式：输出在一行中给出hh:mm:ss格式的结果时间。 输入样例：1211:59:4030 输出样例：112:00:10 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;stdio.h&gt;int main(){ struct time { int h; int m; int s; int n; }a; scanf(\"%d:%d:%d\", &amp;a.h, &amp;a.m, &amp;a.s); scanf(\"%d\", &amp;a.n); if (a.s+a.n&lt;59) a.s=a.s+a.n; else if (a.s+a.n==59) { a.s=0; if(a.m==59) { a.m=0; if(a.h==23) { a.h=0; }else { a.h=a.h+1; } } else { a.m=a.m+1; } } else if((a.s+a.n)&gt;59) { a.s=(a.n+a.s)-60; if(a.m==59) { a.m=0; if(a.h==23) { a.h=0; } else { a.h=a.h+1; } } else { a.m=a.m+1; } } printf(\"%02d:%02d:%02d\\n\", a.h, a.m, a.s); return 0;}","link":"/2018/02/06/siti9-1/"},{"title":"习题9-5 通讯录排序（20 分）","text":"习题9-5 通讯录排序（20 分）输入n个朋友的信息，包括姓名、生日、电话号码，本题要求编写程序，按照年龄从大到小的顺序依次输出通讯录。题目保证所有人的生日均不相同。 输入格式:输入第一行给出正整数$n（\\lt 10）$。随后n行，每行按照“姓名 生日 电话号码”的格式给出一位朋友的信息，其中“姓名”是长度不超过10的英文字母组成的字符串，“生日”是yyyymmdd格式的日期，“电话号码”是不超过17位的数字及+、-组成的字符串。 输出格式:按照年龄从大到小输出朋友的信息，格式同输出。 输入样例:12343zhang 19850403 13912345678wang 19821020 +86-0571-88018448qian 19840619 13609876543 输出样例:123wang 19821020 +86-0571-88018448qian 19840619 13609876543zhang 19850403 13912345678 123456789101112131415161718192021222324252627282930313233#include &lt;stdio.h&gt;#include &lt;string.h&gt;struct contact { char name[10]; int birthday; char telephoneNumber[17];};int main(){ int i, index, j, n; struct contact friend[10], temp; scanf(\"%d\", &amp;n); for (i=0; i&lt;n; i++) scanf(\"%s %d %s\", friend[i].name, &amp;friend[i].birthday, friend[i].telephoneNumber); for (i=0; i&lt;n-1; i++) { index=i; for (j=i+1; j&lt;n; j++) if (friend[index].birthday &gt; friend[j].birthday) index=j; temp=friend[index]; friend[index]=friend[i]; friend[i]=temp; } for (i=0; i&lt;n; i++) printf(\"%s %d %s\\n\", friend[i].name, friend[i].birthday, friend[i].telephoneNumber); return 0;}","link":"/2018/02/08/siti9-5/"},{"title":"习题9-4 查找书籍（20 分）","text":"习题9-4 查找书籍（20 分）给定n本书的名称和定价，本题要求编写程序，查找并输出其中定价最高和最低的书的名称和定价。 输入格式:输入第一行给出正整数$n（\\lt 10）$，随后给出n本书的信息。每本书在一行中给出书名，即长度不超过30的字符串，随后一行中给出正实数价格。题目保证没有同样价格的书。 输出格式:在一行中按照“价格, 书名”的格式先后输出价格最高和最低的书。价格保留2位小数。 输入样例:12345673Programming in C21.5Programming in VB18.5Programming in Delphi25.0 输出样例:1225.00, Programming in Delphi18.50, Programming in VB 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;stdio.h&gt;#include &lt;string.h&gt;struct book { char name[30]; double price;};int main(){ int n, i, maxIndex, minIndex; double max, min; struct book store[10]; scanf(\"%d\", &amp;n); for (i=0; i&lt;n; i++) { getchar(); gets(store[i].name); scanf(\"%lf\", &amp;store[i].price); } max = min = store[0].price; for (i=0; i&lt;n; i++) { if (max &lt;= store[i].price) { max = store[i].price; maxIndex = i; } if (min &gt;= store[i].price) { min = store[i].price; minIndex = i; } } printf(\"%.2f, %s\\n\", max, store[maxIndex].name); printf(\"%.2f, %s\\n\", min, store[minIndex].name); return 0;}","link":"/2018/02/08/siti9-4/"},{"title":"习题9-6 按等级统计学生成绩（20 分）","text":"习题9-6 按等级统计学生成绩（20 分）本题要求实现一个根据学生成绩设置其等级，并统计不及格人数的简单函数。 函数接口定义：1int set_grade( struct student *p, int n ); 其中p是指向学生信息的结构体数组的指针，该结构体的定义为： 123456struct student{ int num; char name[20]; int score; char grade;}; n是数组元素个数。学号num、姓名name和成绩score均是已经存储好的。set_grade函数需要根据学生的成绩score设置其等级grade。等级设置：85－100为A，70－84为B，60－69为C，0－59为D。同时，set_grade还需要返回不及格的人数。 裁判测试程序样例：123456789101112131415161718192021222324252627282930#include &lt;stdio.h&gt;#define MAXN 10struct student{ int num; char name[20]; int score; char grade;};int set_grade( struct student *p, int n );int main(){ struct student stu[MAXN], *ptr; int n, i, count; ptr = stu; scanf(\"%d\\n\", &amp;n); for(i = 0; i &lt; n; i++){ scanf(\"%d%s%d\", &amp;stu[i].num, stu[i].name, &amp;stu[i].score); } count = set_grade(ptr, n); printf(\"The count for failed (&lt;60): %d\\n\", count); printf(\"The grades:\\n\"); for(i = 0; i &lt; n; i++) printf(\"%d %s %c\\n\", stu[i].num, stu[i].name, stu[i].grade); return 0;}/* 你的代码将被嵌在这里 */ 输入样例：12345678910111031001 annie 8531002 bonny 7531003 carol 7031004 dan 8431005 susan 9031006 paul 6931007 pam 6031008 apple 5031009 nancy 10031010 bob 78 输出样例：123456789101112The count for failed (&lt;60): 1The grades:31001 annie A31002 bonny B31003 carol B31004 dan B31005 susan A31006 paul C31007 pam C31008 apple D31009 nancy A31010 bob B 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;stdio.h&gt;#define MAXN 10struct student{ int num; char name[20]; int score; char grade;};int set_grade( struct student *p, int n );int main(){ struct student stu[MAXN], *ptr; int n, i, count; ptr = stu; scanf(\"%d\\n\", &amp;n); for(i = 0; i &lt; n; i++){ scanf(\"%d%s%d\", &amp;stu[i].num, stu[i].name, &amp;stu[i].score); } count = set_grade(ptr, n); printf(\"The count for failed (&lt;60): %d\\n\", count); printf(\"The grades:\\n\"); for(i = 0; i &lt; n; i++) printf(\"%d %s %c\\n\", stu[i].num, stu[i].name, stu[i].grade); return 0;}int set_grade(struct student *p, int n){ int i, count=0; for (i=1; i&lt;=n; i++,p++) { if (p-&gt;score &gt;= 85) p-&gt;grade = 'A'; else if (p-&gt;score &gt;= 70) p-&gt;grade = 'B'; else if (p-&gt;score &gt;= 60) p-&gt;grade = 'C'; else { p-&gt;grade = 'D'; count++; } } return count; }","link":"/2018/02/08/siti9-6/"},{"title":"‘string’ does not name a type","text":"‘string’ does not name a type不是第一次遇到，但還是耽誤一小會，為了不在耽誤時間，所以還是把錯誤寫下‘string’ does not name a type 缺失12#include &lt;string&gt;","link":"/2016/04/27/＆string＊-does-not-name-a-type/"}],"tags":[{"name":"編譯原理","slug":"編譯原理","link":"/tags/編譯原理/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"Hibernate","slug":"Hibernate","link":"/tags/Hibernate/"},{"name":"MinGW","slug":"MinGW","link":"/tags/MinGW/"},{"name":"bugs","slug":"bugs","link":"/tags/bugs/"},{"name":"oracle","slug":"oracle","link":"/tags/oracle/"},{"name":"簡歷","slug":"簡歷","link":"/tags/簡歷/"},{"name":"findbugs","slug":"findbugs","link":"/tags/findbugs/"},{"name":"java","slug":"java","link":"/tags/java/"},{"name":"java面试","slug":"java面试","link":"/tags/java面试/"},{"name":"基础编程题目集","slug":"基础编程题目集","link":"/tags/基础编程题目集/"},{"name":"leetcode Easy Array HashTable","slug":"leetcode-Easy-Array-HashTable","link":"/tags/leetcode-Easy-Array-HashTable/"},{"name":"leetcode","slug":"leetcode","link":"/tags/leetcode/"},{"name":"leetcode LinkedList","slug":"leetcode-LinkedList","link":"/tags/leetcode-LinkedList/"},{"name":"leetcode Stack","slug":"leetcode-Stack","link":"/tags/leetcode-Stack/"},{"name":"leetcode Stack Queue","slug":"leetcode-Stack-Queue","link":"/tags/leetcode-Stack-Queue/"},{"name":"leetcode Array TwoPointers","slug":"leetcode-Array-TwoPointers","link":"/tags/leetcode-Array-TwoPointers/"},{"name":"leetcode TwoPointers","slug":"leetcode-TwoPointers","link":"/tags/leetcode-TwoPointers/"},{"name":"leetcode TwoPointers String","slug":"leetcode-TwoPointers-String","link":"/tags/leetcode-TwoPointers-String/"},{"name":"leetcode Array BinarySearch","slug":"leetcode-Array-BinarySearch","link":"/tags/leetcode-Array-BinarySearch/"},{"name":"leetcode Easy Math","slug":"leetcode-Easy-Math","link":"/tags/leetcode-Easy-Math/"},{"name":"浙大版《C语言程序设计（第3版）》题目集","slug":"浙大版《C语言程序设计（第3版）》题目集","link":"/tags/浙大版《C语言程序设计（第3版）》题目集/"},{"name":"markdown","slug":"markdown","link":"/tags/markdown/"},{"name":"maven","slug":"maven","link":"/tags/maven/"},{"name":"个人简历","slug":"个人简历","link":"/tags/个人简历/"},{"name":"个人观点","slug":"个人观点","link":"/tags/个人观点/"},{"name":"浙大版《C语言程序设计实验与习题指导（第3版）》题目集","slug":"浙大版《C语言程序设计实验与习题指导（第3版）》题目集","link":"/tags/浙大版《C语言程序设计实验与习题指导（第3版）》题目集/"},{"name":"数据结构与算法题目集（中文）","slug":"数据结构与算法题目集（中文）","link":"/tags/数据结构与算法题目集（中文）/"},{"name":"cpp","slug":"cpp","link":"/tags/cpp/"}],"categories":[{"name":"編譯原理","slug":"編譯原理","link":"/categories/編譯原理/"},{"name":"Hexo","slug":"Hexo","link":"/categories/Hexo/"},{"name":"Hibernate","slug":"Hibernate","link":"/categories/Hibernate/"},{"name":"MinGW","slug":"MinGW","link":"/categories/MinGW/"},{"name":"簡歷","slug":"簡歷","link":"/categories/簡歷/"},{"name":"findbugs","slug":"findbugs","link":"/categories/findbugs/"},{"name":"java","slug":"java","link":"/categories/java/"},{"name":"面試","slug":"面試","link":"/categories/面試/"},{"name":"java面试","slug":"java面试","link":"/categories/java面试/"},{"name":"基础编程题目集","slug":"基础编程题目集","link":"/categories/基础编程题目集/"},{"name":"leetcode","slug":"leetcode","link":"/categories/leetcode/"},{"name":"浙大版《C语言程序设计（第3版）》题目集","slug":"浙大版《C语言程序设计（第3版）》题目集","link":"/categories/浙大版《C语言程序设计（第3版）》题目集/"},{"name":"markdown","slug":"markdown","link":"/categories/markdown/"},{"name":"maven","slug":"maven","link":"/categories/maven/"},{"name":"oracle","slug":"oracle","link":"/categories/oracle/"},{"name":"个人简历","slug":"个人简历","link":"/categories/个人简历/"},{"name":"个人观点","slug":"个人观点","link":"/categories/个人观点/"},{"name":"浙大版《C语言程序设计实验与习题指导（第3版）》题目集","slug":"浙大版《C语言程序设计实验与习题指导（第3版）》题目集","link":"/categories/浙大版《C语言程序设计实验与习题指导（第3版）》题目集/"},{"name":"数据结构与算法题目集（中文）","slug":"数据结构与算法题目集（中文）","link":"/categories/数据结构与算法题目集（中文）/"},{"name":"cpp","slug":"cpp","link":"/categories/cpp/"}]}